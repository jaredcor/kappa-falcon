{"ast":null,"code":"var Buffer = require(\"buffer\").Buffer;\nvar events = require(\"events\");\nvar util = require(\"util\");\nvar ENETModule = require(\"../build/enet.js\");\nvar enet = require(\"../index.js\");\nvar jsapi_ = ENETModule.jsapi;\nvar enet_ = ENETModule.libenet;\nvar ENET_HOST_SERVICE_INTERVAL = 10; //milliseconds\n\nutil.inherits(Host, events.EventEmitter);\nmodule.exports.Host = Host;\nmodule.exports.createServer = createServer;\nmodule.exports.createClient = createClient;\nmodule.exports.createServerFromSocket = createServerFromSocket;\nfunction createServer(arg, callback) {\n  return createHost(arg, callback, \"server\");\n}\nfunction createClient(arg, callback) {\n  return createHost(arg, callback, \"client\");\n}\nfunction createServerFromSocket(arg, callback) {\n  return createHost(arg, callback, \"custom\");\n}\nfunction createHost(arg, callback, host_type) {\n  var host, socket;\n  var opt = {};\n  if (typeof arg === \"function\") {\n    callback = arg;\n  } else {\n    opt = arg || opt;\n  }\n  callback = callback || function () {};\n  try {\n    host = new Host(opt.address, opt.peers, opt.channels, opt.down, opt.up, host_type, opt.socket);\n  } catch (e) {\n    if (typeof callback === 'function') callback(e);\n    return undefined;\n  }\n  if (!host || host._pointer === 0) {\n    setTimeout(function () {\n      callback(new Error(\"host-creation-error\"));\n    });\n    return undefined;\n  }\n  socket = host._socket;\n  if (!socket) {\n    setTimeout(function () {\n      callback(new Error(\"socket-creation-error\"));\n    });\n    return undefined;\n  }\n\n  //catch socket bind errors\n  socket.on(\"error\", function (e) {\n    host._socket_closed = true;\n\n    //server will bind so error will be called before listening if error occurs\n    //so we can return the error in the callback\n    if (host_type === \"server\") {\n      callback(e);\n    } else {\n      //for client and custom host application can listen for the error event\n      host.emit(\"error\", e);\n    }\n    host.destroy();\n  });\n  socket.on(\"close\", function () {\n    host._socket_closed = true;\n    host.destroy();\n  });\n  socket.on(\"listening\", function () {\n    socket.setBroadcast(true);\n    //for server host callback when socket is listening\n    if (host_type === \"server\" && typeof callback === 'function') callback(undefined, host);\n  });\n\n  //bind the socket\n  if (host_type === \"server\" || host_type === \"custom\") jsapi_.enet_host_bind(host._pointer);\n  if ((host_type === \"client\" || host_type === \"custom\") && typeof callback === 'function') {\n    setTimeout(function () {\n      callback(undefined, host); //clients get host in callback before socket is listening.\n    });\n  }\n\n  return host;\n}\nfunction Host(address, maxpeers, maxchannels, bw_down, bw_up, host_type, custom_socket) {\n  events.EventEmitter.call(this);\n  this.setMaxListeners(0);\n  this.connectedPeers = {};\n  var enetAddr;\n  var self = this;\n  var pointer = 0;\n  var socketfd, stream;\n  switch (host_type) {\n    case \"client\":\n      this._type = \"client\";\n      pointer = jsapi_.enet_host_create_client(maxpeers || 128, maxchannels || 5, bw_down || 0, bw_up || 0);\n      break;\n    case \"custom\":\n      this._type = \"custom\";\n      //insert a socket into emscrtipten FS\n      socketfd = ENETModule[\"createStreamFromSocket\"](custom_socket);\n      pointer = jsapi_.enet_host_from_socket(socketfd, 0, maxpeers || 128, maxchannels || 5, bw_down || 0, bw_up || 0);\n      break;\n    case \"server\":\n      this._type = \"server\";\n      address = address || {\n        address: \"0.0.0.0\",\n        port: 0\n      };\n      enetAddr = address instanceof enet.Address ? address : new enet.Address(address);\n      pointer = jsapi_.enet_host_create_server(enetAddr.host(), enetAddr.port(), maxpeers || 128, maxchannels || 5, bw_down || 0, bw_up || 0);\n      break;\n    default:\n      //create a host using the createClient and createServer methods.\n      throw new Error(\"Do not create a new instance of enet.Host. Use enet.createServer() and enet.createClient() instead.\");\n  }\n  if (pointer === 0) {\n    throw 'failed to create ENet host';\n  }\n  self._event = new enet.Event(); //allocate memory for events - free it when we destroy the host\n  self._pointer = pointer;\n  socketfd = jsapi_.host_get_socket(self._pointer);\n  self._socket = ENETModule[\"getStreamSocket\"](socketfd);\n  self._packet_free_func_ptr = ENETModule[\"Runtime_addFunction\"](function (packet_ptr) {\n    //grab the callback from peer._packet_callback_functions, call its callback indicate if sent flag\n    //delete from peer._packet_callback_functions\n    var packet, callback;\n    Object.keys(self._packet_callback_functions).forEach(function (ptr) {\n      //keys are strings\n      if (Number(ptr) === packet_ptr) {\n        packet = new enet.Packet(packet_ptr);\n        callback = self._packet_callback_functions[ptr];\n        delete self._packet_callback_functions[ptr];\n        callback(packet.wasSent() ? undefined : \"packet-not-delivered\");\n        return;\n      }\n    });\n  });\n  self._packet_callback_functions = {}; //packet pointers and their free callback function\n}\n\nHost.prototype._addPacketCallback = function (packet, callback) {\n  packet._attachFreeCallback(this._packet_free_func_ptr);\n  this._packet_callback_functions[packet._pointer] = callback;\n};\nHost.prototype.isOffline = function () {\n  return typeof this._pointer === \"undefined\" || this._pointer === 0 || this._shutting_down || this._socket_closed;\n};\nHost.prototype.isOnline = function () {\n  return this.isOffline() === false;\n};\nHost.prototype._service = function () {\n  var self = this;\n  var peer;\n  var recvdAddr;\n  if (self._servicing) return;\n  self._servicing = true;\n  if (!self._pointer || !self._event || self._socket_closed) return;\n  var err = enet_.host_service(self._pointer, self._event._pointer, 0);\n  while (err > 0) {\n    switch (self._event.type()) {\n      case 1:\n        //connect\n        peer = self.connectedPeers[self._event.peerPtr()];\n        if (peer) {\n          //outgoing connection\n          peer.emit(\"connect\");\n          self.emit(\"connect\", peer, undefined, true //local host initiated the connection to foriegn host\n          );\n        } else {\n          peer = self.connectedPeers[self._event.peerPtr()] = self._event.peer();\n          peer._host = self;\n          //incoming connection\n          self.emit(\"connect\", peer, self._event.data(), false //foreign host initiated connection to local host\n          );\n        }\n\n        break;\n      case 2:\n        //disconnect\n        peer = self.connectedPeers[self._event.peerPtr()];\n        if (peer) {\n          peer._delete(true, self._event.data());\n        }\n        break;\n      case 3:\n        //receive\n        peer = self.connectedPeers[self._event.peerPtr()] || self._event.peer();\n        self.emit(\"message\", peer, self._event.packet(), self._event.channelID());\n        //todo - return packet.data() not packet (incase app wants to handle the packet asynchronously)\n        peer.emit(\"message\", self._event.packet(), self._event.channelID());\n        self._event.packet().destroy();\n        break;\n      case 100:\n        //JSON,telex\n        recvdAddr = self.receivedAddress();\n        self.emit(\"telex\", self._event.packet().data(), {\n          'address': recvdAddr.address,\n          'port': recvdAddr.port\n        });\n        self._event.packet().destroy();\n        break;\n    }\n    if (!self._pointer || !self._event || self._socket_closed) return;\n    err = enet_.host_service(self._pointer, self._event._pointer, 0);\n  }\n  if (err < 0) console.error(\"Error servicing host: \", err);\n  self._servicing = false;\n};\nHost.prototype.destroy = function () {\n  var self = this;\n  var peer, peer_ptr;\n  if (self._shutting_down) return;\n  self._shutting_down = true;\n  if (self._io_loop) {\n    clearInterval(self._io_loop);\n  }\n  if (typeof self._pointer === 'undefined' || self._pointer === 0) return;\n  for (peer_ptr in self.connectedPeers) {\n    peer = self.connectedPeers[peer_ptr];\n    if (peer && peer._pointer !== 0) {\n      if (!self._socket_closed) enet_.peer_disconnect_now(peer_ptr, 0);\n      peer._pointer = 0;\n      peer.emit(\"disconnect\", 0);\n    }\n  }\n  delete self.connectedPeers;\n  self.flush();\n  if (self._event) self._event.free();\n  try {\n    if (self._pointer) enet_.host_destroy(self._pointer);\n  } catch (e) {}\n  if (self._packet_free_func_ptr) ENETModule[\"Runtime_removeFunction\"](self._packet_free_func_ptr);\n  delete self._packet_callback_functions;\n  delete self._pointer;\n  delete self._event;\n  delete self._io_loop;\n  delete self._socket;\n  self.emit(\"destroy\");\n};\nHost.prototype.stop = Host.prototype.destroy;\nHost.prototype.receivedAddress = function () {\n  if (this.isOffline()) return;\n  var ptr = jsapi_.host_get_receivedAddress(this._pointer);\n  var addr = new enet.Address(ptr);\n  return {\n    address: addr.address(),\n    port: addr.port()\n  };\n};\nHost.prototype.address = function () {\n  if (this.isOffline()) return;\n  return this._socket.address();\n};\nHost.prototype.send = function (ip, port, buff, callback) {\n  if (this.isOffline()) return;\n  this._socket.send(buff, 0, buff.length, port, ip, callback);\n};\nHost.prototype.flush = function () {\n  if (this.isOffline()) return;\n  enet_.host_flush(this._pointer);\n};\nHost.prototype.connect = function (address, channelCount, data, callback) {\n  if (this.isOffline()) {\n    if (typeof callback === 'function') callback(new Error(\"host-destroyed\"));\n    return;\n  }\n  var self = this;\n  var peer;\n  var enetAddr = address instanceof enet.Address ? address : new enet.Address(address);\n  var ptr = jsapi_.enet_host_connect(this._pointer, enetAddr.host(), enetAddr.port(), channelCount || 5, data || 0);\n  self.firstStart(); //start servicing if not yet started\n\n  var succeeded = false;\n  if (ptr) {\n    peer = new enet.Peer(ptr);\n    peer._host = self;\n    self.connectedPeers[ptr] = peer;\n    if (typeof callback === 'function') {\n      peer.on(\"connect\", function () {\n        succeeded = true;\n        callback(undefined, peer);\n      });\n      peer.on(\"disconnect\", function () {\n        if (!succeeded) callback(new Error(\"failed\"));\n      });\n    }\n    return peer;\n  }\n  if (typeof callback === 'function') {\n    setTimeout(function () {\n      callback(new Error(\"maxpeers\"));\n    });\n  }\n  return undefined;\n};\nHost.prototype.throttleBandwidth = function () {\n  if (this.isOffline()) return;\n  enet_.host_bandwidth_throttle(this._pointer);\n  return this;\n};\nHost.prototype.enableCompression = function () {\n  if (this._pointer) {\n    enet_.host_compress_with_range_coder(this._pointer);\n  }\n  return this;\n};\nHost.prototype.disableCompression = function () {\n  if (this._pointer) {\n    enet_.host_compress(this._pointer, 0); //passing a 0 disables compression\n  }\n\n  return this;\n};\nHost.prototype.broadcast = function (channel, packet) {\n  if (this.isOffline()) return;\n  if (packet instanceof Buffer) packet = new enet.Packet(packet, enet.PACKET_FLAG.RELIABLE);\n  enet_.host_broadcast(this._pointer, channel, packet._pointer);\n};\nHost.prototype.peers = function () {\n  var peer_ptr,\n    peers = [];\n  for (peer_ptr in this.connectedPeers) {\n    peers.push(this.connectedPeers[peer_ptr]);\n  }\n  return peers;\n};\nHost.prototype.firstStart = function () {\n  var self = this;\n  if (!self._io_loop) {\n    self._io_loop = setInterval(function () {\n      self._service();\n    }, ENET_HOST_SERVICE_INTERVAL);\n  }\n};\nHost.prototype.start = function (ms_interval) {\n  var self = this;\n  if (!self._pointer) return; //cannot start a host that is not initialised\n  if (self._io_loop) {\n    clearInterval(self._io_loop);\n  }\n  self._io_loop = setInterval(function () {\n    self._service();\n  }, ms_interval || ENET_HOST_SERVICE_INTERVAL);\n};","map":{"version":3,"names":["Buffer","require","events","util","ENETModule","enet","jsapi_","jsapi","enet_","libenet","ENET_HOST_SERVICE_INTERVAL","inherits","Host","EventEmitter","module","exports","createServer","createClient","createServerFromSocket","arg","callback","createHost","host_type","host","socket","opt","address","peers","channels","down","up","e","undefined","_pointer","setTimeout","Error","_socket","on","_socket_closed","emit","destroy","setBroadcast","enet_host_bind","maxpeers","maxchannels","bw_down","bw_up","custom_socket","call","setMaxListeners","connectedPeers","enetAddr","self","pointer","socketfd","stream","_type","enet_host_create_client","enet_host_from_socket","port","Address","enet_host_create_server","_event","Event","host_get_socket","_packet_free_func_ptr","packet_ptr","packet","Object","keys","_packet_callback_functions","forEach","ptr","Number","Packet","wasSent","prototype","_addPacketCallback","_attachFreeCallback","isOffline","_shutting_down","isOnline","_service","peer","recvdAddr","_servicing","err","host_service","type","peerPtr","_host","data","_delete","channelID","receivedAddress","console","error","peer_ptr","_io_loop","clearInterval","peer_disconnect_now","flush","free","host_destroy","stop","host_get_receivedAddress","addr","send","ip","buff","length","host_flush","connect","channelCount","enet_host_connect","firstStart","succeeded","Peer","throttleBandwidth","host_bandwidth_throttle","enableCompression","host_compress_with_range_coder","disableCompression","host_compress","broadcast","channel","PACKET_FLAG","RELIABLE","host_broadcast","push","setInterval","start","ms_interval"],"sources":["/Users/jaredcortez/node_modules/enet/lib/Host.js"],"sourcesContent":["var Buffer = require(\"buffer\").Buffer;\nvar events = require(\"events\");\nvar util = require(\"util\");\nvar ENETModule = require(\"../build/enet.js\");\nvar enet = require(\"../index.js\");\n\nvar jsapi_ = ENETModule.jsapi;\nvar enet_ = ENETModule.libenet;\n\nvar ENET_HOST_SERVICE_INTERVAL = 10; //milliseconds\n\nutil.inherits(Host, events.EventEmitter);\n\nmodule.exports.Host = Host;\nmodule.exports.createServer = createServer;\nmodule.exports.createClient = createClient;\nmodule.exports.createServerFromSocket = createServerFromSocket;\n\nfunction createServer(arg, callback) {\n\treturn createHost(arg, callback, \"server\");\n}\n\nfunction createClient(arg, callback) {\n\treturn createHost(arg, callback, \"client\");\n}\n\nfunction createServerFromSocket(arg, callback) {\n\treturn createHost(arg, callback, \"custom\");\n}\n\nfunction createHost(arg, callback, host_type) {\n\tvar host, socket;\n\tvar opt = {};\n\n\tif (typeof arg === \"function\") {\n\t\tcallback = arg;\n\t} else {\n\t\topt = arg || opt;\n\t}\n\n\tcallback = callback || function () {};\n\n\ttry {\n\t\thost = new Host(opt.address, opt.peers, opt.channels, opt.down, opt.up, host_type, opt.socket);\n\t} catch (e) {\n\t\tif (typeof callback === 'function') callback(e);\n\t\treturn undefined;\n\t}\n\n\tif (!host || host._pointer === 0) {\n\t\tsetTimeout(function () {\n\t\t\tcallback(new Error(\"host-creation-error\"));\n\t\t});\n\t\treturn undefined;\n\t}\n\n\tsocket = host._socket;\n\n\tif (!socket) {\n\t\tsetTimeout(function () {\n\t\t\tcallback(new Error(\"socket-creation-error\"));\n\t\t});\n\t\treturn undefined;\n\t}\n\n\t//catch socket bind errors\n\tsocket.on(\"error\", function (e) {\n\t\thost._socket_closed = true;\n\n\t\t//server will bind so error will be called before listening if error occurs\n\t\t//so we can return the error in the callback\n\t\tif (host_type === \"server\") {\n\t\t\tcallback(e);\n\t\t} else {\n\t\t\t//for client and custom host application can listen for the error event\n\t\t\thost.emit(\"error\", e);\n\t\t}\n\n\t\thost.destroy();\n\t});\n\n\tsocket.on(\"close\", function () {\n\t\thost._socket_closed = true;\n\t\thost.destroy();\n\t});\n\n\tsocket.on(\"listening\", function () {\n\t\tsocket.setBroadcast(true);\n\t\t//for server host callback when socket is listening\n\t\tif (host_type === \"server\" && typeof callback === 'function') callback(undefined, host);\n\t});\n\n\t//bind the socket\n\tif (host_type === \"server\" || host_type === \"custom\") jsapi_.enet_host_bind(host._pointer);\n\n\tif ((host_type === \"client\" || host_type === \"custom\") && typeof callback === 'function') {\n\t\tsetTimeout(function () {\n\t\t\tcallback(undefined, host); //clients get host in callback before socket is listening.\n\t\t});\n\t}\n\n\treturn host;\n}\n\nfunction Host(address, maxpeers, maxchannels, bw_down, bw_up, host_type, custom_socket) {\n\tevents.EventEmitter.call(this);\n\tthis.setMaxListeners(0);\n\tthis.connectedPeers = {};\n\tvar enetAddr;\n\tvar self = this;\n\tvar pointer = 0;\n\tvar socketfd, stream;\n\n\tswitch (host_type) {\n\tcase \"client\":\n\t\tthis._type = \"client\";\n\t\tpointer = jsapi_.enet_host_create_client(maxpeers || 128, maxchannels || 5, bw_down || 0, bw_up ||\n\t\t\t0);\n\t\tbreak;\n\n\tcase \"custom\":\n\t\tthis._type = \"custom\";\n\t\t//insert a socket into emscrtipten FS\n\t\tsocketfd = ENETModule[\"createStreamFromSocket\"](custom_socket);\n\t\tpointer = jsapi_.enet_host_from_socket(socketfd, 0, maxpeers || 128, maxchannels || 5, bw_down ||\n\t\t\t0,\n\t\t\tbw_up ||\n\t\t\t0);\n\t\tbreak;\n\n\tcase \"server\":\n\t\tthis._type = \"server\";\n\t\taddress = address || {\n\t\t\taddress: \"0.0.0.0\",\n\t\t\tport: 0\n\t\t};\n\t\tenetAddr = (address instanceof enet.Address) ? address : new enet.Address(address);\n\t\tpointer = jsapi_.enet_host_create_server(enetAddr.host(), enetAddr.port(), maxpeers || 128,\n\t\t\tmaxchannels ||\n\t\t\t5,\n\t\t\tbw_down || 0,\n\t\t\tbw_up || 0);\n\t\tbreak;\n\n\tdefault:\n\t\t//create a host using the createClient and createServer methods.\n\t\tthrow (new Error(\n\t\t\t\"Do not create a new instance of enet.Host. Use enet.createServer() and enet.createClient() instead.\"\n\t\t));\n\t}\n\n\tif (pointer === 0) {\n\t\tthrow ('failed to create ENet host');\n\t}\n\n\tself._event = new enet.Event(); //allocate memory for events - free it when we destroy the host\n\tself._pointer = pointer;\n\tsocketfd = jsapi_.host_get_socket(self._pointer);\n\tself._socket = ENETModule[\"getStreamSocket\"](socketfd);\n\n\tself._packet_free_func_ptr = ENETModule[\"Runtime_addFunction\"](function (packet_ptr) {\n\t\t//grab the callback from peer._packet_callback_functions, call its callback indicate if sent flag\n\t\t//delete from peer._packet_callback_functions\n\t\tvar packet, callback;\n\t\tObject.keys(self._packet_callback_functions).forEach(function (ptr) {\n\t\t\t//keys are strings\n\t\t\tif (Number(ptr) === packet_ptr) {\n\t\t\t\tpacket = new enet.Packet(packet_ptr);\n\t\t\t\tcallback = self._packet_callback_functions[ptr];\n\t\t\t\tdelete self._packet_callback_functions[ptr];\n\t\t\t\tcallback(packet.wasSent() ? undefined : \"packet-not-delivered\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t});\n\t});\n\n\tself._packet_callback_functions = {}; //packet pointers and their free callback function\n}\n\nHost.prototype._addPacketCallback = function (packet, callback) {\n\tpacket._attachFreeCallback(this._packet_free_func_ptr);\n\tthis._packet_callback_functions[packet._pointer] = callback;\n};\n\nHost.prototype.isOffline = function () {\n\treturn (typeof this._pointer === \"undefined\" || this._pointer === 0 || this._shutting_down || this._socket_closed);\n};\n\nHost.prototype.isOnline = function () {\n\treturn (this.isOffline() === false);\n};\n\nHost.prototype._service = function () {\n\tvar self = this;\n\tvar peer;\n\tvar recvdAddr;\n\tif (self._servicing) return;\n\tself._servicing = true;\n\n\tif (!self._pointer || !self._event || self._socket_closed) return;\n\tvar err = enet_.host_service(self._pointer, self._event._pointer, 0);\n\twhile (err > 0) {\n\n\t\tswitch (self._event.type()) {\n\t\tcase 1: //connect\n\t\t\tpeer = self.connectedPeers[self._event.peerPtr()];\n\t\t\tif (peer) {\n\t\t\t\t//outgoing connection\n\t\t\t\tpeer.emit(\"connect\");\n\t\t\t\tself.emit(\"connect\",\n\t\t\t\t\tpeer,\n\t\t\t\t\tundefined,\n\t\t\t\t\ttrue //local host initiated the connection to foriegn host\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpeer = self.connectedPeers[self._event.peerPtr()] = self._event.peer();\n\t\t\t\tpeer._host = self;\n\t\t\t\t//incoming connection\n\t\t\t\tself.emit(\"connect\",\n\t\t\t\t\tpeer,\n\t\t\t\t\tself._event.data(),\n\t\t\t\t\tfalse //foreign host initiated connection to local host\n\t\t\t\t);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: //disconnect\n\t\t\tpeer = self.connectedPeers[self._event.peerPtr()];\n\t\t\tif (peer) {\n\t\t\t\tpeer._delete(true, self._event.data());\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3: //receive\n\t\t\tpeer = self.connectedPeers[self._event.peerPtr()] || self._event.peer();\n\t\t\tself.emit(\"message\",\n\t\t\t\tpeer,\n\t\t\t\tself._event.packet(),\n\t\t\t\tself._event.channelID()\n\t\t\t);\n\t\t\t//todo - return packet.data() not packet (incase app wants to handle the packet asynchronously)\n\t\t\tpeer.emit(\"message\", self._event.packet(), self._event.channelID());\n\t\t\tself._event.packet().destroy();\n\t\t\tbreak;\n\t\tcase 100: //JSON,telex\n\t\t\trecvdAddr = self.receivedAddress();\n\t\t\tself.emit(\"telex\",\n\t\t\t\tself._event.packet().data(), {\n\t\t\t\t\t'address': recvdAddr.address,\n\t\t\t\t\t'port': recvdAddr.port\n\t\t\t\t}\n\t\t\t);\n\t\t\tself._event.packet().destroy();\n\t\t\tbreak;\n\t\t}\n\t\tif (!self._pointer || !self._event || self._socket_closed) return;\n\n\t\terr = enet_.host_service(self._pointer, self._event._pointer, 0);\n\t}\n\tif (err < 0) console.error(\"Error servicing host: \", err);\n\tself._servicing = false;\n};\n\nHost.prototype.destroy = function () {\n\tvar self = this;\n\tvar peer, peer_ptr;\n\tif (self._shutting_down) return;\n\tself._shutting_down = true;\n\n\tif (self._io_loop) {\n\t\tclearInterval(self._io_loop);\n\t}\n\n\tif (typeof self._pointer === 'undefined' || self._pointer === 0) return;\n\n\tfor (peer_ptr in self.connectedPeers) {\n\t\tpeer = self.connectedPeers[peer_ptr];\n\t\tif (peer && peer._pointer !== 0) {\n\t\t\tif (!self._socket_closed) enet_.peer_disconnect_now(peer_ptr, 0);\n\t\t\tpeer._pointer = 0;\n\t\t\tpeer.emit(\"disconnect\", 0);\n\t\t}\n\t}\n\tdelete self.connectedPeers;\n\tself.flush();\n\n\tif (self._event) self._event.free();\n\n\ttry {\n\t\tif (self._pointer) enet_.host_destroy(self._pointer);\n\t} catch (e) {}\n\n\tif (self._packet_free_func_ptr) ENETModule[\"Runtime_removeFunction\"](self._packet_free_func_ptr);\n\tdelete self._packet_callback_functions;\n\n\tdelete self._pointer;\n\tdelete self._event;\n\tdelete self._io_loop;\n\tdelete self._socket;\n\tself.emit(\"destroy\");\n};\n\nHost.prototype.stop = Host.prototype.destroy;\n\nHost.prototype.receivedAddress = function () {\n\tif (this.isOffline()) return;\n\tvar ptr = jsapi_.host_get_receivedAddress(this._pointer);\n\tvar addr = new enet.Address(ptr);\n\treturn ({\n\t\taddress: addr.address(),\n\t\tport: addr.port()\n\t});\n};\n\nHost.prototype.address = function () {\n\tif (this.isOffline()) return;\n\treturn this._socket.address();\n};\n\nHost.prototype.send = function (ip, port, buff, callback) {\n\tif (this.isOffline()) return;\n\tthis._socket.send(buff, 0, buff.length, port, ip, callback);\n};\n\nHost.prototype.flush = function () {\n\tif (this.isOffline()) return;\n\tenet_.host_flush(this._pointer);\n};\n\nHost.prototype.connect = function (address, channelCount, data, callback) {\n\tif (this.isOffline()) {\n\t\tif (typeof callback === 'function') callback(new Error(\"host-destroyed\"));\n\t\treturn;\n\t}\n\n\tvar self = this;\n\tvar peer;\n\tvar enetAddr = (address instanceof enet.Address) ? address : new enet.Address(address);\n\tvar ptr = jsapi_.enet_host_connect(this._pointer, enetAddr.host(), enetAddr.port(), channelCount || 5,\n\t\tdata ||\n\t\t0);\n\n\tself.firstStart(); //start servicing if not yet started\n\n\tvar succeeded = false;\n\n\tif (ptr) {\n\t\tpeer = new enet.Peer(ptr);\n\t\tpeer._host = self;\n\t\tself.connectedPeers[ptr] = peer;\n\t\tif (typeof callback === 'function') {\n\t\t\tpeer.on(\"connect\", function () {\n\t\t\t\tsucceeded = true;\n\t\t\t\tcallback(undefined, peer);\n\t\t\t});\n\t\t\tpeer.on(\"disconnect\", function () {\n\t\t\t\tif (!succeeded) callback(new Error(\"failed\"));\n\t\t\t});\n\t\t}\n\t\treturn peer;\n\t}\n\n\tif (typeof callback === 'function') {\n\t\tsetTimeout(function () {\n\t\t\tcallback(new Error(\"maxpeers\"));\n\t\t});\n\t}\n\n\treturn undefined;\n};\n\nHost.prototype.throttleBandwidth = function () {\n\tif (this.isOffline()) return;\n\tenet_.host_bandwidth_throttle(this._pointer);\n\treturn this;\n};\n\nHost.prototype.enableCompression = function () {\n\tif (this._pointer) {\n\t\tenet_.host_compress_with_range_coder(this._pointer);\n\t}\n\treturn this;\n};\n\nHost.prototype.disableCompression = function () {\n\tif (this._pointer) {\n\t\tenet_.host_compress(this._pointer, 0); //passing a 0 disables compression\n\t}\n\treturn this;\n};\n\nHost.prototype.broadcast = function (channel, packet) {\n\tif (this.isOffline()) return;\n\n\tif (packet instanceof Buffer) packet = new enet.Packet(packet, enet.PACKET_FLAG.RELIABLE);\n\n\tenet_.host_broadcast(this._pointer, channel, packet._pointer);\n};\n\nHost.prototype.peers = function () {\n\tvar peer_ptr, peers = [];\n\tfor (peer_ptr in this.connectedPeers) {\n\t\tpeers.push(this.connectedPeers[peer_ptr]);\n\t}\n\treturn peers;\n};\n\nHost.prototype.firstStart = function () {\n\tvar self = this;\n\tif (!self._io_loop) {\n\t\tself._io_loop = setInterval(function () {\n\t\t\tself._service();\n\t\t}, ENET_HOST_SERVICE_INTERVAL);\n\t}\n};\n\nHost.prototype.start = function (ms_interval) {\n\tvar self = this;\n\tif (!self._pointer) return; //cannot start a host that is not initialised\n\tif (self._io_loop) {\n\t\tclearInterval(self._io_loop);\n\t}\n\tself._io_loop = setInterval(function () {\n\t\tself._service();\n\t}, ms_interval || ENET_HOST_SERVICE_INTERVAL);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}