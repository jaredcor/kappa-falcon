{"ast":null,"code":"var EventEmitter = require('events').EventEmitter;\nvar backoff = require('backoff');\nmodule.exports = function (createConnection) {\n  return function (opts, onConnect) {\n    onConnect = 'function' == typeof opts ? opts : onConnect;\n    opts = 'object' == typeof opts ? opts : {\n      initialDelay: 1e3,\n      maxDelay: 30e3\n    };\n    if (!onConnect) onConnect = opts.onConnect;\n    var emitter = new EventEmitter();\n    emitter.connected = false;\n    emitter.reconnect = true;\n    if (onConnect)\n      //use \"connection\" to match core (net) api.\n      emitter.on('connection', onConnect);\n    var backoffStrategy = opts.strategy || opts.type;\n    var backoffMethod;\n    if (typeof backoffStrategy == 'string') backoffMethod = backoff[backoffStrategy](opts);else backoffMethod = backoffStrategy || backoff.fibonacci(opts);\n    if (opts.failAfter) backoffMethod.failAfter(opts.failAfter);\n    backoffMethod.on('backoff', function (n, d, e) {\n      emitter.emit('backoff', n, d, e);\n    });\n    backoffMethod.on('fail', function (e) {\n      emitter.disconnect();\n      emitter.emit('fail', e);\n    });\n    var args;\n    function attempt(n, delay) {\n      if (emitter.connected) return;\n      if (!emitter.reconnect) return;\n      emitter.emit('reconnect', n, delay);\n      var con = createConnection.apply(emitter, args);\n      emitter._connection = con;\n      function onError(err) {\n        con.removeListener('error', onError);\n        emitter.emit('error', err);\n        onDisconnect(err);\n      }\n      function onDisconnect(err) {\n        emitter.connected = false;\n        con.removeListener('close', onDisconnect);\n        con.removeListener('end', onDisconnect);\n\n        //hack to make http not crash.\n        //HTTP IS THE WORST PROTOCOL.\n        if (con.constructor.name == 'Request') con.on('error', function () {});\n\n        //emit disconnect before checking reconnect, so user has a chance to decide not to.\n        emitter.emit('disconnect', err);\n        if (!emitter.reconnect) return;\n        try {\n          backoffMethod.backoff();\n        } catch (_) {}\n      }\n      con.on('error', onError).on('close', onDisconnect).on('end', onDisconnect);\n      if (opts.immediate || con.constructor.name == 'Request') {\n        emitter.connected = true;\n        emitter.emit('connect', con);\n        emitter.emit('connection', con);\n        con.once('data', function () {\n          //this is the only way to know for sure that data is coming...\n          backoffMethod.reset();\n        });\n      } else {\n        con.once('connect', function () {\n          backoffMethod.reset();\n          emitter.connected = true;\n          if (onConnect) con.removeListener('connect', onConnect);\n          emitter.emit('connect', con);\n          //also support net style 'connection' method.\n          emitter.emit('connection', con);\n        });\n      }\n    }\n    emitter.connect = emitter.listen = function () {\n      this.reconnect = true;\n      if (emitter.connected) return;\n      backoffMethod.reset();\n      backoffMethod.on('ready', attempt);\n      if (!args) {\n        var len = arguments.length;\n        args = new Array(len);\n        for (var i = 0; i < len; i++) {\n          args[i] = arguments[i];\n        }\n      }\n      attempt(0, 0);\n      return emitter;\n    };\n\n    //force reconnection\n\n    emitter.disconnect = function () {\n      this.reconnect = false;\n      if (emitter._connection) emitter._connection.end();\n      return emitter;\n    };\n    emitter.reset = function () {\n      backoffMethod.reset();\n      attempt(0, 0);\n    };\n    return emitter;\n  };\n};","map":{"version":3,"names":["EventEmitter","require","backoff","module","exports","createConnection","opts","onConnect","initialDelay","maxDelay","emitter","connected","reconnect","on","backoffStrategy","strategy","type","backoffMethod","fibonacci","failAfter","n","d","e","emit","disconnect","args","attempt","delay","con","apply","_connection","onError","err","removeListener","onDisconnect","constructor","name","_","immediate","once","reset","connect","listen","len","arguments","length","Array","i","end"],"sources":["/Users/jaredcortez/node_modules/reconnect-core/index.js"],"sourcesContent":["var EventEmitter = require('events').EventEmitter\nvar backoff = require('backoff')\n\nmodule.exports =\nfunction (createConnection) {\n  return function (opts, onConnect) {\n    onConnect = 'function' == typeof opts ? opts : onConnect\n    opts = 'object' == typeof opts ? opts : {initialDelay: 1e3, maxDelay: 30e3}\n    if(!onConnect)\n      onConnect = opts.onConnect\n\n    var emitter = new EventEmitter()\n    emitter.connected = false\n    emitter.reconnect = true\n\n    if(onConnect)\n      //use \"connection\" to match core (net) api.\n      emitter.on('connection', onConnect)\n\n    var backoffStrategy = opts.strategy || opts.type\n    var backoffMethod\n    if (typeof backoffStrategy == 'string')\n      backoffMethod = backoff[backoffStrategy](opts)\n    else\n      backoffMethod = backoffStrategy || backoff.fibonacci(opts)\n\n    if(opts.failAfter)\n      backoffMethod.failAfter(opts.failAfter);\n\n    backoffMethod.on('backoff', function (n, d, e) {\n      emitter.emit('backoff', n, d, e)\n    })\n    backoffMethod.on('fail', function (e) {\n      emitter.disconnect()\n      emitter.emit('fail', e)\n    })\n\n    var args\n    function attempt (n, delay) {\n      if(emitter.connected) return\n      if(!emitter.reconnect) return\n\n      emitter.emit('reconnect', n, delay)\n      var con = createConnection.apply(emitter, args)\n      emitter._connection = con\n\n      function onError (err) {\n        con.removeListener('error', onError)\n        emitter.emit('error', err)\n        onDisconnect(err)\n      }\n\n      function onDisconnect (err) {\n        emitter.connected = false\n        con.removeListener('close', onDisconnect)\n        con.removeListener('end'  , onDisconnect)\n\n        //hack to make http not crash.\n        //HTTP IS THE WORST PROTOCOL.\n        if(con.constructor.name == 'Request')\n          con.on('error', function () {})\n\n        //emit disconnect before checking reconnect, so user has a chance to decide not to.\n        emitter.emit('disconnect', err)\n\n        if(!emitter.reconnect) return\n        try { backoffMethod.backoff() } catch (_) { }\n      }\n\n      con\n        .on('error', onError)\n        .on('close', onDisconnect)\n        .on('end'  , onDisconnect)\n\n      if(opts.immediate || con.constructor.name == 'Request') {\n        emitter.connected = true\n        emitter.emit('connect', con)\n        emitter.emit('connection', con)\n        con.once('data', function () {\n          //this is the only way to know for sure that data is coming...\n          backoffMethod.reset()\n        })\n      } else {\n        con\n          .once('connect', function () {\n            backoffMethod.reset()\n            emitter.connected = true\n            if(onConnect)\n              con.removeListener('connect', onConnect)\n            emitter.emit('connect', con)\n            //also support net style 'connection' method.\n            emitter.emit('connection', con)\n          })\n      }\n    }\n\n    emitter.connect =\n    emitter.listen = function () {\n      this.reconnect = true\n      if(emitter.connected) return\n      backoffMethod.reset()\n      backoffMethod.on('ready', attempt)\n      if (!args) {\n        var len = arguments.length;\n        args = new Array(len);\n        for (var i = 0; i < len; i++) {\n          args[i] = arguments[i];\n        }\n      }\n      attempt(0, 0)\n      return emitter\n    }\n\n    //force reconnection\n\n    emitter.disconnect = function () {\n      this.reconnect = false\n\n      if(emitter._connection)\n        emitter._connection.end()\n\n      return emitter\n    }\n\n    emitter.reset = function () {\n      backoffMethod.reset()\n      attempt(0, 0)\n    }\n\n    return emitter\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}