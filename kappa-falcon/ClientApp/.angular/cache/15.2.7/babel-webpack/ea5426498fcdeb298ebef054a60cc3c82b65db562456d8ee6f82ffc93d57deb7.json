{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/jaredcortez/kappa-falcon/kappa-falcon/ClientApp/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar lodash = require('lodash');\nvar events = require('events');\nvar dateFns = require('date-fns');\nvar fs = require('fs');\nvar stream = require('stream');\nvar ubjson = require('@shelacek/ubjson');\nvar net = require('net');\nvar inject = require('reconnect-core');\nvar iconv = require('iconv-lite');\nvar path = require('path');\nvar semver = require('semver');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return n;\n}\nvar fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);\nvar net__default = /*#__PURE__*/_interopDefaultLegacy(net);\nvar inject__default = /*#__PURE__*/_interopDefaultLegacy(inject);\nvar iconv__default = /*#__PURE__*/_interopDefaultLegacy(iconv);\nvar path__default = /*#__PURE__*/_interopDefaultLegacy(path);\nvar semver__default = /*#__PURE__*/_interopDefaultLegacy(semver);\n\n// eslint-disable-next-line\nfunction getDeathDirection(actionStateId) {\n  if (actionStateId > 0xa) {\n    return null;\n  }\n  switch (actionStateId) {\n    case 0:\n      return \"down\";\n    case 1:\n      return \"left\";\n    case 2:\n      return \"right\";\n    default:\n      return \"up\";\n  }\n}\nvar animationUtils = {\n  __proto__: null,\n  getDeathDirection: getDeathDirection\n};\nvar characters = {\n  \"0\": {\n    name: \"Captain Falcon\",\n    shortName: \"Falcon\",\n    colors: [\"Black\", \"Red\", \"White\", \"Green\", \"Blue\"]\n  },\n  \"1\": {\n    name: \"Donkey Kong\",\n    shortName: \"DK\",\n    colors: [\"Black\", \"Red\", \"Blue\", \"Green\"]\n  },\n  \"2\": {\n    name: \"Fox\",\n    colors: [\"Red\", \"Blue\", \"Green\"]\n  },\n  \"3\": {\n    name: \"Mr. Game & Watch\",\n    shortName: \"G&W\",\n    colors: [\"Red\", \"Blue\", \"Green\"]\n  },\n  \"4\": {\n    name: \"Kirby\",\n    colors: [\"Yellow\", \"Blue\", \"Red\", \"Green\", \"White\"]\n  },\n  \"5\": {\n    name: \"Bowser\",\n    colors: [\"Red\", \"Blue\", \"Black\"]\n  },\n  \"6\": {\n    name: \"Link\",\n    colors: [\"Red\", \"Blue\", \"Black\", \"White\"]\n  },\n  \"7\": {\n    name: \"Luigi\",\n    colors: [\"White\", \"Blue\", \"Red\"]\n  },\n  \"8\": {\n    name: \"Mario\",\n    colors: [\"Yellow\", \"Black\", \"Blue\", \"Green\"]\n  },\n  \"9\": {\n    name: \"Marth\",\n    colors: [\"Red\", \"Green\", \"Black\", \"White\"]\n  },\n  \"10\": {\n    name: \"Mewtwo\",\n    colors: [\"Red\", \"Blue\", \"Green\"]\n  },\n  \"11\": {\n    name: \"Ness\",\n    colors: [\"Yellow\", \"Blue\", \"Green\"]\n  },\n  \"12\": {\n    name: \"Peach\",\n    colors: [\"Daisy\", \"White\", \"Blue\", \"Green\"]\n  },\n  \"13\": {\n    name: \"Pikachu\",\n    colors: [\"Red\", \"Party Hat\", \"Cowboy Hat\"]\n  },\n  \"14\": {\n    name: \"Ice Climbers\",\n    shortName: \"ICs\",\n    colors: [\"Green\", \"Orange\", \"Red\"]\n  },\n  \"15\": {\n    name: \"Jigglypuff\",\n    shortName: \"Puff\",\n    colors: [\"Red\", \"Blue\", \"Headband\", \"Crown\"]\n  },\n  \"16\": {\n    name: \"Samus\",\n    colors: [\"Pink\", \"Black\", \"Green\", \"Purple\"]\n  },\n  \"17\": {\n    name: \"Yoshi\",\n    colors: [\"Red\", \"Blue\", \"Yellow\", \"Pink\", \"Cyan\"]\n  },\n  \"18\": {\n    name: \"Zelda\",\n    colors: [\"Red\", \"Blue\", \"Green\", \"White\"]\n  },\n  \"19\": {\n    name: \"Sheik\",\n    colors: [\"Red\", \"Blue\", \"Green\", \"White\"]\n  },\n  \"20\": {\n    name: \"Falco\",\n    colors: [\"Red\", \"Blue\", \"Green\"]\n  },\n  \"21\": {\n    name: \"Young Link\",\n    shortName: \"YLink\",\n    colors: [\"Red\", \"Blue\", \"White\", \"Black\"]\n  },\n  \"22\": {\n    name: \"Dr. Mario\",\n    shortName: \"Doc\",\n    colors: [\"Red\", \"Blue\", \"Green\", \"Black\"]\n  },\n  \"23\": {\n    name: \"Roy\",\n    colors: [\"Red\", \"Blue\", \"Green\", \"Yellow\"]\n  },\n  \"24\": {\n    name: \"Pichu\",\n    colors: [\"Red\", \"Blue\", \"Green\"]\n  },\n  \"25\": {\n    name: \"Ganondorf\",\n    shortName: \"Ganon\",\n    colors: [\"Red\", \"Blue\", \"Green\", \"Purple\"]\n  },\n  \"26\": {\n    name: \"Master Hand\"\n  },\n  \"27\": {\n    name: \"Wireframe (Male)\"\n  },\n  \"28\": {\n    name: \"Wireframe (Female)\"\n  },\n  \"29\": {\n    name: \"Gigabowser\"\n  },\n  \"30\": {\n    name: \"Crazy Hand\"\n  },\n  \"31\": {\n    name: \"Sandbag\"\n  },\n  \"32\": {\n    name: \"Popo\"\n  }\n};\nconst DEFAULT_COLOR = \"Default\";\nconst UnknownCharacter = {\n  id: -1,\n  name: \"Unknown Character\",\n  shortName: \"Unknown\",\n  colors: [DEFAULT_COLOR]\n};\nfunction generateCharacterInfo(id, info) {\n  var _info$shortName, _info$colors;\n  if (!info) {\n    return UnknownCharacter;\n  }\n  return {\n    id,\n    name: info.name,\n    shortName: (_info$shortName = info.shortName) != null ? _info$shortName : info.name,\n    colors: [DEFAULT_COLOR, ...((_info$colors = info.colors) != null ? _info$colors : [])]\n  };\n}\nfunction getAllCharacters() {\n  return Object.entries(characters).map(([id, data]) => generateCharacterInfo(parseInt(id, 10), data)).sort((a, b) => a.id - b.id);\n}\nfunction getCharacterInfo(externalCharacterId) {\n  const data = characters[externalCharacterId.toString()];\n  return generateCharacterInfo(externalCharacterId, data);\n}\nfunction getCharacterShortName(externalCharacterId) {\n  const character = getCharacterInfo(externalCharacterId);\n  return character.shortName;\n}\nfunction getCharacterName(externalCharacterId) {\n  const character = getCharacterInfo(externalCharacterId);\n  return character.name;\n} // Return a human-readable color from a characterCode.\n\nfunction getCharacterColorName(externalCharacterId, characterColor) {\n  const character = getCharacterInfo(externalCharacterId);\n  const color = character.colors[characterColor];\n  if (color) {\n    return color;\n  }\n  return DEFAULT_COLOR;\n}\nvar characterUtils = {\n  __proto__: null,\n  UnknownCharacter: UnknownCharacter,\n  getAllCharacters: getAllCharacters,\n  getCharacterInfo: getCharacterInfo,\n  getCharacterShortName: getCharacterShortName,\n  getCharacterName: getCharacterName,\n  getCharacterColorName: getCharacterColorName\n};\nvar moveNames = {\n  \"1\": {\n    name: \"Miscellaneous\",\n    shortName: \"misc\"\n  },\n  \"2\": {\n    name: \"Jab\",\n    shortName: \"jab\"\n  },\n  \"3\": {\n    name: \"Jab\",\n    shortName: \"jab\"\n  },\n  \"4\": {\n    name: \"Jab\",\n    shortName: \"jab\"\n  },\n  \"5\": {\n    name: \"Rapid Jabs\",\n    shortName: \"rapid-jabs\"\n  },\n  \"6\": {\n    name: \"Dash Attack\",\n    shortName: \"dash\"\n  },\n  \"7\": {\n    name: \"Forward Tilt\",\n    shortName: \"ftilt\"\n  },\n  \"8\": {\n    name: \"Up Tilt\",\n    shortName: \"utilt\"\n  },\n  \"9\": {\n    name: \"Down Tilt\",\n    shortName: \"dtilt\"\n  },\n  \"10\": {\n    name: \"Forward Smash\",\n    shortName: \"fsmash\"\n  },\n  \"11\": {\n    name: \"Up Smash\",\n    shortName: \"usmash\"\n  },\n  \"12\": {\n    name: \"Down Smash\",\n    shortName: \"dsmash\"\n  },\n  \"13\": {\n    name: \"Neutral Air\",\n    shortName: \"nair\"\n  },\n  \"14\": {\n    name: \"Forward Air\",\n    shortName: \"fair\"\n  },\n  \"15\": {\n    name: \"Back Air\",\n    shortName: \"bair\"\n  },\n  \"16\": {\n    name: \"Up Air\",\n    shortName: \"uair\"\n  },\n  \"17\": {\n    name: \"Down Air\",\n    shortName: \"dair\"\n  },\n  \"18\": {\n    name: \"Neutral B\",\n    shortName: \"neutral-b\"\n  },\n  \"19\": {\n    name: \"Side B\",\n    shortName: \"side-b\"\n  },\n  \"20\": {\n    name: \"Up B\",\n    shortName: \"up-b\"\n  },\n  \"21\": {\n    name: \"Down B\",\n    shortName: \"down-b\"\n  },\n  \"50\": {\n    name: \"Getup Attack\",\n    shortName: \"getup\"\n  },\n  \"51\": {\n    name: \"Getup Attack (Slow)\",\n    shortName: \"getup-slow\"\n  },\n  \"52\": {\n    name: \"Grab Pummel\",\n    shortName: \"pummel\"\n  },\n  \"53\": {\n    name: \"Forward Throw\",\n    shortName: \"fthrow\"\n  },\n  \"54\": {\n    name: \"Back Throw\",\n    shortName: \"bthrow\"\n  },\n  \"55\": {\n    name: \"Up Throw\",\n    shortName: \"uthrow\"\n  },\n  \"56\": {\n    name: \"Down Throw\",\n    shortName: \"dthrow\"\n  },\n  \"61\": {\n    name: \"Edge Attack (Slow)\",\n    shortName: \"edge-slow\"\n  },\n  \"62\": {\n    name: \"Edge Attack\",\n    shortName: \"edge\"\n  }\n};\nconst UnknownMove = {\n  id: -1,\n  name: \"Unknown Move\",\n  shortName: \"unknown\"\n};\nfunction getMoveInfo(moveId) {\n  const moveName = moveNames[moveId.toString()];\n  if (!moveName) {\n    return UnknownMove;\n  }\n  return {\n    id: moveId,\n    name: moveName.name,\n    shortName: moveName.shortName\n  };\n}\nfunction getMoveShortName(moveId) {\n  const move = getMoveInfo(moveId);\n  return move.shortName;\n}\nfunction getMoveName(moveId) {\n  const move = getMoveInfo(moveId);\n  return move.name;\n}\nvar moveUtils = {\n  __proto__: null,\n  UnknownMove: UnknownMove,\n  getMoveInfo: getMoveInfo,\n  getMoveShortName: getMoveShortName,\n  getMoveName: getMoveName\n};\nvar stageNames = {\n  \"2\": \"Fountain of Dreams\",\n  \"3\": \"Pokémon Stadium\",\n  \"4\": \"Princess Peach's Castle\",\n  \"5\": \"Kongo Jungle\",\n  \"6\": \"Brinstar\",\n  \"7\": \"Corneria\",\n  \"8\": \"Yoshi's Story\",\n  \"9\": \"Onett\",\n  \"10\": \"Mute City\",\n  \"11\": \"Rainbow Cruise\",\n  \"12\": \"Jungle Japes\",\n  \"13\": \"Great Bay\",\n  \"14\": \"Hyrule Temple\",\n  \"15\": \"Brinstar Depths\",\n  \"16\": \"Yoshi's Island\",\n  \"17\": \"Green Greens\",\n  \"18\": \"Fourside\",\n  \"19\": \"Mushroom Kingdom I\",\n  \"20\": \"Mushroom Kingdom II\",\n  \"22\": \"Venom\",\n  \"23\": \"Poké Floats\",\n  \"24\": \"Big Blue\",\n  \"25\": \"Icicle Mountain\",\n  \"26\": \"Icetop\",\n  \"27\": \"Flat Zone\",\n  \"28\": \"Dream Land N64\",\n  \"29\": \"Yoshi's Island N64\",\n  \"30\": \"Kongo Jungle N64\",\n  \"31\": \"Battlefield\",\n  \"32\": \"Final Destination\",\n  \"33\": \"Target Test (Mario)\",\n  \"34\": \"Target Test (Captain Falcon)\",\n  \"35\": \"Target Test (Young Link)\",\n  \"36\": \"Target Test (Donkey Kong)\",\n  \"37\": \"Target Test (Dr. Mario)\",\n  \"38\": \"Target Test (Falco)\",\n  \"39\": \"Target Test (Fox)\",\n  \"40\": \"Target Test (Ice Climbers)\",\n  \"41\": \"Target Test (Kirby)\",\n  \"42\": \"Target Test (Bowser)\",\n  \"43\": \"Target Test (Link)\",\n  \"44\": \"Target Test (Luigi)\",\n  \"45\": \"Target Test (Marth)\",\n  \"46\": \"Target Test (Mewtwo)\",\n  \"47\": \"Target Test (Ness)\",\n  \"48\": \"Target Test (Peach)\",\n  \"49\": \"Target Test (Pichu)\",\n  \"50\": \"Target Test (Pikachu)\",\n  \"51\": \"Target Test (Jigglypuff)\",\n  \"52\": \"Target Test (Samus)\",\n  \"53\": \"Target Test (Sheik)\",\n  \"54\": \"Target Test (Yoshi)\",\n  \"55\": \"Target Test (Zelda)\",\n  \"56\": \"Target Test (Mr. Game & Watch)\",\n  \"57\": \"Target Test (Roy)\",\n  \"58\": \"Target Test (Ganondorf)\",\n  \"84\": \"Home-Run Contest\"\n};\nconst UnknownStage = {\n  id: -1,\n  name: \"Unknown Stage\"\n};\nfunction getStageInfo(stageId) {\n  const stageName = stageNames[stageId.toString()];\n  if (!stageName) {\n    return UnknownStage;\n  }\n  return {\n    id: stageId,\n    name: stageName\n  };\n}\nfunction getStageName(stageId) {\n  const stage = getStageInfo(stageId);\n  return stage.name;\n}\nvar stageUtils = {\n  __proto__: null,\n  UnknownStage: UnknownStage,\n  getStageInfo: getStageInfo,\n  getStageName: getStageName\n};\nexports.Character = void 0;\n(function (Character) {\n  Character[Character[\"CAPTAIN_FALCON\"] = 0] = \"CAPTAIN_FALCON\";\n  Character[Character[\"DONKEY_KONG\"] = 1] = \"DONKEY_KONG\";\n  Character[Character[\"FOX\"] = 2] = \"FOX\";\n  Character[Character[\"GAME_AND_WATCH\"] = 3] = \"GAME_AND_WATCH\";\n  Character[Character[\"KIRBY\"] = 4] = \"KIRBY\";\n  Character[Character[\"BOWSER\"] = 5] = \"BOWSER\";\n  Character[Character[\"LINK\"] = 6] = \"LINK\";\n  Character[Character[\"LUIGI\"] = 7] = \"LUIGI\";\n  Character[Character[\"MARIO\"] = 8] = \"MARIO\";\n  Character[Character[\"MARTH\"] = 9] = \"MARTH\";\n  Character[Character[\"MEWTWO\"] = 10] = \"MEWTWO\";\n  Character[Character[\"NESS\"] = 11] = \"NESS\";\n  Character[Character[\"PEACH\"] = 12] = \"PEACH\";\n  Character[Character[\"PIKACHU\"] = 13] = \"PIKACHU\";\n  Character[Character[\"ICE_CLIMBERS\"] = 14] = \"ICE_CLIMBERS\";\n  Character[Character[\"JIGGLYPUFF\"] = 15] = \"JIGGLYPUFF\";\n  Character[Character[\"SAMUS\"] = 16] = \"SAMUS\";\n  Character[Character[\"YOSHI\"] = 17] = \"YOSHI\";\n  Character[Character[\"ZELDA\"] = 18] = \"ZELDA\";\n  Character[Character[\"SHEIK\"] = 19] = \"SHEIK\";\n  Character[Character[\"FALCO\"] = 20] = \"FALCO\";\n  Character[Character[\"YOUNG_LINK\"] = 21] = \"YOUNG_LINK\";\n  Character[Character[\"DR_MARIO\"] = 22] = \"DR_MARIO\";\n  Character[Character[\"ROY\"] = 23] = \"ROY\";\n  Character[Character[\"PICHU\"] = 24] = \"PICHU\";\n  Character[Character[\"GANONDORF\"] = 25] = \"GANONDORF\";\n  Character[Character[\"MASTER_HAND\"] = 26] = \"MASTER_HAND\";\n  Character[Character[\"WIREFRAME_MALE\"] = 27] = \"WIREFRAME_MALE\";\n  Character[Character[\"WIREFRAME_FEMALE\"] = 28] = \"WIREFRAME_FEMALE\";\n  Character[Character[\"GIGA_BOWSER\"] = 29] = \"GIGA_BOWSER\";\n  Character[Character[\"CRAZY_HAND\"] = 30] = \"CRAZY_HAND\";\n  Character[Character[\"SANDBAG\"] = 31] = \"SANDBAG\";\n  Character[Character[\"POPO\"] = 32] = \"POPO\";\n})(exports.Character || (exports.Character = {}));\nexports.Stage = void 0;\n(function (Stage) {\n  Stage[Stage[\"FOUNTAIN_OF_DREAMS\"] = 2] = \"FOUNTAIN_OF_DREAMS\";\n  Stage[Stage[\"POKEMON_STADIUM\"] = 3] = \"POKEMON_STADIUM\";\n  Stage[Stage[\"PEACHS_CASTLE\"] = 4] = \"PEACHS_CASTLE\";\n  Stage[Stage[\"KONGO_JUNGLE\"] = 5] = \"KONGO_JUNGLE\";\n  Stage[Stage[\"BRINSTAR\"] = 6] = \"BRINSTAR\";\n  Stage[Stage[\"CORNERIA\"] = 7] = \"CORNERIA\";\n  Stage[Stage[\"YOSHIS_STORY\"] = 8] = \"YOSHIS_STORY\";\n  Stage[Stage[\"ONETT\"] = 9] = \"ONETT\";\n  Stage[Stage[\"MUTE_CITY\"] = 10] = \"MUTE_CITY\";\n  Stage[Stage[\"RAINBOW_CRUISE\"] = 11] = \"RAINBOW_CRUISE\";\n  Stage[Stage[\"JUNGLE_JAPES\"] = 12] = \"JUNGLE_JAPES\";\n  Stage[Stage[\"GREAT_BAY\"] = 13] = \"GREAT_BAY\";\n  Stage[Stage[\"HYRULE_TEMPLE\"] = 14] = \"HYRULE_TEMPLE\";\n  Stage[Stage[\"BRINSTAR_DEPTHS\"] = 15] = \"BRINSTAR_DEPTHS\";\n  Stage[Stage[\"YOSHIS_ISLAND\"] = 16] = \"YOSHIS_ISLAND\";\n  Stage[Stage[\"GREEN_GREENS\"] = 17] = \"GREEN_GREENS\";\n  Stage[Stage[\"FOURSIDE\"] = 18] = \"FOURSIDE\";\n  Stage[Stage[\"MUSHROOM_KINGDOM\"] = 19] = \"MUSHROOM_KINGDOM\";\n  Stage[Stage[\"MUSHROOM_KINGDOM_2\"] = 20] = \"MUSHROOM_KINGDOM_2\";\n  Stage[Stage[\"VENOM\"] = 22] = \"VENOM\";\n  Stage[Stage[\"POKE_FLOATS\"] = 23] = \"POKE_FLOATS\";\n  Stage[Stage[\"BIG_BLUE\"] = 24] = \"BIG_BLUE\";\n  Stage[Stage[\"ICICLE_MOUNTAIN\"] = 25] = \"ICICLE_MOUNTAIN\";\n  Stage[Stage[\"ICETOP\"] = 26] = \"ICETOP\";\n  Stage[Stage[\"FLAT_ZONE\"] = 27] = \"FLAT_ZONE\";\n  Stage[Stage[\"DREAMLAND\"] = 28] = \"DREAMLAND\";\n  Stage[Stage[\"YOSHIS_ISLAND_N64\"] = 29] = \"YOSHIS_ISLAND_N64\";\n  Stage[Stage[\"KONGO_JUNGLE_N64\"] = 30] = \"KONGO_JUNGLE_N64\";\n  Stage[Stage[\"BATTLEFIELD\"] = 31] = \"BATTLEFIELD\";\n  Stage[Stage[\"FINAL_DESTINATION\"] = 32] = \"FINAL_DESTINATION\";\n  Stage[Stage[\"TARGET_TEST_MARIO\"] = 33] = \"TARGET_TEST_MARIO\";\n  Stage[Stage[\"TARGET_TEST_CAPTAIN_FALCON\"] = 34] = \"TARGET_TEST_CAPTAIN_FALCON\";\n  Stage[Stage[\"TARGET_TEST_YOUNG_LINK\"] = 35] = \"TARGET_TEST_YOUNG_LINK\";\n  Stage[Stage[\"TARGET_TEST_DONKEY_KONG\"] = 36] = \"TARGET_TEST_DONKEY_KONG\";\n  Stage[Stage[\"TARGET_TEST_DR_MARIO\"] = 37] = \"TARGET_TEST_DR_MARIO\";\n  Stage[Stage[\"TARGET_TEST_FALCO\"] = 38] = \"TARGET_TEST_FALCO\";\n  Stage[Stage[\"TARGET_TEST_FOX\"] = 39] = \"TARGET_TEST_FOX\";\n  Stage[Stage[\"TARGET_TEST_ICE_CLIMBERS\"] = 40] = \"TARGET_TEST_ICE_CLIMBERS\";\n  Stage[Stage[\"TARGET_TEST_KIRBY\"] = 41] = \"TARGET_TEST_KIRBY\";\n  Stage[Stage[\"TARGET_TEST_BOWSER\"] = 42] = \"TARGET_TEST_BOWSER\";\n  Stage[Stage[\"TARGET_TEST_LINK\"] = 43] = \"TARGET_TEST_LINK\";\n  Stage[Stage[\"TARGET_TEST_LUIGI\"] = 44] = \"TARGET_TEST_LUIGI\";\n  Stage[Stage[\"TARGET_TEST_MARTH\"] = 45] = \"TARGET_TEST_MARTH\";\n  Stage[Stage[\"TARGET_TEST_MEWTWO\"] = 46] = \"TARGET_TEST_MEWTWO\";\n  Stage[Stage[\"TARGET_TEST_NESS\"] = 47] = \"TARGET_TEST_NESS\";\n  Stage[Stage[\"TARGET_TEST_PEACH\"] = 48] = \"TARGET_TEST_PEACH\";\n  Stage[Stage[\"TARGET_TEST_PICHU\"] = 49] = \"TARGET_TEST_PICHU\";\n  Stage[Stage[\"TARGET_TEST_PIKACHU\"] = 50] = \"TARGET_TEST_PIKACHU\";\n  Stage[Stage[\"TARGET_TEST_JIGGLYPUFF\"] = 51] = \"TARGET_TEST_JIGGLYPUFF\";\n  Stage[Stage[\"TARGET_TEST_SAMUS\"] = 52] = \"TARGET_TEST_SAMUS\";\n  Stage[Stage[\"TARGET_TEST_SHEIK\"] = 53] = \"TARGET_TEST_SHEIK\";\n  Stage[Stage[\"TARGET_TEST_YOSHI\"] = 54] = \"TARGET_TEST_YOSHI\";\n  Stage[Stage[\"TARGET_TEST_ZELDA\"] = 55] = \"TARGET_TEST_ZELDA\";\n  Stage[Stage[\"TARGET_TEST_GAME_AND_WATCH\"] = 56] = \"TARGET_TEST_GAME_AND_WATCH\";\n  Stage[Stage[\"TARGET_TEST_ROY\"] = 57] = \"TARGET_TEST_ROY\";\n  Stage[Stage[\"TARGET_TEST_GANONDORF\"] = 58] = \"TARGET_TEST_GANONDORF\";\n  Stage[Stage[\"RACE_TO_THE_FINISH\"] = 82] = \"RACE_TO_THE_FINISH\";\n  Stage[Stage[\"GRAB_THE_TROPHIES\"] = 83] = \"GRAB_THE_TROPHIES\";\n  Stage[Stage[\"HOME_RUN_CONTEST\"] = 84] = \"HOME_RUN_CONTEST\";\n  Stage[Stage[\"ALL_STAR_LOBBY\"] = 85] = \"ALL_STAR_LOBBY\";\n  Stage[Stage[\"EVENT_ONE\"] = 202] = \"EVENT_ONE\";\n  Stage[Stage[\"EVENT_EIGHTEEN\"] = 203] = \"EVENT_EIGHTEEN\";\n  Stage[Stage[\"EVENT_THREE\"] = 204] = \"EVENT_THREE\";\n  Stage[Stage[\"EVENT_FOUR\"] = 205] = \"EVENT_FOUR\";\n  Stage[Stage[\"EVENT_FIVE\"] = 206] = \"EVENT_FIVE\";\n  Stage[Stage[\"EVENT_SIX\"] = 207] = \"EVENT_SIX\";\n  Stage[Stage[\"EVENT_SEVEN\"] = 208] = \"EVENT_SEVEN\";\n  Stage[Stage[\"EVENT_EIGHT\"] = 209] = \"EVENT_EIGHT\";\n  Stage[Stage[\"EVENT_NINE\"] = 210] = \"EVENT_NINE\";\n  Stage[Stage[\"EVENT_TEN_PART_ONE\"] = 211] = \"EVENT_TEN_PART_ONE\";\n  Stage[Stage[\"EVENT_ELEVEN\"] = 212] = \"EVENT_ELEVEN\";\n  Stage[Stage[\"EVENT_TWELVE\"] = 213] = \"EVENT_TWELVE\";\n  Stage[Stage[\"EVENT_THIRTEEN\"] = 214] = \"EVENT_THIRTEEN\";\n  Stage[Stage[\"EVENT_FOURTEEN\"] = 215] = \"EVENT_FOURTEEN\";\n  Stage[Stage[\"EVENT_THIRTY_SEVEN\"] = 216] = \"EVENT_THIRTY_SEVEN\";\n  Stage[Stage[\"EVENT_SIXTEEN\"] = 217] = \"EVENT_SIXTEEN\";\n  Stage[Stage[\"EVENT_SEVENTEEN\"] = 218] = \"EVENT_SEVENTEEN\";\n  Stage[Stage[\"EVENT_TWO\"] = 219] = \"EVENT_TWO\";\n  Stage[Stage[\"EVENT_NINETEEN\"] = 220] = \"EVENT_NINETEEN\";\n  Stage[Stage[\"EVENT_TWENTY_PART_ONE\"] = 221] = \"EVENT_TWENTY_PART_ONE\";\n  Stage[Stage[\"EVENT_TWENTY_ONE\"] = 222] = \"EVENT_TWENTY_ONE\";\n  Stage[Stage[\"EVENT_TWENTY_TWO\"] = 223] = \"EVENT_TWENTY_TWO\";\n  Stage[Stage[\"EVENT_TWENTY_SEVEN\"] = 224] = \"EVENT_TWENTY_SEVEN\";\n  Stage[Stage[\"EVENT_TWENTY_FOUR\"] = 225] = \"EVENT_TWENTY_FOUR\";\n  Stage[Stage[\"EVENT_TWENTY_FIVE\"] = 226] = \"EVENT_TWENTY_FIVE\";\n  Stage[Stage[\"EVENT_TWENTY_SIX\"] = 227] = \"EVENT_TWENTY_SIX\";\n  Stage[Stage[\"EVENT_TWENTY_THREE\"] = 228] = \"EVENT_TWENTY_THREE\";\n  Stage[Stage[\"EVENT_TWENTY_EIGHT\"] = 229] = \"EVENT_TWENTY_EIGHT\";\n  Stage[Stage[\"EVENT_TWENTY_NINE\"] = 230] = \"EVENT_TWENTY_NINE\";\n  Stage[Stage[\"EVENT_THIRTY_PART_ONE\"] = 231] = \"EVENT_THIRTY_PART_ONE\";\n  Stage[Stage[\"EVENT_THIRTY_ONE\"] = 232] = \"EVENT_THIRTY_ONE\";\n  Stage[Stage[\"EVENT_THIRTY_TWO\"] = 233] = \"EVENT_THIRTY_TWO\";\n  Stage[Stage[\"EVENT_THIRTY_THREE\"] = 234] = \"EVENT_THIRTY_THREE\";\n  Stage[Stage[\"EVENT_THIRTY_FOUR\"] = 235] = \"EVENT_THIRTY_FOUR\";\n  Stage[Stage[\"EVENT_FORTY_EIGHT\"] = 236] = \"EVENT_FORTY_EIGHT\";\n  Stage[Stage[\"EVENT_THIRTY_SIX_PART_ONE\"] = 237] = \"EVENT_THIRTY_SIX_PART_ONE\";\n  Stage[Stage[\"EVENT_FIFTEEN\"] = 238] = \"EVENT_FIFTEEN\";\n  Stage[Stage[\"EVENT_THIRTY_EIGHT\"] = 239] = \"EVENT_THIRTY_EIGHT\";\n  Stage[Stage[\"EVENT_THIRTY_NINE\"] = 240] = \"EVENT_THIRTY_NINE\";\n  Stage[Stage[\"EVENT_FORTY_PART_ONE\"] = 241] = \"EVENT_FORTY_PART_ONE\";\n  Stage[Stage[\"EVENT_FORTY_ONE\"] = 242] = \"EVENT_FORTY_ONE\";\n  Stage[Stage[\"EVENT_FORTY_TWO\"] = 243] = \"EVENT_FORTY_TWO\";\n  Stage[Stage[\"EVENT_FORTY_THREE\"] = 244] = \"EVENT_FORTY_THREE\";\n  Stage[Stage[\"EVENT_FORTY_FOUR\"] = 245] = \"EVENT_FORTY_FOUR\";\n  Stage[Stage[\"EVENT_FORTY_FIVE\"] = 246] = \"EVENT_FORTY_FIVE\";\n  Stage[Stage[\"EVENT_FORTY_SIX\"] = 247] = \"EVENT_FORTY_SIX\";\n  Stage[Stage[\"EVENT_FORTY_SEVEN\"] = 248] = \"EVENT_FORTY_SEVEN\";\n  Stage[Stage[\"EVENT_THIRTY_FIVE\"] = 249] = \"EVENT_THIRTY_FIVE\";\n  Stage[Stage[\"EVENT_FORTY_NINE_PART_ONE\"] = 250] = \"EVENT_FORTY_NINE_PART_ONE\";\n  Stage[Stage[\"EVENT_FIFTY\"] = 251] = \"EVENT_FIFTY\";\n  Stage[Stage[\"EVENT_FIFTY_ONE\"] = 252] = \"EVENT_FIFTY_ONE\";\n  Stage[Stage[\"EVENT_TEN_PART_TWO\"] = 253] = \"EVENT_TEN_PART_TWO\";\n  Stage[Stage[\"EVENT_TEN_PART_THREE\"] = 254] = \"EVENT_TEN_PART_THREE\";\n  Stage[Stage[\"EVENT_TEN_PART_FOUR\"] = 255] = \"EVENT_TEN_PART_FOUR\";\n  Stage[Stage[\"EVENT_TEN_PART_FIVE\"] = 256] = \"EVENT_TEN_PART_FIVE\";\n  Stage[Stage[\"EVENT_TWENTY_PART_TWO\"] = 257] = \"EVENT_TWENTY_PART_TWO\";\n  Stage[Stage[\"EVENT_TWENTY_PART_THREE\"] = 258] = \"EVENT_TWENTY_PART_THREE\";\n  Stage[Stage[\"EVENT_TWENTY_PART_FOUR\"] = 259] = \"EVENT_TWENTY_PART_FOUR\";\n  Stage[Stage[\"EVENT_TWENTY_PART_FIVE\"] = 260] = \"EVENT_TWENTY_PART_FIVE\";\n  Stage[Stage[\"EVENT_THIRTY_PART_TWO\"] = 261] = \"EVENT_THIRTY_PART_TWO\";\n  Stage[Stage[\"EVENT_THIRTY_PART_THREE\"] = 262] = \"EVENT_THIRTY_PART_THREE\";\n  Stage[Stage[\"EVENT_THIRTY_PART_FOUR\"] = 263] = \"EVENT_THIRTY_PART_FOUR\";\n  Stage[Stage[\"EVENT_FORTY_PART_TWO\"] = 264] = \"EVENT_FORTY_PART_TWO\";\n  Stage[Stage[\"EVENT_FORTY_PART_THREE\"] = 265] = \"EVENT_FORTY_PART_THREE\";\n  Stage[Stage[\"EVENT_FORTY_PART_FOUR\"] = 266] = \"EVENT_FORTY_PART_FOUR\";\n  Stage[Stage[\"EVENT_FORTY_PART_FIVE\"] = 267] = \"EVENT_FORTY_PART_FIVE\";\n  Stage[Stage[\"EVENT_FORTY_NINE_PART_TWO\"] = 268] = \"EVENT_FORTY_NINE_PART_TWO\";\n  Stage[Stage[\"EVENT_FORTY_NINE_PART_THREE\"] = 269] = \"EVENT_FORTY_NINE_PART_THREE\";\n  Stage[Stage[\"EVENT_FORTY_NINE_PART_FOUR\"] = 270] = \"EVENT_FORTY_NINE_PART_FOUR\";\n  Stage[Stage[\"EVENT_FORTY_NINE_PART_FIVE\"] = 271] = \"EVENT_FORTY_NINE_PART_FIVE\";\n  Stage[Stage[\"EVENT_FORTY_NINE_PART_SIX\"] = 272] = \"EVENT_FORTY_NINE_PART_SIX\";\n  Stage[Stage[\"EVENT_THIRTY_SIX_PART_TWO\"] = 273] = \"EVENT_THIRTY_SIX_PART_TWO\";\n  Stage[Stage[\"MULTI_MAN_MELEE\"] = 285] = \"MULTI_MAN_MELEE\";\n})(exports.Stage || (exports.Stage = {}));\nexports.State = void 0;\n(function (State) {\n  // Animation ID ranges\n  State[State[\"DAMAGE_START\"] = 75] = \"DAMAGE_START\";\n  State[State[\"DAMAGE_END\"] = 91] = \"DAMAGE_END\";\n  State[State[\"CAPTURE_START\"] = 223] = \"CAPTURE_START\";\n  State[State[\"CAPTURE_END\"] = 232] = \"CAPTURE_END\";\n  State[State[\"GUARD_START\"] = 178] = \"GUARD_START\";\n  State[State[\"GUARD_END\"] = 182] = \"GUARD_END\";\n  State[State[\"GROUNDED_CONTROL_START\"] = 14] = \"GROUNDED_CONTROL_START\";\n  State[State[\"GROUNDED_CONTROL_END\"] = 24] = \"GROUNDED_CONTROL_END\";\n  State[State[\"SQUAT_START\"] = 39] = \"SQUAT_START\";\n  State[State[\"SQUAT_END\"] = 41] = \"SQUAT_END\";\n  State[State[\"DOWN_START\"] = 183] = \"DOWN_START\";\n  State[State[\"DOWN_END\"] = 198] = \"DOWN_END\";\n  State[State[\"TECH_START\"] = 199] = \"TECH_START\";\n  State[State[\"TECH_END\"] = 204] = \"TECH_END\";\n  State[State[\"DYING_START\"] = 0] = \"DYING_START\";\n  State[State[\"DYING_END\"] = 10] = \"DYING_END\";\n  State[State[\"CONTROLLED_JUMP_START\"] = 24] = \"CONTROLLED_JUMP_START\";\n  State[State[\"CONTROLLED_JUMP_END\"] = 34] = \"CONTROLLED_JUMP_END\";\n  State[State[\"GROUND_ATTACK_START\"] = 44] = \"GROUND_ATTACK_START\";\n  State[State[\"GROUND_ATTACK_END\"] = 64] = \"GROUND_ATTACK_END\";\n  State[State[\"AERIAL_ATTACK_START\"] = 65] = \"AERIAL_ATTACK_START\";\n  State[State[\"AERIAL_ATTACK_END\"] = 74] = \"AERIAL_ATTACK_END\";\n  State[State[\"ATTACK_FTILT_START\"] = 51] = \"ATTACK_FTILT_START\";\n  State[State[\"ATTACK_FTILT_END\"] = 55] = \"ATTACK_FTILT_END\";\n  State[State[\"ATTACK_FSMASH_START\"] = 58] = \"ATTACK_FSMASH_START\";\n  State[State[\"ATTACK_FSMASH_END\"] = 62] = \"ATTACK_FSMASH_END\"; // Animation ID specific\n\n  State[State[\"ROLL_FORWARD\"] = 233] = \"ROLL_FORWARD\";\n  State[State[\"ROLL_BACKWARD\"] = 234] = \"ROLL_BACKWARD\";\n  State[State[\"SPOT_DODGE\"] = 235] = \"SPOT_DODGE\";\n  State[State[\"AIR_DODGE\"] = 236] = \"AIR_DODGE\";\n  State[State[\"ACTION_WAIT\"] = 14] = \"ACTION_WAIT\";\n  State[State[\"ACTION_DASH\"] = 20] = \"ACTION_DASH\";\n  State[State[\"ACTION_KNEE_BEND\"] = 24] = \"ACTION_KNEE_BEND\";\n  State[State[\"GUARD_ON\"] = 178] = \"GUARD_ON\";\n  State[State[\"TECH_MISS_UP\"] = 183] = \"TECH_MISS_UP\";\n  State[State[\"JAB_RESET_UP\"] = 185] = \"JAB_RESET_UP\";\n  State[State[\"TECH_MISS_DOWN\"] = 191] = \"TECH_MISS_DOWN\";\n  State[State[\"JAB_RESET_DOWN\"] = 193] = \"JAB_RESET_DOWN\";\n  State[State[\"NEUTRAL_TECH\"] = 199] = \"NEUTRAL_TECH\";\n  State[State[\"FORWARD_TECH\"] = 200] = \"FORWARD_TECH\";\n  State[State[\"BACKWARD_TECH\"] = 201] = \"BACKWARD_TECH\";\n  State[State[\"WALL_TECH\"] = 202] = \"WALL_TECH\";\n  State[State[\"MISSED_WALL_TECH\"] = 247] = \"MISSED_WALL_TECH\";\n  State[State[\"DASH\"] = 20] = \"DASH\";\n  State[State[\"TURN\"] = 18] = \"TURN\";\n  State[State[\"LANDING_FALL_SPECIAL\"] = 43] = \"LANDING_FALL_SPECIAL\";\n  State[State[\"JUMP_FORWARD\"] = 25] = \"JUMP_FORWARD\";\n  State[State[\"JUMP_BACKWARD\"] = 26] = \"JUMP_BACKWARD\";\n  State[State[\"FALL_FORWARD\"] = 30] = \"FALL_FORWARD\";\n  State[State[\"FALL_BACKWARD\"] = 31] = \"FALL_BACKWARD\";\n  State[State[\"GRAB\"] = 212] = \"GRAB\";\n  State[State[\"DASH_GRAB\"] = 214] = \"DASH_GRAB\";\n  State[State[\"GRAB_WAIT\"] = 216] = \"GRAB_WAIT\";\n  State[State[\"PUMMEL\"] = 217] = \"PUMMEL\";\n  State[State[\"CLIFF_CATCH\"] = 252] = \"CLIFF_CATCH\";\n  State[State[\"THROW_UP\"] = 221] = \"THROW_UP\";\n  State[State[\"THROW_FORWARD\"] = 219] = \"THROW_FORWARD\";\n  State[State[\"THROW_DOWN\"] = 222] = \"THROW_DOWN\";\n  State[State[\"THROW_BACK\"] = 220] = \"THROW_BACK\";\n  State[State[\"DAMAGE_FALL\"] = 38] = \"DAMAGE_FALL\";\n  State[State[\"ATTACK_JAB1\"] = 44] = \"ATTACK_JAB1\";\n  State[State[\"ATTACK_JAB2\"] = 45] = \"ATTACK_JAB2\";\n  State[State[\"ATTACK_JAB3\"] = 46] = \"ATTACK_JAB3\";\n  State[State[\"ATTACK_JABM\"] = 47] = \"ATTACK_JABM\";\n  State[State[\"ATTACK_DASH\"] = 50] = \"ATTACK_DASH\";\n  State[State[\"ATTACK_UTILT\"] = 56] = \"ATTACK_UTILT\";\n  State[State[\"ATTACK_DTILT\"] = 57] = \"ATTACK_DTILT\";\n  State[State[\"ATTACK_USMASH\"] = 63] = \"ATTACK_USMASH\";\n  State[State[\"ATTACK_DSMASH\"] = 64] = \"ATTACK_DSMASH\";\n  State[State[\"AERIAL_NAIR\"] = 65] = \"AERIAL_NAIR\";\n  State[State[\"AERIAL_FAIR\"] = 66] = \"AERIAL_FAIR\";\n  State[State[\"AERIAL_BAIR\"] = 67] = \"AERIAL_BAIR\";\n  State[State[\"AERIAL_UAIR\"] = 68] = \"AERIAL_UAIR\";\n  State[State[\"AERIAL_DAIR\"] = 69] = \"AERIAL_DAIR\"; // Weird GnW IDs\n\n  State[State[\"GNW_JAB1\"] = 341] = \"GNW_JAB1\";\n  State[State[\"GNW_JABM\"] = 342] = \"GNW_JABM\";\n  State[State[\"GNW_DTILT\"] = 345] = \"GNW_DTILT\";\n  State[State[\"GNW_FSMASH\"] = 346] = \"GNW_FSMASH\";\n  State[State[\"GNW_NAIR\"] = 347] = \"GNW_NAIR\";\n  State[State[\"GNW_BAIR\"] = 348] = \"GNW_BAIR\";\n  State[State[\"GNW_UAIR\"] = 349] = \"GNW_UAIR\"; // Peach FSMASH ID\n  // FSMASH1 = Golf Club, FSMASH2 = Frying Pan, FSMASH3 = Tennis Racket\n\n  State[State[\"PEACH_FSMASH1\"] = 349] = \"PEACH_FSMASH1\";\n  State[State[\"PEACH_FSMASH2\"] = 350] = \"PEACH_FSMASH2\";\n  State[State[\"PEACH_FSMASH3\"] = 351] = \"PEACH_FSMASH3\"; // Command Grabs\n\n  State[State[\"BARREL_WAIT\"] = 293] = \"BARREL_WAIT\";\n  State[State[\"COMMAND_GRAB_RANGE1_START\"] = 266] = \"COMMAND_GRAB_RANGE1_START\";\n  State[State[\"COMMAND_GRAB_RANGE1_END\"] = 304] = \"COMMAND_GRAB_RANGE1_END\";\n  State[State[\"COMMAND_GRAB_RANGE2_START\"] = 327] = \"COMMAND_GRAB_RANGE2_START\";\n  State[State[\"COMMAND_GRAB_RANGE2_END\"] = 338] = \"COMMAND_GRAB_RANGE2_END\";\n})(exports.State || (exports.State = {}));\nconst Timers = {\n  PUNISH_RESET_FRAMES: 45,\n  RECOVERY_RESET_FRAMES: 45,\n  COMBO_STRING_RESET_FRAMES: 45\n};\nfunction getSinglesPlayerPermutationsFromSettings(settings) {\n  if (!settings || settings.players.length !== 2) {\n    // Only return opponent indices for singles\n    return [];\n  }\n  return [{\n    playerIndex: settings.players[0].playerIndex,\n    opponentIndex: settings.players[1].playerIndex\n  }, {\n    playerIndex: settings.players[1].playerIndex,\n    opponentIndex: settings.players[0].playerIndex\n  }];\n}\nfunction didLoseStock(frame, prevFrame) {\n  if (!frame || !prevFrame) {\n    return false;\n  }\n  return prevFrame.stocksRemaining - frame.stocksRemaining > 0;\n}\nfunction isInControl(state) {\n  const ground = state >= exports.State.GROUNDED_CONTROL_START && state <= exports.State.GROUNDED_CONTROL_END;\n  const squat = state >= exports.State.SQUAT_START && state <= exports.State.SQUAT_END;\n  const groundAttack = state > exports.State.GROUND_ATTACK_START && state <= exports.State.GROUND_ATTACK_END;\n  const isGrab = state === exports.State.GRAB; // TODO: Add grounded b moves?\n\n  return ground || squat || groundAttack || isGrab;\n}\nfunction isTeching(state) {\n  return state >= exports.State.TECH_START && state <= exports.State.TECH_END;\n}\nfunction isDown(state) {\n  return state >= exports.State.DOWN_START && state <= exports.State.DOWN_END;\n}\nfunction isDamaged(state) {\n  return state >= exports.State.DAMAGE_START && state <= exports.State.DAMAGE_END || state === exports.State.DAMAGE_FALL || state === exports.State.JAB_RESET_UP || state === exports.State.JAB_RESET_DOWN;\n}\nfunction isGrabbed(state) {\n  return state >= exports.State.CAPTURE_START && state <= exports.State.CAPTURE_END;\n} // TODO: Find better implementation of 3 seperate ranges\n\nfunction isCommandGrabbed(state) {\n  return (state >= exports.State.COMMAND_GRAB_RANGE1_START && state <= exports.State.COMMAND_GRAB_RANGE1_END || state >= exports.State.COMMAND_GRAB_RANGE2_START && state <= exports.State.COMMAND_GRAB_RANGE2_END) && state !== exports.State.BARREL_WAIT;\n}\nfunction isDead(state) {\n  return state >= exports.State.DYING_START && state <= exports.State.DYING_END;\n}\nfunction calcDamageTaken(frame, prevFrame) {\n  var _frame$percent, _prevFrame$percent;\n  const percent = (_frame$percent = frame.percent) != null ? _frame$percent : 0;\n  const prevPercent = (_prevFrame$percent = prevFrame.percent) != null ? _prevFrame$percent : 0;\n  return percent - prevPercent;\n}\nconst dashDanceAnimations = [exports.State.DASH, exports.State.TURN, exports.State.DASH];\nclass ActionsComputer {\n  constructor() {\n    this.playerPermutations = new Array();\n    this.state = new Map();\n  }\n  setup(settings) {\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.playerPermutations.forEach(indices => {\n      const playerCounts = {\n        playerIndex: indices.playerIndex,\n        wavedashCount: 0,\n        wavelandCount: 0,\n        airDodgeCount: 0,\n        dashDanceCount: 0,\n        spotDodgeCount: 0,\n        ledgegrabCount: 0,\n        rollCount: 0,\n        lCancelCount: {\n          success: 0,\n          fail: 0\n        },\n        attackCount: {\n          jab1: 0,\n          jab2: 0,\n          jab3: 0,\n          jabm: 0,\n          dash: 0,\n          ftilt: 0,\n          utilt: 0,\n          dtilt: 0,\n          fsmash: 0,\n          usmash: 0,\n          dsmash: 0,\n          nair: 0,\n          fair: 0,\n          bair: 0,\n          uair: 0,\n          dair: 0\n        },\n        grabCount: {\n          success: 0,\n          fail: 0\n        },\n        throwCount: {\n          up: 0,\n          forward: 0,\n          back: 0,\n          down: 0\n        },\n        groundTechCount: {\n          // tech away/in are in reference to the opponents position and not the stage\n          away: 0,\n          in: 0,\n          neutral: 0,\n          fail: 0\n        },\n        wallTechCount: {\n          success: 0,\n          fail: 0\n        }\n      };\n      const playerState = {\n        playerCounts: playerCounts,\n        animations: [],\n        actionFrameCounters: []\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n  processFrame(frame) {\n    this.playerPermutations.forEach(indices => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleActionCompute(state, indices, frame);\n      }\n    });\n  }\n  fetch() {\n    return Array.from(this.state.values()).map(val => val.playerCounts);\n  }\n}\nfunction isMissGroundTech(animation) {\n  return animation === exports.State.TECH_MISS_DOWN || animation === exports.State.TECH_MISS_UP;\n}\nfunction isRolling(animation) {\n  return animation === exports.State.ROLL_BACKWARD || animation === exports.State.ROLL_FORWARD;\n}\nfunction isGrabAction(animation) {\n  // Includes Grab pull, wait, pummel, and throws\n  return animation > exports.State.GRAB && animation <= exports.State.THROW_DOWN && animation !== exports.State.DASH_GRAB;\n}\nfunction isGrabbing(animation) {\n  return animation === exports.State.GRAB || animation === exports.State.DASH_GRAB;\n}\nfunction isAerialAttack(animation) {\n  return animation >= exports.State.AERIAL_ATTACK_START && animation <= exports.State.AERIAL_ATTACK_END;\n}\nfunction isForwardTilt(animation) {\n  return animation >= exports.State.ATTACK_FTILT_START && animation <= exports.State.ATTACK_FTILT_END;\n}\nfunction isForwardSmash(animation) {\n  return animation >= exports.State.ATTACK_FSMASH_START && animation <= exports.State.ATTACK_FSMASH_END;\n}\nfunction handleActionCompute(state, indices, frame) {\n  const playerFrame = frame.players[indices.playerIndex].post;\n  const opponentFrame = frame.players[indices.opponentIndex].post;\n  const incrementCount = (field, condition) => {\n    if (!condition) {\n      return;\n    }\n    const current = lodash.get(state.playerCounts, field, 0);\n    lodash.set(state.playerCounts, field, current + 1);\n  }; // Manage animation state\n\n  const currentAnimation = playerFrame.actionStateId;\n  state.animations.push(currentAnimation);\n  const currentFrameCounter = playerFrame.actionStateCounter;\n  state.actionFrameCounters.push(currentFrameCounter); // Grab last 3 frames\n\n  const last3Frames = state.animations.slice(-3);\n  const prevAnimation = last3Frames[last3Frames.length - 2];\n  const prevFrameCounter = state.actionFrameCounters[state.actionFrameCounters.length - 2]; // New action if new animation or frame counter goes back down (repeated action)\n\n  const isNewAction = currentAnimation !== prevAnimation || prevFrameCounter > currentFrameCounter;\n  if (!isNewAction) {\n    return;\n  } // Increment counts based on conditions\n\n  const didDashDance = lodash.isEqual(last3Frames, dashDanceAnimations);\n  incrementCount(\"dashDanceCount\", didDashDance);\n  incrementCount(\"rollCount\", isRolling(currentAnimation));\n  incrementCount(\"spotDodgeCount\", currentAnimation === exports.State.SPOT_DODGE);\n  incrementCount(\"airDodgeCount\", currentAnimation === exports.State.AIR_DODGE);\n  incrementCount(\"ledgegrabCount\", currentAnimation === exports.State.CLIFF_CATCH); // Grabs\n\n  incrementCount(\"grabCount.success\", isGrabbing(prevAnimation) && isGrabAction(currentAnimation));\n  incrementCount(\"grabCount.fail\", isGrabbing(prevAnimation) && !isGrabAction(currentAnimation));\n  if (currentAnimation === exports.State.DASH_GRAB && prevAnimation === exports.State.ATTACK_DASH) {\n    state.playerCounts.attackCount.dash -= 1; // subtract from dash attack if boost grab\n  } // Basic attacks\n\n  incrementCount(\"attackCount.jab1\", currentAnimation === exports.State.ATTACK_JAB1);\n  incrementCount(\"attackCount.jab2\", currentAnimation === exports.State.ATTACK_JAB2);\n  incrementCount(\"attackCount.jab3\", currentAnimation === exports.State.ATTACK_JAB3);\n  incrementCount(\"attackCount.jabm\", currentAnimation === exports.State.ATTACK_JABM);\n  incrementCount(\"attackCount.dash\", currentAnimation === exports.State.ATTACK_DASH);\n  incrementCount(\"attackCount.ftilt\", isForwardTilt(currentAnimation));\n  incrementCount(\"attackCount.utilt\", currentAnimation === exports.State.ATTACK_UTILT);\n  incrementCount(\"attackCount.dtilt\", currentAnimation === exports.State.ATTACK_DTILT);\n  incrementCount(\"attackCount.fsmash\", isForwardSmash(currentAnimation));\n  incrementCount(\"attackCount.usmash\", currentAnimation === exports.State.ATTACK_USMASH);\n  incrementCount(\"attackCount.dsmash\", currentAnimation === exports.State.ATTACK_DSMASH);\n  incrementCount(\"attackCount.nair\", currentAnimation === exports.State.AERIAL_NAIR);\n  incrementCount(\"attackCount.fair\", currentAnimation === exports.State.AERIAL_FAIR);\n  incrementCount(\"attackCount.bair\", currentAnimation === exports.State.AERIAL_BAIR);\n  incrementCount(\"attackCount.uair\", currentAnimation === exports.State.AERIAL_UAIR);\n  incrementCount(\"attackCount.dair\", currentAnimation === exports.State.AERIAL_DAIR); // GnW is weird and has unique IDs for some moves\n\n  if (playerFrame.internalCharacterId === 0x18) {\n    incrementCount(\"attackCount.jab1\", currentAnimation === exports.State.GNW_JAB1);\n    incrementCount(\"attackCount.jabm\", currentAnimation === exports.State.GNW_JABM);\n    incrementCount(\"attackCount.dtilt\", currentAnimation === exports.State.GNW_DTILT);\n    incrementCount(\"attackCount.fsmash\", currentAnimation === exports.State.GNW_FSMASH);\n    incrementCount(\"attackCount.nair\", currentAnimation === exports.State.GNW_NAIR);\n    incrementCount(\"attackCount.bair\", currentAnimation === exports.State.GNW_BAIR);\n    incrementCount(\"attackCount.uair\", currentAnimation === exports.State.GNW_UAIR);\n  } // Peach is also weird and has a unique ID for her fsmash\n  // FSMASH1 = Golf Club, FSMASH2 = Frying Pan, FSMASH3 = Tennis Racket\n\n  if (playerFrame.internalCharacterId === 0x09) {\n    incrementCount(\"attackCount.fsmash\", currentAnimation === exports.State.PEACH_FSMASH1);\n    incrementCount(\"attackCount.fsmash\", currentAnimation === exports.State.PEACH_FSMASH2);\n    incrementCount(\"attackCount.fsmash\", currentAnimation === exports.State.PEACH_FSMASH3);\n  } // Throws\n\n  incrementCount(\"throwCount.up\", currentAnimation === exports.State.THROW_UP);\n  incrementCount(\"throwCount.forward\", currentAnimation === exports.State.THROW_FORWARD);\n  incrementCount(\"throwCount.down\", currentAnimation === exports.State.THROW_DOWN);\n  incrementCount(\"throwCount.back\", currentAnimation === exports.State.THROW_BACK); // Techs\n\n  const opponentDir = playerFrame.positionX > opponentFrame.positionX ? -1 : 1;\n  const facingOpponent = playerFrame.facingDirection === opponentDir;\n  incrementCount(\"groundTechCount.fail\", isMissGroundTech(currentAnimation));\n  incrementCount(\"groundTechCount.in\", currentAnimation === exports.State.FORWARD_TECH && facingOpponent);\n  incrementCount(\"groundTechCount.in\", currentAnimation === exports.State.BACKWARD_TECH && !facingOpponent);\n  incrementCount(\"groundTechCount.neutral\", currentAnimation === exports.State.NEUTRAL_TECH);\n  incrementCount(\"groundTechCount.away\", currentAnimation === exports.State.BACKWARD_TECH && facingOpponent);\n  incrementCount(\"groundTechCount.away\", currentAnimation === exports.State.FORWARD_TECH && !facingOpponent);\n  incrementCount(\"wallTechCount.success\", currentAnimation === exports.State.WALL_TECH);\n  incrementCount(\"wallTechCount.fail\", currentAnimation === exports.State.MISSED_WALL_TECH);\n  if (isAerialAttack(currentAnimation)) {\n    incrementCount(\"lCancelCount.success\", playerFrame.lCancelStatus === 1);\n    incrementCount(\"lCancelCount.fail\", playerFrame.lCancelStatus === 2);\n  } // Handles wavedash detection (and waveland)\n\n  handleActionWavedash(state.playerCounts, state.animations);\n}\nfunction handleActionWavedash(counts, animations) {\n  const currentAnimation = lodash.last(animations);\n  const prevAnimation = animations[animations.length - 2];\n  const isSpecialLanding = currentAnimation === exports.State.LANDING_FALL_SPECIAL;\n  const isAcceptablePrevious = isWavedashInitiationAnimation(prevAnimation);\n  const isPossibleWavedash = isSpecialLanding && isAcceptablePrevious;\n  if (!isPossibleWavedash) {\n    return;\n  } // Here we special landed, it might be a wavedash, let's check\n  // We grab the last 8 frames here because that should be enough time to execute a\n  // wavedash. This number could be tweaked if we find false negatives\n\n  const recentFrames = animations.slice(-8);\n  const recentAnimations = lodash.keyBy(recentFrames, animation => animation);\n  if (lodash.size(recentAnimations) === 2 && recentAnimations[exports.State.AIR_DODGE]) {\n    // If the only other animation is air dodge, this might be really late to the point\n    // where it was actually an air dodge. Air dodge animation is really long\n    return;\n  }\n  if (recentAnimations[exports.State.AIR_DODGE]) {\n    // If one of the recent animations was an air dodge, let's remove that from the\n    // air dodge counter, we don't want to count air dodges used to wavedash/land\n    counts.airDodgeCount -= 1;\n  }\n  if (recentAnimations[exports.State.ACTION_KNEE_BEND]) {\n    // If a jump was started recently, we will consider this a wavedash\n    counts.wavedashCount += 1;\n  } else {\n    // If there was no jump recently, this is a waveland\n    counts.wavelandCount += 1;\n  }\n}\nfunction isWavedashInitiationAnimation(animation) {\n  if (animation === exports.State.AIR_DODGE) {\n    return true;\n  }\n  const isAboveMin = animation >= exports.State.CONTROLLED_JUMP_START;\n  const isBelowMax = animation <= exports.State.CONTROLLED_JUMP_END;\n  return isAboveMin && isBelowMax;\n}\nvar ComboEvent;\n(function (ComboEvent) {\n  ComboEvent[\"COMBO_START\"] = \"COMBO_START\";\n  ComboEvent[\"COMBO_EXTEND\"] = \"COMBO_EXTEND\";\n  ComboEvent[\"COMBO_END\"] = \"COMBO_END\";\n})(ComboEvent || (ComboEvent = {}));\nclass ComboComputer extends events.EventEmitter {\n  constructor(...args) {\n    super(...args);\n    this.playerPermutations = new Array();\n    this.state = new Map();\n    this.combos = new Array();\n    this.settings = null;\n  }\n  setup(settings) {\n    // Reset the state\n    this.settings = settings;\n    this.state = new Map();\n    this.combos = [];\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.playerPermutations.forEach(indices => {\n      const playerState = {\n        combo: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n        event: null\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n  processFrame(frame, allFrames) {\n    this.playerPermutations.forEach(indices => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleComboCompute(allFrames, state, indices, frame, this.combos); // Emit an event for the new combo\n\n        if (state.event !== null) {\n          this.emit(state.event, {\n            combo: lodash.last(this.combos),\n            settings: this.settings\n          });\n          state.event = null;\n        }\n      }\n    });\n  }\n  fetch() {\n    return this.combos;\n  }\n}\nfunction handleComboCompute(frames, state, indices, frame, combos) {\n  const currentFrameNumber = frame.frame;\n  const playerFrame = frame.players[indices.playerIndex].post;\n  const opponentFrame = frame.players[indices.opponentIndex].post;\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame = null;\n  let prevOpponentFrame = null;\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber].players[indices.playerIndex].post;\n    prevOpponentFrame = frames[prevFrameNumber].players[indices.opponentIndex].post;\n  }\n  const oppActionStateId = opponentFrame.actionStateId;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0; // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  } // If opponent took damage and was put in some kind of stun this frame, either\n  // start a combo or count the moves for the existing combo\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    let comboStarted = false;\n    if (!state.combo) {\n      var _prevOpponentFrame$pe, _opponentFrame$percen;\n      state.combo = {\n        playerIndex: indices.opponentIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? (_prevOpponentFrame$pe = prevOpponentFrame.percent) != null ? _prevOpponentFrame$pe : 0 : 0,\n        currentPercent: (_opponentFrame$percen = opponentFrame.percent) != null ? _opponentFrame$percen : 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        lastHitBy: indices.playerIndex\n      };\n      combos.push(state.combo); // Track whether this is a new combo or not\n\n      comboStarted = true;\n    }\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded,\n          hitCount: 0,\n          damage: 0\n        };\n        state.combo.moves.push(state.move); // Make sure we don't overwrite the START event\n\n        if (!comboStarted) {\n          state.event = ComboEvent.COMBO_EXTEND;\n        }\n      }\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      } // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n    if (comboStarted) {\n      state.event = ComboEvent.COMBO_START;\n    }\n  }\n  if (!state.combo) {\n    // The rest of the function handles combo termination logic, so if we don't\n    // have a combo started, there is no need to continue\n    return;\n  }\n  const opntIsTeching = isTeching(oppActionStateId);\n  const opntIsDowned = isDown(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n  const opntIsDying = isDead(oppActionStateId); // Update percent if opponent didn't lose stock\n\n  if (!opntDidLoseStock) {\n    var _opponentFrame$percen2;\n    state.combo.currentPercent = (_opponentFrame$percen2 = opponentFrame.percent) != null ? _opponentFrame$percen2 : 0;\n  }\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed || opntIsTeching || opntIsDowned || opntIsDying) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  } else {\n    state.resetCounter += 1;\n  }\n  let shouldTerminate = false; // Termination condition 1 - player kills opponent\n\n  if (opntDidLoseStock) {\n    state.combo.didKill = true;\n    shouldTerminate = true;\n  } // Termination condition 2 - combo resets on time\n\n  if (state.resetCounter > Timers.COMBO_STRING_RESET_FRAMES) {\n    shouldTerminate = true;\n  } // If combo should terminate, mark the end states and add it to list\n\n  if (shouldTerminate) {\n    var _prevOpponentFrame$pe2;\n    state.combo.endFrame = playerFrame.frame;\n    state.combo.endPercent = prevOpponentFrame ? (_prevOpponentFrame$pe2 = prevOpponentFrame.percent) != null ? _prevOpponentFrame$pe2 : 0 : 0;\n    state.event = ComboEvent.COMBO_END;\n    state.combo = null;\n    state.move = null;\n  }\n}\nclass ConversionComputer extends events.EventEmitter {\n  constructor() {\n    super();\n    this.playerPermutations = new Array();\n    this.conversions = new Array();\n    this.state = new Map();\n    this.metadata = void 0;\n    this.settings = null;\n    this.metadata = {\n      lastEndFrameByOppIdx: {}\n    };\n  }\n  setup(settings) {\n    // Reset the state\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.conversions = [];\n    this.state = new Map();\n    this.metadata = {\n      lastEndFrameByOppIdx: {}\n    };\n    this.settings = settings;\n    this.playerPermutations.forEach(indices => {\n      const playerState = {\n        conversion: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n  processFrame(frame, allFrames) {\n    this.playerPermutations.forEach(indices => {\n      const state = this.state.get(indices);\n      if (state) {\n        const terminated = handleConversionCompute(allFrames, state, indices, frame, this.conversions);\n        if (terminated) {\n          this.emit(\"CONVERSION\", {\n            combo: lodash.last(this.conversions),\n            settings: this.settings\n          });\n        }\n      }\n    });\n  }\n  fetch() {\n    this._populateConversionTypes();\n    return this.conversions;\n  }\n  _populateConversionTypes() {\n    // Post-processing step: set the openingTypes\n    const conversionsToHandle = lodash.filter(this.conversions, conversion => {\n      return conversion.openingType === \"unknown\";\n    }); // Group new conversions by startTime and sort\n\n    const groupedConversions = lodash.groupBy(conversionsToHandle, \"startFrame\");\n    const sortedConversions = lodash.orderBy(groupedConversions, conversions => lodash.get(conversions, [0, \"startFrame\"])); // Set the opening types on the conversions we need to handle\n\n    sortedConversions.forEach(conversions => {\n      const isTrade = conversions.length >= 2;\n      conversions.forEach(conversion => {\n        // Set end frame for this conversion\n        this.metadata.lastEndFrameByOppIdx[conversion.playerIndex] = conversion.endFrame;\n        if (isTrade) {\n          // If trade, just short-circuit\n          conversion.openingType = \"trade\";\n          return;\n        } // If not trade, check the opponent endFrame\n\n        const lastMove = lodash.last(conversion.moves);\n        const oppEndFrame = this.metadata.lastEndFrameByOppIdx[lastMove ? lastMove.playerIndex : conversion.playerIndex];\n        const isCounterAttack = oppEndFrame && oppEndFrame > conversion.startFrame;\n        conversion.openingType = isCounterAttack ? \"counter-attack\" : \"neutral-win\";\n      });\n    });\n  }\n}\nfunction handleConversionCompute(frames, state, indices, frame, conversions) {\n  const currentFrameNumber = frame.frame;\n  const playerFrame = frame.players[indices.playerIndex].post;\n  const opponentFrame = frame.players[indices.opponentIndex].post;\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame = null;\n  let prevOpponentFrame = null;\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber].players[indices.playerIndex].post;\n    prevOpponentFrame = frames[prevFrameNumber].players[indices.opponentIndex].post;\n  }\n  const oppActionStateId = opponentFrame.actionStateId;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0; // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  } // If opponent took damage and was put in some kind of stun this frame, either\n  // start a conversion or\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    if (!state.conversion) {\n      var _prevOpponentFrame$pe, _opponentFrame$percen;\n      state.conversion = {\n        playerIndex: indices.opponentIndex,\n        lastHitBy: indices.playerIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? (_prevOpponentFrame$pe = prevOpponentFrame.percent) != null ? _prevOpponentFrame$pe : 0 : 0,\n        currentPercent: (_opponentFrame$percen = opponentFrame.percent) != null ? _opponentFrame$percen : 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        openingType: \"unknown\" // Will be updated later\n      };\n\n      conversions.push(state.conversion);\n    }\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded,\n          hitCount: 0,\n          damage: 0\n        };\n        state.conversion.moves.push(state.move);\n      }\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      } // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n  }\n  if (!state.conversion) {\n    // The rest of the function handles conversion termination logic, so if we don't\n    // have a conversion started, there is no need to continue\n    return false;\n  }\n  const opntInControl = isInControl(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame); // Update percent if opponent didn't lose stock\n\n  if (!opntDidLoseStock) {\n    var _opponentFrame$percen2;\n    state.conversion.currentPercent = (_opponentFrame$percen2 = opponentFrame.percent) != null ? _opponentFrame$percen2 : 0;\n  }\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  }\n  const shouldStartResetCounter = state.resetCounter === 0 && opntInControl;\n  const shouldContinueResetCounter = state.resetCounter > 0;\n  if (shouldStartResetCounter || shouldContinueResetCounter) {\n    // This will increment the reset timer under the following conditions:\n    // 1) if we were punishing opponent but they have now entered an actionable state\n    // 2) if counter has already started counting meaning opponent has entered actionable state\n    state.resetCounter += 1;\n  }\n  let shouldTerminate = false; // Termination condition 1 - player kills opponent\n\n  if (opntDidLoseStock) {\n    state.conversion.didKill = true;\n    shouldTerminate = true;\n  } // Termination condition 2 - conversion resets on time\n\n  if (state.resetCounter > Timers.PUNISH_RESET_FRAMES) {\n    shouldTerminate = true;\n  } // If conversion should terminate, mark the end states and add it to list\n\n  if (shouldTerminate) {\n    var _prevOpponentFrame$pe2;\n    state.conversion.endFrame = playerFrame.frame;\n    state.conversion.endPercent = prevOpponentFrame ? (_prevOpponentFrame$pe2 = prevOpponentFrame.percent) != null ? _prevOpponentFrame$pe2 : 0 : 0;\n    state.conversion = null;\n    state.move = null;\n  }\n  return shouldTerminate;\n}\nexports.Command = void 0;\n(function (Command) {\n  Command[Command[\"SPLIT_MESSAGE\"] = 16] = \"SPLIT_MESSAGE\";\n  Command[Command[\"MESSAGE_SIZES\"] = 53] = \"MESSAGE_SIZES\";\n  Command[Command[\"GAME_START\"] = 54] = \"GAME_START\";\n  Command[Command[\"PRE_FRAME_UPDATE\"] = 55] = \"PRE_FRAME_UPDATE\";\n  Command[Command[\"POST_FRAME_UPDATE\"] = 56] = \"POST_FRAME_UPDATE\";\n  Command[Command[\"GAME_END\"] = 57] = \"GAME_END\";\n  Command[Command[\"FRAME_START\"] = 58] = \"FRAME_START\";\n  Command[Command[\"ITEM_UPDATE\"] = 59] = \"ITEM_UPDATE\";\n  Command[Command[\"FRAME_BOOKEND\"] = 60] = \"FRAME_BOOKEND\";\n  Command[Command[\"GECKO_LIST\"] = 61] = \"GECKO_LIST\";\n})(exports.Command || (exports.Command = {}));\nexports.GameMode = void 0;\n(function (GameMode) {\n  GameMode[GameMode[\"VS\"] = 2] = \"VS\";\n  GameMode[GameMode[\"ONLINE\"] = 8] = \"ONLINE\";\n  GameMode[GameMode[\"TARGET_TEST\"] = 15] = \"TARGET_TEST\";\n  GameMode[GameMode[\"HOME_RUN_CONTEST\"] = 32] = \"HOME_RUN_CONTEST\";\n})(exports.GameMode || (exports.GameMode = {}));\nexports.Language = void 0;\n(function (Language) {\n  Language[Language[\"JAPANESE\"] = 0] = \"JAPANESE\";\n  Language[Language[\"ENGLISH\"] = 1] = \"ENGLISH\";\n})(exports.Language || (exports.Language = {}));\nexports.TimerType = void 0;\n(function (TimerType) {\n  TimerType[TimerType[\"NONE\"] = 0] = \"NONE\";\n  TimerType[TimerType[\"DECREASING\"] = 2] = \"DECREASING\";\n  TimerType[TimerType[\"INCREASING\"] = 3] = \"INCREASING\";\n})(exports.TimerType || (exports.TimerType = {}));\nexports.ItemSpawnType = void 0;\n(function (ItemSpawnType) {\n  ItemSpawnType[ItemSpawnType[\"OFF\"] = 255] = \"OFF\";\n  ItemSpawnType[ItemSpawnType[\"VERY_LOW\"] = 0] = \"VERY_LOW\";\n  ItemSpawnType[ItemSpawnType[\"LOW\"] = 1] = \"LOW\";\n  ItemSpawnType[ItemSpawnType[\"MEDIUM\"] = 2] = \"MEDIUM\";\n  ItemSpawnType[ItemSpawnType[\"HIGH\"] = 3] = \"HIGH\";\n  ItemSpawnType[ItemSpawnType[\"VERY_HIGH\"] = 4] = \"VERY_HIGH\";\n})(exports.ItemSpawnType || (exports.ItemSpawnType = {}));\nexports.EnabledItemType = void 0;\n(function (EnabledItemType) {\n  EnabledItemType[EnabledItemType[\"METAL_BOX\"] = 1] = \"METAL_BOX\";\n  EnabledItemType[EnabledItemType[\"CLOAKING_DEVICE\"] = 2] = \"CLOAKING_DEVICE\";\n  EnabledItemType[EnabledItemType[\"POKEBALL\"] = 4] = \"POKEBALL\"; // Bits 4 through 8 of item bitfield 1 are unknown\n\n  EnabledItemType[EnabledItemType[\"UNKNOWN_ITEM_BIT_4\"] = 8] = \"UNKNOWN_ITEM_BIT_4\";\n  EnabledItemType[EnabledItemType[\"UNKNOWN_ITEM_BIT_5\"] = 16] = \"UNKNOWN_ITEM_BIT_5\";\n  EnabledItemType[EnabledItemType[\"UNKNOWN_ITEM_BIT_6\"] = 32] = \"UNKNOWN_ITEM_BIT_6\";\n  EnabledItemType[EnabledItemType[\"UNKNOWN_ITEM_BIT_7\"] = 64] = \"UNKNOWN_ITEM_BIT_7\";\n  EnabledItemType[EnabledItemType[\"UNKNOWN_ITEM_BIT_8\"] = 128] = \"UNKNOWN_ITEM_BIT_8\";\n  EnabledItemType[EnabledItemType[\"FAN\"] = 256] = \"FAN\";\n  EnabledItemType[EnabledItemType[\"FIRE_FLOWER\"] = 512] = \"FIRE_FLOWER\";\n  EnabledItemType[EnabledItemType[\"SUPER_MUSHROOM\"] = 1024] = \"SUPER_MUSHROOM\";\n  EnabledItemType[EnabledItemType[\"POISON_MUSHROOM\"] = 2048] = \"POISON_MUSHROOM\";\n  EnabledItemType[EnabledItemType[\"HAMMER\"] = 4096] = \"HAMMER\";\n  EnabledItemType[EnabledItemType[\"WARP_STAR\"] = 8192] = \"WARP_STAR\";\n  EnabledItemType[EnabledItemType[\"SCREW_ATTACK\"] = 16384] = \"SCREW_ATTACK\";\n  EnabledItemType[EnabledItemType[\"BUNNY_HOOD\"] = 32768] = \"BUNNY_HOOD\";\n  EnabledItemType[EnabledItemType[\"RAY_GUN\"] = 65536] = \"RAY_GUN\";\n  EnabledItemType[EnabledItemType[\"FREEZIE\"] = 131072] = \"FREEZIE\";\n  EnabledItemType[EnabledItemType[\"FOOD\"] = 262144] = \"FOOD\";\n  EnabledItemType[EnabledItemType[\"MOTION_SENSOR_BOMB\"] = 524288] = \"MOTION_SENSOR_BOMB\";\n  EnabledItemType[EnabledItemType[\"FLIPPER\"] = 1048576] = \"FLIPPER\";\n  EnabledItemType[EnabledItemType[\"SUPER_SCOPE\"] = 2097152] = \"SUPER_SCOPE\";\n  EnabledItemType[EnabledItemType[\"STAR_ROD\"] = 4194304] = \"STAR_ROD\";\n  EnabledItemType[EnabledItemType[\"LIPS_STICK\"] = 8388608] = \"LIPS_STICK\";\n  EnabledItemType[EnabledItemType[\"HEART_CONTAINER\"] = 16777216] = \"HEART_CONTAINER\";\n  EnabledItemType[EnabledItemType[\"MAXIM_TOMATO\"] = 33554432] = \"MAXIM_TOMATO\";\n  EnabledItemType[EnabledItemType[\"STARMAN\"] = 67108864] = \"STARMAN\";\n  EnabledItemType[EnabledItemType[\"HOME_RUN_BAT\"] = 134217728] = \"HOME_RUN_BAT\";\n  EnabledItemType[EnabledItemType[\"BEAM_SWORD\"] = 268435456] = \"BEAM_SWORD\";\n  EnabledItemType[EnabledItemType[\"PARASOL\"] = 536870912] = \"PARASOL\";\n  EnabledItemType[EnabledItemType[\"GREEN_SHELL\"] = 1073741824] = \"GREEN_SHELL\";\n  EnabledItemType[EnabledItemType[\"RED_SHELL\"] = 2147483648] = \"RED_SHELL\";\n  EnabledItemType[EnabledItemType[\"CAPSULE\"] = 4294967296] = \"CAPSULE\";\n  EnabledItemType[EnabledItemType[\"BOX\"] = 8589934592] = \"BOX\";\n  EnabledItemType[EnabledItemType[\"BARREL\"] = 17179869184] = \"BARREL\";\n  EnabledItemType[EnabledItemType[\"EGG\"] = 34359738368] = \"EGG\";\n  EnabledItemType[EnabledItemType[\"PARTY_BALL\"] = 68719476736] = \"PARTY_BALL\";\n  EnabledItemType[EnabledItemType[\"BARREL_CANNON\"] = 137438953472] = \"BARREL_CANNON\";\n  EnabledItemType[EnabledItemType[\"BOMB_OMB\"] = 274877906944] = \"BOMB_OMB\";\n  EnabledItemType[EnabledItemType[\"MR_SATURN\"] = 549755813888] = \"MR_SATURN\";\n})(exports.EnabledItemType || (exports.EnabledItemType = {}));\nexports.GameEndMethod = void 0;\n(function (GameEndMethod) {\n  GameEndMethod[GameEndMethod[\"UNRESOLVED\"] = 0] = \"UNRESOLVED\";\n  GameEndMethod[GameEndMethod[\"RESOLVED\"] = 3] = \"RESOLVED\"; // The following options are only returned in version 2.0.0 onwards\n\n  GameEndMethod[GameEndMethod[\"TIME\"] = 1] = \"TIME\";\n  GameEndMethod[GameEndMethod[\"GAME\"] = 2] = \"GAME\";\n  GameEndMethod[GameEndMethod[\"NO_CONTEST\"] = 7] = \"NO_CONTEST\";\n})(exports.GameEndMethod || (exports.GameEndMethod = {}));\nexports.Frames = void 0;\n(function (Frames) {\n  Frames[Frames[\"FIRST\"] = -123] = \"FIRST\";\n  Frames[Frames[\"FIRST_PLAYABLE\"] = -39] = \"FIRST_PLAYABLE\";\n})(exports.Frames || (exports.Frames = {}));\nvar JoystickRegion;\n(function (JoystickRegion) {\n  JoystickRegion[JoystickRegion[\"DZ\"] = 0] = \"DZ\";\n  JoystickRegion[JoystickRegion[\"NE\"] = 1] = \"NE\";\n  JoystickRegion[JoystickRegion[\"SE\"] = 2] = \"SE\";\n  JoystickRegion[JoystickRegion[\"SW\"] = 3] = \"SW\";\n  JoystickRegion[JoystickRegion[\"NW\"] = 4] = \"NW\";\n  JoystickRegion[JoystickRegion[\"N\"] = 5] = \"N\";\n  JoystickRegion[JoystickRegion[\"E\"] = 6] = \"E\";\n  JoystickRegion[JoystickRegion[\"S\"] = 7] = \"S\";\n  JoystickRegion[JoystickRegion[\"W\"] = 8] = \"W\";\n})(JoystickRegion || (JoystickRegion = {}));\nclass InputComputer {\n  constructor() {\n    this.state = new Map();\n    this.playerPermutations = new Array();\n  }\n  setup(settings) {\n    // Reset the state\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.playerPermutations.forEach(indices => {\n      const playerState = {\n        playerIndex: indices.playerIndex,\n        opponentIndex: indices.opponentIndex,\n        inputCount: 0,\n        joystickInputCount: 0,\n        cstickInputCount: 0,\n        buttonInputCount: 0,\n        triggerInputCount: 0\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n  processFrame(frame, allFrames) {\n    this.playerPermutations.forEach(indices => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleInputCompute(allFrames, state, indices, frame);\n      }\n    });\n  }\n  fetch() {\n    return Array.from(this.state.values());\n  }\n}\nfunction handleInputCompute(frames, state, indices, frame) {\n  const playerFrame = frame.players[indices.playerIndex].pre;\n  const currentFrameNumber = playerFrame.frame;\n  const prevFrameNumber = currentFrameNumber - 1;\n  const prevPlayerFrame = frames[prevFrameNumber] ? frames[prevFrameNumber].players[indices.playerIndex].pre : null;\n  if (currentFrameNumber < exports.Frames.FIRST_PLAYABLE || !prevPlayerFrame) {\n    // Don't count inputs until the game actually starts\n    return;\n  } // First count the number of buttons that go from 0 to 1\n  // Increment action count by amount of button presses\n\n  const invertedPreviousButtons = ~prevPlayerFrame.physicalButtons;\n  const currentButtons = playerFrame.physicalButtons;\n  const buttonChanges = invertedPreviousButtons & currentButtons & 0xfff;\n  const newInputsPressed = countSetBits(buttonChanges);\n  state.inputCount += newInputsPressed;\n  state.buttonInputCount += newInputsPressed; // Increment action count when sticks change from one region to another.\n  // Don't increment when stick returns to deadzone\n\n  const prevAnalogRegion = getJoystickRegion(prevPlayerFrame.joystickX, prevPlayerFrame.joystickY);\n  const currentAnalogRegion = getJoystickRegion(playerFrame.joystickX, playerFrame.joystickY);\n  if (prevAnalogRegion !== currentAnalogRegion && currentAnalogRegion !== JoystickRegion.DZ) {\n    state.inputCount += 1;\n    state.joystickInputCount += 1;\n  } // Do the same for c-stick\n\n  const prevCstickRegion = getJoystickRegion(prevPlayerFrame.cStickX, prevPlayerFrame.cStickY);\n  const currentCstickRegion = getJoystickRegion(playerFrame.cStickX, playerFrame.cStickY);\n  if (prevCstickRegion !== currentCstickRegion && currentCstickRegion !== JoystickRegion.DZ) {\n    state.inputCount += 1;\n    state.cstickInputCount += 1;\n  } // Increment action on analog trigger... I'm not sure when. This needs revision\n  // Currently will update input count when the button gets pressed past 0.3\n  // Changes from hard shield to light shield should probably count as inputs but\n  // are not counted here\n\n  if (prevPlayerFrame.physicalLTrigger < 0.3 && playerFrame.physicalLTrigger >= 0.3) {\n    state.inputCount += 1;\n    state.triggerInputCount += 1;\n  }\n  if (prevPlayerFrame.physicalRTrigger < 0.3 && playerFrame.physicalRTrigger >= 0.3) {\n    state.inputCount += 1;\n    state.triggerInputCount += 1;\n  }\n}\nfunction countSetBits(x) {\n  // This function solves the Hamming Weight problem. Effectively it counts the number of\n  // bits in the input that are set to 1\n  // This implementation is supposedly very efficient when most bits are zero.\n  // Found: https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation\n  let bits = x;\n  let count;\n  for (count = 0; bits; count += 1) {\n    bits &= bits - 1;\n  }\n  return count;\n}\nfunction getJoystickRegion(x, y) {\n  let region = JoystickRegion.DZ;\n  if (x >= 0.2875 && y >= 0.2875) {\n    region = JoystickRegion.NE;\n  } else if (x >= 0.2875 && y <= -0.2875) {\n    region = JoystickRegion.SE;\n  } else if (x <= -0.2875 && y <= -0.2875) {\n    region = JoystickRegion.SW;\n  } else if (x <= -0.2875 && y >= 0.2875) {\n    region = JoystickRegion.NW;\n  } else if (y >= 0.2875) {\n    region = JoystickRegion.N;\n  } else if (x >= 0.2875) {\n    region = JoystickRegion.E;\n  } else if (y <= -0.2875) {\n    region = JoystickRegion.S;\n  } else if (x <= -0.2875) {\n    region = JoystickRegion.W;\n  }\n  return region;\n}\nfunction generateOverallStats({\n  settings,\n  inputs,\n  conversions,\n  playableFrameCount\n}) {\n  const inputsByPlayer = lodash.keyBy(inputs, \"playerIndex\");\n  const originalConversions = conversions;\n  const conversionsByPlayer = lodash.groupBy(conversions, conv => {\n    var _conv$moves$;\n    return (_conv$moves$ = conv.moves[0]) == null ? void 0 : _conv$moves$.playerIndex;\n  });\n  const conversionsByPlayerByOpening = lodash.mapValues(conversionsByPlayer, conversions => lodash.groupBy(conversions, \"openingType\"));\n  const gameMinutes = playableFrameCount / 3600;\n  const overall = settings.players.map(player => {\n    const playerIndex = player.playerIndex;\n    const playerInputs = lodash.get(inputsByPlayer, playerIndex) || {};\n    const inputCounts = {\n      buttons: lodash.get(playerInputs, \"buttonInputCount\"),\n      triggers: lodash.get(playerInputs, \"triggerInputCount\"),\n      cstick: lodash.get(playerInputs, \"cstickInputCount\"),\n      joystick: lodash.get(playerInputs, \"joystickInputCount\"),\n      total: lodash.get(playerInputs, \"inputCount\")\n    }; // const conversions = get(conversionsByPlayer, playerIndex) || [];\n    // const successfulConversions = conversions.filter((conversion) => conversion.moves.length > 1);\n\n    let conversionCount = 0;\n    let successfulConversionCount = 0;\n    const opponentIndices = settings.players.filter(opp => {\n      // We want players which aren't ourselves\n      if (opp.playerIndex === playerIndex) {\n        return false;\n      } // Make sure they're not on our team either\n\n      return !settings.isTeams || opp.teamId !== player.teamId;\n    }).map(opp => opp.playerIndex);\n    let totalDamage = 0;\n    let killCount = 0; // These are the conversions that we did on our opponents\n\n    originalConversions // Filter down to conversions of our opponent\n    .filter(conversion => conversion.playerIndex !== playerIndex).forEach(conversion => {\n      conversionCount++; // We killed the opponent\n\n      if (conversion.didKill && conversion.lastHitBy === playerIndex) {\n        killCount += 1;\n      }\n      if (conversion.moves.length > 1 && conversion.moves[0].playerIndex === playerIndex) {\n        successfulConversionCount++;\n      }\n      conversion.moves.forEach(move => {\n        if (move.playerIndex === playerIndex) {\n          totalDamage += move.damage;\n        }\n      });\n    });\n    return {\n      playerIndex: playerIndex,\n      inputCounts: inputCounts,\n      conversionCount: conversionCount,\n      totalDamage: totalDamage,\n      killCount: killCount,\n      successfulConversions: getRatio(successfulConversionCount, conversionCount),\n      inputsPerMinute: getRatio(inputCounts.total, gameMinutes),\n      digitalInputsPerMinute: getRatio(inputCounts.buttons, gameMinutes),\n      openingsPerKill: getRatio(conversionCount, killCount),\n      damagePerOpening: getRatio(totalDamage, conversionCount),\n      neutralWinRatio: getOpeningRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices, \"neutral-win\"),\n      counterHitRatio: getOpeningRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices, \"counter-attack\"),\n      beneficialTradeRatio: getBeneficialTradeRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices)\n    };\n  });\n  return overall;\n}\nfunction getRatio(count, total) {\n  return {\n    count: count,\n    total: total,\n    ratio: total ? count / total : null\n  };\n}\nfunction getOpeningRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices, type) {\n  const openings = lodash.get(conversionsByPlayerByOpening, [playerIndex, type]) || [];\n  const opponentOpenings = lodash.flatten(opponentIndices.map(opponentIndex => lodash.get(conversionsByPlayerByOpening, [opponentIndex, type]) || []));\n  return getRatio(openings.length, openings.length + opponentOpenings.length);\n}\nfunction getBeneficialTradeRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices) {\n  const playerTrades = lodash.get(conversionsByPlayerByOpening, [playerIndex, \"trade\"]) || [];\n  const opponentTrades = lodash.flatten(opponentIndices.map(opponentIndex => lodash.get(conversionsByPlayerByOpening, [opponentIndex, \"trade\"]) || []));\n  const benefitsPlayer = []; // Figure out which punishes benefited this player\n\n  const zippedTrades = lodash.zip(playerTrades, opponentTrades);\n  zippedTrades.forEach(conversionPair => {\n    const playerConversion = lodash.first(conversionPair);\n    const opponentConversion = lodash.last(conversionPair);\n    if (playerConversion && opponentConversion) {\n      const playerDamage = playerConversion.currentPercent - playerConversion.startPercent;\n      const opponentDamage = opponentConversion.currentPercent - opponentConversion.startPercent;\n      if (playerConversion.didKill && !opponentConversion.didKill) {\n        benefitsPlayer.push(playerConversion);\n      } else if (playerDamage > opponentDamage) {\n        benefitsPlayer.push(playerConversion);\n      }\n    }\n  });\n  return getRatio(benefitsPlayer.length, playerTrades.length);\n}\nconst defaultOptions = {\n  processOnTheFly: false\n};\nclass Stats {\n  constructor(options) {\n    this.options = void 0;\n    this.lastProcessedFrame = null;\n    this.frames = {};\n    this.players = [];\n    this.allComputers = new Array();\n    this.options = Object.assign({}, defaultOptions, options);\n  }\n  /**\r\n   * Should reset the frames to their default values.\r\n   */\n\n  setup(settings) {\n    // Reset the frames since it's a new game\n    this.frames = {};\n    this.players = settings.players.map(v => v.playerIndex); // Forward the settings on to the individual stat computer\n\n    this.allComputers.forEach(comp => comp.setup(settings));\n  }\n  register(...computer) {\n    this.allComputers.push(...computer);\n  }\n  process() {\n    if (this.players.length === 0) {\n      return;\n    }\n    let i = this.lastProcessedFrame !== null ? this.lastProcessedFrame + 1 : exports.Frames.FIRST;\n    while (this.frames[i]) {\n      const frame = this.frames[i]; // Don't attempt to compute stats on frames that have not been fully received\n\n      if (!isCompletedFrame(this.players, frame)) {\n        return;\n      }\n      this.allComputers.forEach(comp => comp.processFrame(frame, this.frames));\n      this.lastProcessedFrame = i;\n      i++;\n    }\n  }\n  addFrame(frame) {\n    this.frames[frame.frame] = frame;\n    if (this.options.processOnTheFly) {\n      this.process();\n    }\n  }\n}\nfunction isCompletedFrame(players, frame) {\n  if (!frame) {\n    return false;\n  } // This function checks whether we have successfully received an entire frame.\n  // It is not perfect because it does not wait for follower frames. Fortunately,\n  // follower frames are not used for any stat calculations so this doesn't matter\n  // for our purposes.\n\n  for (const player of players) {\n    const playerPostFrame = lodash.get(frame, [\"players\", player, \"post\"]);\n    if (!playerPostFrame) {\n      return false;\n    }\n  }\n  return true;\n}\nclass StockComputer {\n  constructor() {\n    this.state = new Map();\n    this.playerPermutations = new Array();\n    this.stocks = new Array();\n  }\n  setup(settings) {\n    // Reset state\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.stocks = [];\n    this.playerPermutations.forEach(indices => {\n      const playerState = {\n        stock: null\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n  processFrame(frame, allFrames) {\n    this.playerPermutations.forEach(indices => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleStockCompute(allFrames, state, indices, frame, this.stocks);\n      }\n    });\n  }\n  fetch() {\n    return this.stocks;\n  }\n}\nfunction handleStockCompute(frames, state, indices, frame, stocks) {\n  const playerFrame = frame.players[indices.playerIndex].post;\n  const currentFrameNumber = playerFrame.frame;\n  const prevFrameNumber = currentFrameNumber - 1;\n  const prevPlayerFrame = frames[prevFrameNumber] ? frames[prevFrameNumber].players[indices.playerIndex].post : null; // If there is currently no active stock, wait until the player is no longer spawning.\n  // Once the player is no longer spawning, start the stock\n\n  if (!state.stock) {\n    const isPlayerDead = isDead(playerFrame.actionStateId);\n    if (isPlayerDead) {\n      return;\n    }\n    state.stock = {\n      playerIndex: indices.playerIndex,\n      startFrame: currentFrameNumber,\n      endFrame: null,\n      startPercent: 0,\n      endPercent: null,\n      currentPercent: 0,\n      count: playerFrame.stocksRemaining,\n      deathAnimation: null\n    };\n    stocks.push(state.stock);\n  } else if (prevPlayerFrame && didLoseStock(playerFrame, prevPlayerFrame)) {\n    var _prevPlayerFrame$perc;\n    state.stock.endFrame = playerFrame.frame;\n    state.stock.endPercent = (_prevPlayerFrame$perc = prevPlayerFrame.percent) != null ? _prevPlayerFrame$perc : 0;\n    state.stock.deathAnimation = playerFrame.actionStateId;\n    state.stock = null;\n  } else {\n    var _playerFrame$percent;\n    state.stock.currentPercent = (_playerFrame$percent = playerFrame.percent) != null ? _playerFrame$percent : 0;\n  }\n}\n\n// Based on https://github.com/wilsonzlin/edgesearch/blob/d03816dd4b18d3d2eb6d08cb1ae14f96f046141d/demo/wiki/client/src/util/util.ts\n// Ensures value is not null or undefined.\n// != does no type validation so we don't need to explcitly check for undefined.\nfunction exists(value) {\n  return value != null;\n}\nconst TARGET_ITEM_TYPE_ID = 209;\nclass TargetBreakComputer {\n  constructor() {\n    this.targetBreaks = new Array();\n    this.isTargetTestGame = false;\n  }\n  setup(settings) {\n    // Reset the state\n    this.targetBreaks = [];\n    this.isTargetTestGame = settings.gameMode === exports.GameMode.TARGET_TEST;\n  }\n  processFrame(frame, allFrames) {\n    if (!this.isTargetTestGame) {\n      return;\n    }\n    handleTargetBreak(allFrames, frame, this.targetBreaks);\n  }\n  fetch() {\n    return this.targetBreaks;\n  }\n}\nfunction handleTargetBreak(frames, frame, targetBreaks) {\n  var _frames$currentFrameN, _frames$currentFrameN2, _frames$currentFrameN3, _frames$prevFrameNumb, _frames$prevFrameNumb2, _frames$prevFrameNumb3;\n  const currentFrameNumber = frame.frame;\n  const prevFrameNumber = currentFrameNumber - 1; // Add all targets on the first frame\n\n  if (currentFrameNumber === exports.Frames.FIRST) {\n    var _frames$Frames$FIRST$, _frames$Frames$FIRST, _frames$Frames$FIRST$2;\n    const targets = (_frames$Frames$FIRST$ = (_frames$Frames$FIRST = frames[exports.Frames.FIRST]) == null ? void 0 : (_frames$Frames$FIRST$2 = _frames$Frames$FIRST.items) == null ? void 0 : _frames$Frames$FIRST$2.filter(item => item.typeId === TARGET_ITEM_TYPE_ID)) != null ? _frames$Frames$FIRST$ : [];\n    targets.forEach(target => {\n      targetBreaks.push({\n        spawnId: target.spawnId,\n        frameDestroyed: null,\n        positionX: target.positionX,\n        positionY: target.positionY\n      });\n    });\n  }\n  const currentTargets = (_frames$currentFrameN = (_frames$currentFrameN2 = frames[currentFrameNumber]) == null ? void 0 : (_frames$currentFrameN3 = _frames$currentFrameN2.items) == null ? void 0 : _frames$currentFrameN3.filter(item => item.typeId === TARGET_ITEM_TYPE_ID)) != null ? _frames$currentFrameN : [];\n  const previousTargets = (_frames$prevFrameNumb = (_frames$prevFrameNumb2 = frames[prevFrameNumber]) == null ? void 0 : (_frames$prevFrameNumb3 = _frames$prevFrameNumb2.items) == null ? void 0 : _frames$prevFrameNumb3.filter(item => item.typeId === TARGET_ITEM_TYPE_ID)) != null ? _frames$prevFrameNumb : [];\n  const currentTargetIds = currentTargets.map(item => item.spawnId).filter(exists);\n  const previousTargetIds = previousTargets.map(item => item.spawnId).filter(exists); // Check if any targets were destroyed\n\n  const brokenTargetIds = previousTargetIds.filter(id => !currentTargetIds.includes(id));\n  brokenTargetIds.forEach(id => {\n    // Update the target break\n    const targetBreak = targetBreaks.find(targetBreak => targetBreak.spawnId === id);\n    if (targetBreak) {\n      targetBreak.frameDestroyed = currentFrameNumber;\n    }\n  });\n}\nfunction frameToGameTimer(frame, options) {\n  const {\n    timerType,\n    startingTimerSeconds\n  } = options;\n  if (timerType === exports.TimerType.DECREASING) {\n    if (!exists(startingTimerSeconds)) {\n      return \"Unknown\";\n    }\n    const centiseconds = Math.ceil((60 - frame % 60) % 60 * 99 / 59);\n    const date = new Date(0, 0, 0, 0, 0, startingTimerSeconds - frame / 60, centiseconds * 10);\n    return dateFns.format(date, \"mm:ss.SS\");\n  }\n  if (timerType === exports.TimerType.INCREASING) {\n    const centiseconds = Math.floor(frame % 60 * 99 / 59);\n    const date = new Date(0, 0, 0, 0, 0, frame / 60, centiseconds * 10);\n    return dateFns.format(date, \"mm:ss.SS\");\n  }\n  return \"Infinite\";\n}\nexports.CommunicationType = void 0;\n(function (CommunicationType) {\n  CommunicationType[CommunicationType[\"HANDSHAKE\"] = 1] = \"HANDSHAKE\";\n  CommunicationType[CommunicationType[\"REPLAY\"] = 2] = \"REPLAY\";\n  CommunicationType[CommunicationType[\"KEEP_ALIVE\"] = 3] = \"KEEP_ALIVE\";\n})(exports.CommunicationType || (exports.CommunicationType = {})); // This class is responsible for handling the communication protocol between the Wii and the\n// desktop app\n\nclass ConsoleCommunication {\n  constructor() {\n    this.receiveBuf = Buffer.from([]);\n    this.messages = new Array();\n  }\n  receive(data) {\n    this.receiveBuf = Buffer.concat([this.receiveBuf, data]);\n    while (this.receiveBuf.length >= 4) {\n      // First get the size of the message we are expecting\n      const msgSize = this.receiveBuf.readUInt32BE(0);\n      if (this.receiveBuf.length < msgSize + 4) {\n        // If we haven't received all the data yet, let's wait for more\n        return;\n      } // Here we have received all the data, so let's decode it\n\n      const ubjsonData = this.receiveBuf.slice(4, msgSize + 4);\n      this.messages.push(ubjson.decode(ubjsonData)); // Remove the processed data from receiveBuf\n\n      this.receiveBuf = this.receiveBuf.slice(msgSize + 4);\n    }\n  }\n  getReceiveBuffer() {\n    return this.receiveBuf;\n  }\n  getMessages() {\n    const toReturn = this.messages;\n    this.messages = [];\n    return toReturn;\n  }\n  genHandshakeOut(cursor, clientToken, isRealtime = false) {\n    const clientTokenBuf = Buffer.from([0, 0, 0, 0]);\n    clientTokenBuf.writeUInt32BE(clientToken, 0);\n    const message = {\n      type: exports.CommunicationType.HANDSHAKE,\n      payload: {\n        cursor: cursor,\n        clientToken: Uint8Array.from(clientTokenBuf),\n        isRealtime: isRealtime\n      }\n    };\n    const buf = ubjson.encode(message, {\n      optimizeArrays: true\n    });\n    const msg = Buffer.concat([Buffer.from([0, 0, 0, 0]), Buffer.from(buf)]);\n    msg.writeUInt32BE(buf.byteLength, 0);\n    return msg;\n  }\n}\nexports.ConnectionEvent = void 0;\n(function (ConnectionEvent) {\n  ConnectionEvent[\"CONNECT\"] = \"connect\";\n  ConnectionEvent[\"MESSAGE\"] = \"message\";\n  ConnectionEvent[\"HANDSHAKE\"] = \"handshake\";\n  ConnectionEvent[\"STATUS_CHANGE\"] = \"statusChange\";\n  ConnectionEvent[\"DATA\"] = \"data\";\n  ConnectionEvent[\"ERROR\"] = \"error\";\n})(exports.ConnectionEvent || (exports.ConnectionEvent = {}));\nexports.ConnectionStatus = void 0;\n(function (ConnectionStatus) {\n  ConnectionStatus[ConnectionStatus[\"DISCONNECTED\"] = 0] = \"DISCONNECTED\";\n  ConnectionStatus[ConnectionStatus[\"CONNECTING\"] = 1] = \"CONNECTING\";\n  ConnectionStatus[ConnectionStatus[\"CONNECTED\"] = 2] = \"CONNECTED\";\n  ConnectionStatus[ConnectionStatus[\"RECONNECT_WAIT\"] = 3] = \"RECONNECT_WAIT\";\n})(exports.ConnectionStatus || (exports.ConnectionStatus = {}));\nexports.Ports = void 0;\n(function (Ports) {\n  Ports[Ports[\"DEFAULT\"] = 51441] = \"DEFAULT\";\n  Ports[Ports[\"LEGACY\"] = 666] = \"LEGACY\";\n  Ports[Ports[\"RELAY_START\"] = 53741] = \"RELAY_START\";\n})(exports.Ports || (exports.Ports = {}));\nconst NETWORK_MESSAGE = \"HELO\\0\";\nconst DEFAULT_CONNECTION_TIMEOUT_MS = 20000;\nvar CommunicationState;\n(function (CommunicationState) {\n  CommunicationState[\"INITIAL\"] = \"initial\";\n  CommunicationState[\"LEGACY\"] = \"legacy\";\n  CommunicationState[\"NORMAL\"] = \"normal\";\n})(CommunicationState || (CommunicationState = {}));\nconst defaultConnectionDetails = {\n  consoleNick: \"unknown\",\n  gameDataCursor: /*#__PURE__*/Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0]),\n  version: \"\",\n  clientToken: 0\n};\nconst consoleConnectionOptions = {\n  autoReconnect: true\n};\n/**\r\n * Responsible for maintaining connection to a Slippi relay connection or Wii connection.\r\n * Events are emitted whenever data is received.\r\n *\r\n * Basic usage example:\r\n *\r\n * ```javascript\r\n * const { ConsoleConnection } = require(\"@slippi/slippi-js\");\r\n *\r\n * const connection = new ConsoleConnection();\r\n * connection.connect(\"localhost\", 667); // You should set these values appropriately\r\n *\r\n * connection.on(\"data\", (data) => {\r\n *   // Received data from console\r\n *   console.log(data);\r\n * });\r\n *\r\n * connection.on(\"statusChange\", (status) => {\r\n *   console.log(`status changed: ${status}`);\r\n * });\r\n * ```\r\n */\n\nclass ConsoleConnection extends events.EventEmitter {\n  constructor(options) {\n    super();\n    this.ipAddress = void 0;\n    this.port = void 0;\n    this.isRealtime = void 0;\n    this.connectionStatus = exports.ConnectionStatus.DISCONNECTED;\n    this.connDetails = {\n      ...defaultConnectionDetails\n    };\n    this.client = null;\n    this.connection = null;\n    this.options = void 0;\n    this.shouldReconnect = false;\n    this.ipAddress = \"0.0.0.0\";\n    this.port = exports.Ports.DEFAULT;\n    this.isRealtime = false;\n    this.options = Object.assign({}, consoleConnectionOptions, options);\n  }\n  /**\r\n   * @returns The current connection status.\r\n   */\n\n  getStatus() {\n    return this.connectionStatus;\n  }\n  /**\r\n   * @returns The IP address and port of the current connection.\r\n   */\n\n  getSettings() {\n    return {\n      ipAddress: this.ipAddress,\n      port: this.port\n    };\n  }\n  /**\r\n   * @returns The specific details about the connected console.\r\n   */\n\n  getDetails() {\n    return {\n      ...this.connDetails\n    };\n  }\n  /**\r\n   * Initiate a connection to the Wii or Slippi relay.\r\n   * @param ip   The IP address of the Wii or Slippi relay.\r\n   * @param port The port to connect to.\r\n   * @param isRealtime Optional. A flag to tell the Wii to send data as quickly as possible\r\n   * @param timeout Optional. The timeout in milliseconds when attempting to connect\r\n   *                to the Wii or relay.\r\n   */\n\n  connect(ip, port, isRealtime = false, timeout = DEFAULT_CONNECTION_TIMEOUT_MS) {\n    this.ipAddress = ip;\n    this.port = port;\n    this.isRealtime = isRealtime;\n    this._connectOnPort(ip, port, timeout);\n  }\n  _connectOnPort(ip, port, timeout) {\n    // set up reconnect\n    const reconnect = inject__default[\"default\"](() => net__default[\"default\"].connect({\n      host: ip,\n      port: port,\n      timeout: timeout\n    })); // Indicate we are connecting\n\n    this._setStatus(exports.ConnectionStatus.CONNECTING); // Prepare console communication obj for talking UBJSON\n\n    const consoleComms = new ConsoleCommunication(); // TODO: reconnect on failed reconnect, not sure how\n    // TODO: to do this\n\n    const connection = reconnect({\n      initialDelay: 2000,\n      maxDelay: 10000,\n      strategy: \"fibonacci\",\n      failAfter: Infinity\n    }, client => {\n      var _this$connDetails$cli;\n      this.emit(exports.ConnectionEvent.CONNECT); // We successfully connected so turn on auto-reconnect\n\n      this.shouldReconnect = this.options.autoReconnect;\n      this.client = client;\n      let commState = CommunicationState.INITIAL;\n      client.on(\"data\", data => {\n        if (commState === CommunicationState.INITIAL) {\n          commState = this._getInitialCommState(data);\n          console.log(`Connected to ${ip}:${port} with type: ${commState}`);\n          this._setStatus(exports.ConnectionStatus.CONNECTED);\n          console.log(data.toString(\"hex\"));\n        }\n        if (commState === CommunicationState.LEGACY) {\n          // If the first message received was not a handshake message, either we\n          // connected to an old Nintendont version or a relay instance\n          this._handleReplayData(data);\n          return;\n        }\n        try {\n          consoleComms.receive(data);\n        } catch (err) {\n          console.error(\"Failed to process new data from server...\", {\n            error: err,\n            prevDataBuf: consoleComms.getReceiveBuffer(),\n            rcvData: data\n          });\n          client.destroy();\n          this.emit(exports.ConnectionEvent.ERROR, err);\n          return;\n        }\n        const messages = consoleComms.getMessages(); // Process all of the received messages\n\n        try {\n          messages.forEach(message => this._processMessage(message));\n        } catch (err) {\n          // Disconnect client to send another handshake message\n          console.error(err);\n          client.destroy();\n          this.emit(exports.ConnectionEvent.ERROR, err);\n        }\n      });\n      client.on(\"timeout\", () => {\n        // const previouslyConnected = this.connectionStatus === ConnectionStatus.CONNECTED;\n        console.warn(`Attempted connection to ${ip}:${port} timed out after ${timeout}ms`);\n        client.destroy();\n      });\n      client.on(\"end\", () => {\n        console.log(\"disconnect\");\n        if (!this.shouldReconnect) {\n          client.destroy();\n        }\n      });\n      client.on(\"close\", () => {\n        console.log(\"connection was closed\");\n      });\n      const handshakeMsgOut = consoleComms.genHandshakeOut(this.connDetails.gameDataCursor, (_this$connDetails$cli = this.connDetails.clientToken) != null ? _this$connDetails$cli : 0, this.isRealtime);\n      client.write(handshakeMsgOut);\n    });\n    const setConnectingStatus = () => {\n      // Indicate we are connecting\n      this._setStatus(this.shouldReconnect ? exports.ConnectionStatus.RECONNECT_WAIT : exports.ConnectionStatus.CONNECTING);\n    };\n    connection.on(\"connect\", setConnectingStatus);\n    connection.on(\"reconnect\", setConnectingStatus);\n    connection.on(\"disconnect\", () => {\n      if (!this.shouldReconnect) {\n        connection.reconnect = false;\n        connection.disconnect();\n        this._setStatus(exports.ConnectionStatus.DISCONNECTED);\n      } // TODO: Figure out how to set RECONNECT_WAIT state here. Currently it will stay on\n      // TODO: Connecting... forever\n    });\n\n    connection.on(\"error\", err => {\n      console.warn(`Connection on port ${port} encountered an error.`, err);\n      this._setStatus(exports.ConnectionStatus.DISCONNECTED);\n      this.emit(exports.ConnectionEvent.ERROR, `Connection on port ${port} encountered an error.\\n${err}`);\n    });\n    this.connection = connection;\n    connection.connect(port);\n  }\n  /**\r\n   * Terminate the current connection.\r\n   */\n\n  disconnect() {\n    // Prevent reconnections and disconnect\n    if (this.connection) {\n      this.connection.reconnect = false;\n      this.connection.disconnect();\n      this.connection = null;\n    }\n    if (this.client) {\n      this.client.destroy();\n    }\n  }\n  _getInitialCommState(data) {\n    if (data.length < 13) {\n      return CommunicationState.LEGACY;\n    }\n    const openingBytes = Buffer.from([0x7b, 0x69, 0x04, 0x74, 0x79, 0x70, 0x65, 0x55, 0x01]);\n    const dataStart = data.slice(4, 13);\n    return dataStart.equals(openingBytes) ? CommunicationState.NORMAL : CommunicationState.LEGACY;\n  }\n  _processMessage(message) {\n    this.emit(exports.ConnectionEvent.MESSAGE, message);\n    switch (message.type) {\n      case exports.CommunicationType.KEEP_ALIVE:\n        // console.log(\"Keep alive message received\");\n        // TODO: This is the jankiest shit ever but it will allow for relay connections not\n        // TODO: to time out as long as the main connection is still receving keep alive messages\n        // TODO: Need to figure out a better solution for this. There should be no need to have an\n        // TODO: active Wii connection for the relay connection to keep itself alive\n        const fakeKeepAlive = Buffer.from(NETWORK_MESSAGE);\n        this._handleReplayData(fakeKeepAlive);\n        break;\n      case exports.CommunicationType.REPLAY:\n        const readPos = Uint8Array.from(message.payload.pos);\n        const cmp = Buffer.compare(this.connDetails.gameDataCursor, readPos);\n        if (!message.payload.forcePos && cmp !== 0) {\n          // The readPos is not the one we are waiting on, throw error\n          throw new Error(`Position of received data is incorrect. Expected: ${this.connDetails.gameDataCursor.toString()}, Received: ${readPos.toString()}`);\n        }\n        if (message.payload.forcePos) {\n          console.warn(\"Overflow occured in Nintendont, data has likely been skipped and replay corrupted. \" + \"Expected, Received:\", this.connDetails.gameDataCursor, readPos);\n        }\n        this.connDetails.gameDataCursor = Uint8Array.from(message.payload.nextPos);\n        const data = Uint8Array.from(message.payload.data);\n        this._handleReplayData(data);\n        break;\n      case exports.CommunicationType.HANDSHAKE:\n        const {\n          nick,\n          nintendontVersion\n        } = message.payload;\n        if (nick) {\n          this.connDetails.consoleNick = nick;\n        }\n        const tokenBuf = Buffer.from(message.payload.clientToken);\n        this.connDetails.clientToken = tokenBuf.readUInt32BE(0);\n        if (nintendontVersion) {\n          this.connDetails.version = nintendontVersion;\n        }\n        this.connDetails.gameDataCursor = Uint8Array.from(message.payload.pos);\n        this.emit(exports.ConnectionEvent.HANDSHAKE, this.connDetails);\n        break;\n    }\n  }\n  _handleReplayData(data) {\n    this.emit(exports.ConnectionEvent.DATA, data);\n  }\n  _setStatus(status) {\n    // Don't fire the event if the status hasn't actually changed\n    if (this.connectionStatus !== status) {\n      this.connectionStatus = status;\n      this.emit(exports.ConnectionEvent.STATUS_CHANGE, this.connectionStatus);\n    }\n  }\n}\nconst MAX_PEERS = 32;\nexports.DolphinMessageType = void 0;\n(function (DolphinMessageType) {\n  DolphinMessageType[\"CONNECT_REPLY\"] = \"connect_reply\";\n  DolphinMessageType[\"GAME_EVENT\"] = \"game_event\";\n  DolphinMessageType[\"START_GAME\"] = \"start_game\";\n  DolphinMessageType[\"END_GAME\"] = \"end_game\";\n})(exports.DolphinMessageType || (exports.DolphinMessageType = {}));\nclass DolphinConnection extends events.EventEmitter {\n  constructor() {\n    super();\n    this.ipAddress = void 0;\n    this.port = void 0;\n    this.connectionStatus = exports.ConnectionStatus.DISCONNECTED;\n    this.gameCursor = 0;\n    this.nickname = \"unknown\";\n    this.version = \"\";\n    this.peer = null;\n    this.ipAddress = \"0.0.0.0\";\n    this.port = exports.Ports.DEFAULT;\n  }\n  /**\r\n   * @returns The current connection status.\r\n   */\n\n  getStatus() {\n    return this.connectionStatus;\n  }\n  /**\r\n   * @returns The IP address and port of the current connection.\r\n   */\n\n  getSettings() {\n    return {\n      ipAddress: this.ipAddress,\n      port: this.port\n    };\n  }\n  getDetails() {\n    return {\n      consoleNick: this.nickname,\n      gameDataCursor: this.gameCursor,\n      version: this.version\n    };\n  }\n  connect(ip, port) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      console.log(`Connecting to: ${ip}:${port}`);\n      _this.ipAddress = ip;\n      _this.port = port;\n      const enet = yield Promise.resolve().then(function () {\n        return /*#__PURE__*/_interopNamespace(require('enet'));\n      }); // Create the enet client\n\n      const client = enet.createClient({\n        peers: MAX_PEERS,\n        channels: 3,\n        down: 0,\n        up: 0\n      }, err => {\n        if (err) {\n          console.error(err);\n          return;\n        }\n      });\n      _this.peer = client.connect({\n        address: _this.ipAddress,\n        port: _this.port\n      }, 3, 1337,\n      // Data to send, not sure what this is or what this represents\n      (err, newPeer) => {\n        if (err) {\n          console.error(err);\n          return;\n        }\n        newPeer.ping();\n        _this.emit(exports.ConnectionEvent.CONNECT);\n        _this._setStatus(exports.ConnectionStatus.CONNECTED);\n      });\n      _this.peer.on(\"connect\", () => {\n        // Reset the game cursor to the beginning of the game. Do we need to do this or\n        // should it just continue from where it left off?\n        _this.gameCursor = 0;\n        const request = {\n          type: \"connect_request\",\n          cursor: _this.gameCursor\n        };\n        const packet = new enet.Packet(JSON.stringify(request), enet.PACKET_FLAG.RELIABLE);\n        _this.peer.send(0, packet);\n      });\n      _this.peer.on(\"message\", packet => {\n        const data = packet.data();\n        if (data.length === 0) {\n          return;\n        }\n        const dataString = data.toString(\"ascii\");\n        const message = JSON.parse(dataString);\n        const {\n          dolphin_closed\n        } = message;\n        if (dolphin_closed) {\n          // We got a disconnection request\n          _this.disconnect();\n          return;\n        }\n        _this.emit(exports.ConnectionEvent.MESSAGE, message);\n        switch (message.type) {\n          case exports.DolphinMessageType.CONNECT_REPLY:\n            _this.connectionStatus = exports.ConnectionStatus.CONNECTED;\n            _this.gameCursor = message.cursor;\n            _this.nickname = message.nick;\n            _this.version = message.version;\n            _this.emit(exports.ConnectionEvent.HANDSHAKE, _this.getDetails());\n            break;\n          case exports.DolphinMessageType.GAME_EVENT:\n            {\n              const {\n                payload\n              } = message; //TODO: remove after game start and end messages have been in stable Ishii for a bit\n\n              if (!payload) {\n                // We got a disconnection request\n                _this.disconnect();\n                return;\n              }\n              _this._updateCursor(message, dataString);\n              const gameData = Buffer.from(payload, \"base64\");\n              _this._handleReplayData(gameData);\n              break;\n            }\n          case exports.DolphinMessageType.START_GAME:\n            {\n              _this._updateCursor(message, dataString);\n              break;\n            }\n          case exports.DolphinMessageType.END_GAME:\n            {\n              _this._updateCursor(message, dataString);\n              break;\n            }\n        }\n      });\n      _this.peer.on(\"disconnect\", () => {\n        _this.disconnect();\n      });\n      _this._setStatus(exports.ConnectionStatus.CONNECTING);\n    })();\n  }\n  disconnect() {\n    if (this.peer) {\n      this.peer.disconnect();\n      this.peer = null;\n    }\n    this._setStatus(exports.ConnectionStatus.DISCONNECTED);\n  }\n  _handleReplayData(data) {\n    this.emit(exports.ConnectionEvent.DATA, data);\n  }\n  _setStatus(status) {\n    // Don't fire the event if the status hasn't actually changed\n    if (this.connectionStatus !== status) {\n      this.connectionStatus = status;\n      this.emit(exports.ConnectionEvent.STATUS_CHANGE, this.connectionStatus);\n    }\n  }\n  _updateCursor(message, dataString) {\n    const {\n      cursor,\n      next_cursor\n    } = message;\n    if (this.gameCursor !== cursor) {\n      const err = new Error(`Unexpected game data cursor. Expected: ${this.gameCursor} but got: ${cursor}. Payload: ${dataString}`);\n      console.warn(err);\n      this.emit(exports.ConnectionEvent.ERROR, err);\n    }\n    this.gameCursor = next_cursor;\n  }\n}\nfunction toHalfwidth(str) {\n  // Converts a fullwidth character to halfwidth\n  const convertChar = charCode => {\n    /**\r\n     * Standard full width encodings\r\n     * https://en.wikipedia.org/wiki/Halfwidth_and_Fullwidth_Forms_(Unicode_block)\r\n     */\n    if (charCode > 0xff00 && charCode < 0xff5f) {\n      return 0x0020 + (charCode - 0xff00);\n    } // space:\n\n    if (charCode === 0x3000) {\n      return 0x0020;\n    }\n    /**\r\n     * Exceptions found in Melee/Japanese keyboards\r\n     */\n    // single quote: '\n\n    if (charCode === 0x2019) {\n      return 0x0027;\n    } // double quote: \"\n\n    if (charCode === 0x201d) {\n      return 0x0022;\n    }\n    return charCode;\n  };\n  const ret = lodash.map(str, char => convertChar(char.charCodeAt(0)));\n  return String.fromCharCode(...ret);\n}\nexports.SlpInputSource = void 0;\n(function (SlpInputSource) {\n  SlpInputSource[\"BUFFER\"] = \"buffer\";\n  SlpInputSource[\"FILE\"] = \"file\";\n})(exports.SlpInputSource || (exports.SlpInputSource = {}));\nfunction getRef(input) {\n  switch (input.source) {\n    case exports.SlpInputSource.FILE:\n      if (!input.filePath) {\n        throw new Error(\"File source requires a file path\");\n      }\n      const fd = fs__default[\"default\"].openSync(input.filePath, \"r\");\n      return {\n        source: input.source,\n        fileDescriptor: fd\n      };\n    case exports.SlpInputSource.BUFFER:\n      return {\n        source: input.source,\n        buffer: input.buffer\n      };\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n}\nfunction readRef(ref, buffer, offset, length, position) {\n  switch (ref.source) {\n    case exports.SlpInputSource.FILE:\n      return fs__default[\"default\"].readSync(ref.fileDescriptor, buffer, offset, length, position);\n    case exports.SlpInputSource.BUFFER:\n      return ref.buffer.copy(buffer, offset, position, position + length);\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n}\nfunction getLenRef(ref) {\n  switch (ref.source) {\n    case exports.SlpInputSource.FILE:\n      const fileStats = fs__default[\"default\"].fstatSync(ref.fileDescriptor);\n      return fileStats.size;\n    case exports.SlpInputSource.BUFFER:\n      return ref.buffer.length;\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n}\n/**\r\n * Opens a file at path\r\n */\n\nfunction openSlpFile(input) {\n  const ref = getRef(input);\n  const rawDataPosition = getRawDataPosition(ref);\n  const rawDataLength = getRawDataLength(ref, rawDataPosition);\n  const metadataPosition = rawDataPosition + rawDataLength + 10; // remove metadata string\n\n  const metadataLength = getMetadataLength(ref, metadataPosition);\n  const messageSizes = getMessageSizes(ref, rawDataPosition);\n  return {\n    ref,\n    rawDataPosition,\n    rawDataLength,\n    metadataPosition,\n    metadataLength,\n    messageSizes\n  };\n}\nfunction closeSlpFile(file) {\n  switch (file.ref.source) {\n    case exports.SlpInputSource.FILE:\n      fs__default[\"default\"].closeSync(file.ref.fileDescriptor);\n      break;\n  }\n} // This function gets the position where the raw data starts\n\nfunction getRawDataPosition(ref) {\n  const buffer = new Uint8Array(1);\n  readRef(ref, buffer, 0, buffer.length, 0);\n  if (buffer[0] === 0x36) {\n    return 0;\n  }\n  if (buffer[0] !== \"{\".charCodeAt(0)) {\n    return 0; // return error?\n  }\n\n  return 15;\n}\nfunction getRawDataLength(ref, position) {\n  const fileSize = getLenRef(ref);\n  if (position === 0) {\n    return fileSize;\n  }\n  const buffer = new Uint8Array(4);\n  readRef(ref, buffer, 0, buffer.length, position - 4);\n  const rawDataLen = buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];\n  if (rawDataLen > 0) {\n    // If this method manages to read a number, it's probably trustworthy\n    return rawDataLen;\n  } // If the above does not return a valid data length,\n  // return a file size based on file length. This enables\n  // some support for severed files\n\n  return fileSize - position;\n}\nfunction getMetadataLength(ref, position) {\n  const len = getLenRef(ref);\n  return len - position - 1;\n}\nfunction getMessageSizes(ref, position) {\n  const messageSizes = {}; // Support old file format\n\n  if (position === 0) {\n    messageSizes[0x36] = 0x140;\n    messageSizes[0x37] = 0x6;\n    messageSizes[0x38] = 0x46;\n    messageSizes[0x39] = 0x1;\n    return messageSizes;\n  }\n  const buffer = new Uint8Array(2);\n  readRef(ref, buffer, 0, buffer.length, position);\n  if (buffer[0] !== exports.Command.MESSAGE_SIZES) {\n    return {};\n  }\n  const payloadLength = buffer[1];\n  messageSizes[0x35] = payloadLength;\n  const messageSizesBuffer = new Uint8Array(payloadLength - 1);\n  readRef(ref, messageSizesBuffer, 0, messageSizesBuffer.length, position + 2);\n  for (let i = 0; i < payloadLength - 1; i += 3) {\n    const command = messageSizesBuffer[i]; // Get size of command\n\n    messageSizes[command] = messageSizesBuffer[i + 1] << 8 | messageSizesBuffer[i + 2];\n  }\n  return messageSizes;\n}\nfunction getEnabledItems(view) {\n  const offsets = [0x1, 0x100, 0x10000, 0x1000000, 0x100000000];\n  const enabledItems = offsets.reduce((acc, byteOffset, index) => {\n    const byte = readUint8(view, 0x28 + index);\n    return acc + byte * byteOffset;\n  }, 0);\n  return enabledItems;\n}\nfunction getGameInfoBlock(view) {\n  const offset = 0x5;\n  return {\n    gameBitfield1: readUint8(view, 0x0 + offset),\n    gameBitfield2: readUint8(view, 0x1 + offset),\n    gameBitfield3: readUint8(view, 0x2 + offset),\n    gameBitfield4: readUint8(view, 0x3 + offset),\n    bombRainEnabled: (readUint8(view, 0x6 + offset) & 0xff) > 0 ? true : false,\n    itemSpawnBehavior: readInt8(view, 0xb + offset),\n    selfDestructScoreValue: readInt8(view, 0xc + offset),\n    //stageId: readUint16(view, 0xe + offset),\n    //gameTimer: readUint32(view, 0x10 + offset),\n    itemSpawnBitfield1: readUint8(view, 0x23 + offset),\n    itemSpawnBitfield2: readUint8(view, 0x24 + offset),\n    itemSpawnBitfield3: readUint8(view, 0x25 + offset),\n    itemSpawnBitfield4: readUint8(view, 0x26 + offset),\n    itemSpawnBitfield5: readUint8(view, 0x27 + offset),\n    damageRatio: readFloat(view, 0x30 + offset)\n  };\n}\n/**\r\n * Iterates through slp events and parses payloads\r\n */\n\nfunction iterateEvents(slpFile, callback, startPos = null) {\n  const ref = slpFile.ref;\n  let readPosition = startPos !== null && startPos > 0 ? startPos : slpFile.rawDataPosition;\n  const stopReadingAt = slpFile.rawDataPosition + slpFile.rawDataLength; // Generate read buffers for each\n\n  const commandPayloadBuffers = lodash.mapValues(slpFile.messageSizes, size => new Uint8Array(size + 1));\n  let splitMessageBuffer = new Uint8Array(0);\n  const commandByteBuffer = new Uint8Array(1);\n  while (readPosition < stopReadingAt) {\n    var _commandByteBuffer$;\n    readRef(ref, commandByteBuffer, 0, 1, readPosition);\n    let commandByte = (_commandByteBuffer$ = commandByteBuffer[0]) != null ? _commandByteBuffer$ : 0;\n    let buffer = commandPayloadBuffers[commandByte];\n    if (buffer === undefined) {\n      // If we don't have an entry for this command, return false to indicate failed read\n      return readPosition;\n    }\n    if (buffer.length > stopReadingAt - readPosition) {\n      return readPosition;\n    }\n    const advanceAmount = buffer.length;\n    readRef(ref, buffer, 0, buffer.length, readPosition);\n    if (commandByte === exports.Command.SPLIT_MESSAGE) {\n      var _readUint, _readUint2;\n\n      // Here we have a split message, we will collect data from them until the last\n      // message of the list is received\n      const view = new DataView(buffer.buffer);\n      const size = (_readUint = readUint16(view, 0x201)) != null ? _readUint : 512;\n      const isLastMessage = readBool(view, 0x204);\n      const internalCommand = (_readUint2 = readUint8(view, 0x203)) != null ? _readUint2 : 0; // If this is the first message, initialize the splitMessageBuffer\n      // with the internal command byte because our parseMessage function\n      // seems to expect a command byte at the start\n\n      if (splitMessageBuffer.length === 0) {\n        splitMessageBuffer = new Uint8Array(1);\n        splitMessageBuffer[0] = internalCommand;\n      } // Collect new data into splitMessageBuffer\n\n      const appendBuf = buffer.slice(0x1, 0x1 + size);\n      const mergedBuf = new Uint8Array(splitMessageBuffer.length + appendBuf.length);\n      mergedBuf.set(splitMessageBuffer);\n      mergedBuf.set(appendBuf, splitMessageBuffer.length);\n      splitMessageBuffer = mergedBuf;\n      if (isLastMessage) {\n        var _splitMessageBuffer$;\n        commandByte = (_splitMessageBuffer$ = splitMessageBuffer[0]) != null ? _splitMessageBuffer$ : 0;\n        buffer = splitMessageBuffer;\n        splitMessageBuffer = new Uint8Array(0);\n      }\n    }\n    const parsedPayload = parseMessage(commandByte, buffer);\n    const shouldStop = callback(commandByte, parsedPayload, buffer);\n    if (shouldStop) {\n      break;\n    }\n    readPosition += advanceAmount;\n  }\n  return readPosition;\n}\nfunction parseMessage(command, payload) {\n  const view = new DataView(payload.buffer);\n  switch (command) {\n    case exports.Command.GAME_START:\n      const getPlayerObject = playerIndex => {\n        // Controller Fix stuff\n        const cfOffset = playerIndex * 0x8;\n        const dashback = readUint32(view, 0x141 + cfOffset);\n        const shieldDrop = readUint32(view, 0x145 + cfOffset);\n        let controllerFix = \"None\";\n        if (dashback !== shieldDrop) {\n          controllerFix = \"Mixed\";\n        } else if (dashback === 1) {\n          controllerFix = \"UCF\";\n        } else if (dashback === 2) {\n          controllerFix = \"Dween\";\n        } // Nametag stuff\n\n        const nametagLength = 0x10;\n        const nametagOffset = playerIndex * nametagLength;\n        const nametagStart = 0x161 + nametagOffset;\n        const nametagBuf = payload.slice(nametagStart, nametagStart + nametagLength);\n        const nameTagString = iconv__default[\"default\"].decode(nametagBuf, \"Shift_JIS\").split(\"\\0\").shift();\n        const nametag = nameTagString ? toHalfwidth(nameTagString) : \"\"; // Display name\n\n        const displayNameLength = 0x1f;\n        const displayNameOffset = playerIndex * displayNameLength;\n        const displayNameStart = 0x1a5 + displayNameOffset;\n        const displayNameBuf = payload.slice(displayNameStart, displayNameStart + displayNameLength);\n        const displayNameString = iconv__default[\"default\"].decode(displayNameBuf, \"Shift_JIS\").split(\"\\0\").shift();\n        const displayName = displayNameString ? toHalfwidth(displayNameString) : \"\"; // Connect code\n\n        const connectCodeLength = 0xa;\n        const connectCodeOffset = playerIndex * connectCodeLength;\n        const connectCodeStart = 0x221 + connectCodeOffset;\n        const connectCodeBuf = payload.slice(connectCodeStart, connectCodeStart + connectCodeLength);\n        const connectCodeString = iconv__default[\"default\"].decode(connectCodeBuf, \"Shift_JIS\").split(\"\\0\").shift();\n        const connectCode = connectCodeString ? toHalfwidth(connectCodeString) : \"\";\n        const userIdLength = 0x1d;\n        const userIdOffset = playerIndex * userIdLength;\n        const userIdStart = 0x249 + userIdOffset;\n        const userIdBuf = payload.slice(userIdStart, userIdStart + userIdLength);\n        const userIdString = iconv__default[\"default\"].decode(userIdBuf, \"utf8\").split(\"\\0\").shift();\n        const userId = userIdString != null ? userIdString : \"\";\n        const offset = playerIndex * 0x24;\n        return {\n          playerIndex,\n          port: playerIndex + 1,\n          characterId: readUint8(view, 0x65 + offset),\n          type: readUint8(view, 0x66 + offset),\n          startStocks: readUint8(view, 0x67 + offset),\n          characterColor: readUint8(view, 0x68 + offset),\n          teamShade: readUint8(view, 0x6c + offset),\n          handicap: readUint8(view, 0x6d + offset),\n          teamId: readUint8(view, 0x6e + offset),\n          staminaMode: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x01)),\n          silentCharacter: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x02)),\n          lowGravity: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x04)),\n          invisible: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x08)),\n          blackStockIcon: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x10)),\n          metal: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x20)),\n          startOnAngelPlatform: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x40)),\n          rumbleEnabled: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x80)),\n          cpuLevel: readUint8(view, 0x74 + offset),\n          offenseRatio: readFloat(view, 0x7d + offset),\n          defenseRatio: readFloat(view, 0x81 + offset),\n          modelScale: readFloat(view, 0x85 + offset),\n          controllerFix,\n          nametag,\n          displayName,\n          connectCode,\n          userId\n        };\n      };\n      const matchIdLength = 51;\n      const matchIdStart = 0x2be;\n      const matchIdBuf = payload.slice(matchIdStart, matchIdStart + matchIdLength);\n      const matchIdString = iconv__default[\"default\"].decode(matchIdBuf, \"utf8\").split(\"\\0\").shift();\n      const matchId = matchIdString != null ? matchIdString : \"\";\n      return {\n        slpVersion: `${readUint8(view, 0x1)}.${readUint8(view, 0x2)}.${readUint8(view, 0x3)}`,\n        timerType: readUint8(view, 0x5, 0x03),\n        inGameMode: readUint8(view, 0x5, 0xe0),\n        friendlyFireEnabled: !!readUint8(view, 0x6, 0x01),\n        isTeams: readBool(view, 0xd),\n        itemSpawnBehavior: readUint8(view, 0x10),\n        stageId: readUint16(view, 0x13),\n        startingTimerSeconds: readUint32(view, 0x15),\n        enabledItems: getEnabledItems(view),\n        players: [0, 1, 2, 3].map(getPlayerObject),\n        scene: readUint8(view, 0x1a3),\n        gameMode: readUint8(view, 0x1a4),\n        language: readUint8(view, 0x2bd),\n        gameInfoBlock: getGameInfoBlock(view),\n        randomSeed: readUint32(view, 0x13d),\n        isPAL: readBool(view, 0x1a1),\n        isFrozenPS: readBool(view, 0x1a2),\n        matchInfo: {\n          matchId,\n          gameNumber: readUint32(view, 0x2f1),\n          tiebreakerNumber: readUint32(view, 0x2f5)\n        }\n      };\n    case exports.Command.FRAME_START:\n      return {\n        frame: readInt32(view, 0x1),\n        seed: readUint32(view, 0x5),\n        sceneFrameCounter: readUint32(view, 0x9)\n      };\n    case exports.Command.PRE_FRAME_UPDATE:\n      return {\n        frame: readInt32(view, 0x1),\n        playerIndex: readUint8(view, 0x5),\n        isFollower: readBool(view, 0x6),\n        seed: readUint32(view, 0x7),\n        actionStateId: readUint16(view, 0xb),\n        positionX: readFloat(view, 0xd),\n        positionY: readFloat(view, 0x11),\n        facingDirection: readFloat(view, 0x15),\n        joystickX: readFloat(view, 0x19),\n        joystickY: readFloat(view, 0x1d),\n        cStickX: readFloat(view, 0x21),\n        cStickY: readFloat(view, 0x25),\n        trigger: readFloat(view, 0x29),\n        buttons: readUint32(view, 0x2d),\n        physicalButtons: readUint16(view, 0x31),\n        physicalLTrigger: readFloat(view, 0x33),\n        physicalRTrigger: readFloat(view, 0x37),\n        rawJoystickX: readInt8(view, 0x3b),\n        percent: readFloat(view, 0x3c)\n      };\n    case exports.Command.POST_FRAME_UPDATE:\n      const selfInducedSpeeds = {\n        airX: readFloat(view, 0x35),\n        y: readFloat(view, 0x39),\n        attackX: readFloat(view, 0x3d),\n        attackY: readFloat(view, 0x41),\n        groundX: readFloat(view, 0x45)\n      };\n      return {\n        frame: readInt32(view, 0x1),\n        playerIndex: readUint8(view, 0x5),\n        isFollower: readBool(view, 0x6),\n        internalCharacterId: readUint8(view, 0x7),\n        actionStateId: readUint16(view, 0x8),\n        positionX: readFloat(view, 0xa),\n        positionY: readFloat(view, 0xe),\n        facingDirection: readFloat(view, 0x12),\n        percent: readFloat(view, 0x16),\n        shieldSize: readFloat(view, 0x1a),\n        lastAttackLanded: readUint8(view, 0x1e),\n        currentComboCount: readUint8(view, 0x1f),\n        lastHitBy: readUint8(view, 0x20),\n        stocksRemaining: readUint8(view, 0x21),\n        actionStateCounter: readFloat(view, 0x22),\n        miscActionState: readFloat(view, 0x2b),\n        isAirborne: readBool(view, 0x2f),\n        lastGroundId: readUint16(view, 0x30),\n        jumpsRemaining: readUint8(view, 0x32),\n        lCancelStatus: readUint8(view, 0x33),\n        hurtboxCollisionState: readUint8(view, 0x34),\n        selfInducedSpeeds: selfInducedSpeeds,\n        hitlagRemaining: readFloat(view, 0x49),\n        animationIndex: readUint32(view, 0x4d)\n      };\n    case exports.Command.ITEM_UPDATE:\n      return {\n        frame: readInt32(view, 0x1),\n        typeId: readUint16(view, 0x5),\n        state: readUint8(view, 0x7),\n        facingDirection: readFloat(view, 0x8),\n        velocityX: readFloat(view, 0xc),\n        velocityY: readFloat(view, 0x10),\n        positionX: readFloat(view, 0x14),\n        positionY: readFloat(view, 0x18),\n        damageTaken: readUint16(view, 0x1c),\n        expirationTimer: readFloat(view, 0x1e),\n        spawnId: readUint32(view, 0x22),\n        missileType: readUint8(view, 0x26),\n        turnipFace: readUint8(view, 0x27),\n        chargeShotLaunched: readUint8(view, 0x28),\n        chargePower: readUint8(view, 0x29),\n        owner: readInt8(view, 0x2a)\n      };\n    case exports.Command.FRAME_BOOKEND:\n      return {\n        frame: readInt32(view, 0x1),\n        latestFinalizedFrame: readInt32(view, 0x5)\n      };\n    case exports.Command.GAME_END:\n      const placements = [0, 1, 2, 3].map(playerIndex => {\n        const position = readInt8(view, 0x3 + playerIndex);\n        return {\n          playerIndex,\n          position\n        };\n      });\n      return {\n        gameEndMethod: readUint8(view, 0x1),\n        lrasInitiatorIndex: readInt8(view, 0x2),\n        placements\n      };\n    case exports.Command.GECKO_LIST:\n      const codes = [];\n      let pos = 1;\n      while (pos < payload.length) {\n        var _readUint3;\n        const word1 = (_readUint3 = readUint32(view, pos)) != null ? _readUint3 : 0;\n        const codetype = word1 >> 24 & 0xfe;\n        const address = (word1 & 0x01ffffff) + 0x80000000;\n        let offset = 8; // Default code length, most codes are this length\n\n        if (codetype === 0xc0 || codetype === 0xc2) {\n          var _readUint4;\n          const lineCount = (_readUint4 = readUint32(view, pos + 4)) != null ? _readUint4 : 0;\n          offset = 8 + lineCount * 8;\n        } else if (codetype === 0x06) {\n          var _readUint5;\n          const byteLen = (_readUint5 = readUint32(view, pos + 4)) != null ? _readUint5 : 0;\n          offset = 8 + (byteLen + 7 & 0xfffffff8);\n        } else if (codetype === 0x08) {\n          offset = 16;\n        }\n        codes.push({\n          type: codetype,\n          address: address,\n          contents: payload.slice(pos, pos + offset)\n        });\n        pos += offset;\n      }\n      return {\n        contents: payload.slice(1),\n        codes: codes\n      };\n    default:\n      return null;\n  }\n}\nfunction canReadFromView(view, offset, length) {\n  const viewLength = view.byteLength;\n  return offset + length <= viewLength;\n}\nfunction readFloat(view, offset) {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n  return view.getFloat32(offset);\n}\nfunction readInt32(view, offset) {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n  return view.getInt32(offset);\n}\nfunction readInt8(view, offset) {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n  return view.getInt8(offset);\n}\nfunction readUint32(view, offset) {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n  return view.getUint32(offset);\n}\nfunction readUint16(view, offset) {\n  if (!canReadFromView(view, offset, 2)) {\n    return null;\n  }\n  return view.getUint16(offset);\n}\nfunction readUint8(view, offset, bitmask = 0xff) {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n  return view.getUint8(offset) & bitmask;\n}\nfunction readBool(view, offset) {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n  return !!view.getUint8(offset);\n}\nfunction getMetadata(slpFile) {\n  if (slpFile.metadataLength <= 0) {\n    // This will happen on a severed incomplete file\n    // $FlowFixMe\n    return null;\n  }\n  const buffer = new Uint8Array(slpFile.metadataLength);\n  readRef(slpFile.ref, buffer, 0, buffer.length, slpFile.metadataPosition);\n  let metadata = null;\n  try {\n    metadata = ubjson.decode(buffer);\n  } catch (ex) {// Do nothing\n    // console.log(ex);\n  } // $FlowFixMe\n\n  return metadata;\n}\nfunction getGameEnd(slpFile) {\n  const {\n    ref,\n    rawDataPosition,\n    rawDataLength,\n    messageSizes\n  } = slpFile;\n  const gameEndPayloadSize = messageSizes[exports.Command.GAME_END];\n  if (!exists(gameEndPayloadSize) || gameEndPayloadSize <= 0) {\n    return null;\n  } // Add one to account for command byte\n\n  const gameEndSize = gameEndPayloadSize + 1;\n  const gameEndPosition = rawDataPosition + rawDataLength - gameEndSize;\n  const buffer = new Uint8Array(gameEndSize);\n  readRef(ref, buffer, 0, buffer.length, gameEndPosition);\n  if (buffer[0] !== exports.Command.GAME_END) {\n    // This isn't even a game end payload\n    return null;\n  }\n  const gameEndMessage = parseMessage(exports.Command.GAME_END, buffer);\n  if (!gameEndMessage) {\n    return null;\n  }\n  return gameEndMessage;\n}\nfunction extractFinalPostFrameUpdates(slpFile) {\n  const {\n    ref,\n    rawDataPosition,\n    rawDataLength,\n    messageSizes\n  } = slpFile; // The following should exist on all replay versions\n\n  const postFramePayloadSize = messageSizes[exports.Command.POST_FRAME_UPDATE];\n  const gameEndPayloadSize = messageSizes[exports.Command.GAME_END];\n  const frameBookendPayloadSize = messageSizes[exports.Command.FRAME_BOOKEND]; // Technically this should not be possible\n\n  if (!exists(postFramePayloadSize)) {\n    return [];\n  }\n  const gameEndSize = gameEndPayloadSize ? gameEndPayloadSize + 1 : 0;\n  const postFrameSize = postFramePayloadSize + 1;\n  const frameBookendSize = frameBookendPayloadSize ? frameBookendPayloadSize + 1 : 0;\n  let frameNum = null;\n  let postFramePosition = rawDataPosition + rawDataLength - gameEndSize - frameBookendSize - postFrameSize;\n  const postFrameUpdates = [];\n  do {\n    const buffer = new Uint8Array(postFrameSize);\n    readRef(ref, buffer, 0, buffer.length, postFramePosition);\n    if (buffer[0] !== exports.Command.POST_FRAME_UPDATE) {\n      break;\n    }\n    const postFrameMessage = parseMessage(exports.Command.POST_FRAME_UPDATE, buffer);\n    if (!postFrameMessage) {\n      break;\n    }\n    if (frameNum === null) {\n      frameNum = postFrameMessage.frame;\n    } else if (frameNum !== postFrameMessage.frame) {\n      // If post frame message is found but the frame doesn't match, it's not part of the final frame\n      break;\n    }\n    postFrameUpdates.unshift(postFrameMessage);\n    postFramePosition -= postFrameSize;\n  } while (postFramePosition >= rawDataPosition);\n  return postFrameUpdates;\n}\nexports.SlpStreamMode = void 0;\n(function (SlpStreamMode) {\n  SlpStreamMode[\"AUTO\"] = \"AUTO\";\n  SlpStreamMode[\"MANUAL\"] = \"MANUAL\";\n})(exports.SlpStreamMode || (exports.SlpStreamMode = {}));\nconst defaultSettings$1 = {\n  suppressErrors: false,\n  mode: exports.SlpStreamMode.AUTO\n};\nexports.SlpStreamEvent = void 0;\n(function (SlpStreamEvent) {\n  SlpStreamEvent[\"RAW\"] = \"slp-raw\";\n  SlpStreamEvent[\"COMMAND\"] = \"slp-command\";\n})(exports.SlpStreamEvent || (exports.SlpStreamEvent = {}));\n/**\r\n * SlpStream is a writable stream of Slippi data. It passes the data being written in\r\n * and emits an event based on what kind of Slippi messages were processed.\r\n *\r\n * SlpStream emits two events: \"slp-raw\" and \"slp-command\". The \"slp-raw\" event emits the raw buffer\r\n * bytes whenever it processes each command. You can manually parse this or write it to a\r\n * file. The \"slp-command\" event returns the parsed payload which you can access the attributes.\r\n *\r\n * @class SlpStream\r\n * @extends {Writable}\r\n */\n\nclass SlpStream extends stream.Writable {\n  // True only if in manual mode and the game has completed\n\n  /**\r\n   *Creates an instance of SlpStream.\r\n   * @param {Partial<SlpStreamSettings>} [slpOptions]\r\n   * @param {WritableOptions} [opts]\r\n   * @memberof SlpStream\r\n   */\n  constructor(slpOptions, opts) {\n    super(opts);\n    this.gameEnded = false;\n    this.settings = void 0;\n    this.payloadSizes = null;\n    this.previousBuffer = Buffer.from([]);\n    this.settings = Object.assign({}, defaultSettings$1, slpOptions);\n  }\n  restart() {\n    this.gameEnded = false;\n    this.payloadSizes = null;\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  _write(newData, encoding, callback) {\n    if (encoding !== \"buffer\") {\n      throw new Error(`Unsupported stream encoding. Expected 'buffer' got '${encoding}'.`);\n    } // Join the current data with the old data\n\n    const data = Uint8Array.from(Buffer.concat([this.previousBuffer, newData])); // Clear previous data\n\n    this.previousBuffer = Buffer.from([]);\n    const dataView = new DataView(data.buffer); // Iterate through the data\n\n    let index = 0;\n    while (index < data.length) {\n      // We want to filter out the network messages\n      if (Buffer.from(data.slice(index, index + 5)).toString() === NETWORK_MESSAGE) {\n        index += 5;\n        continue;\n      } // Make sure we have enough data to read a full payload\n\n      const command = dataView.getUint8(index);\n      let payloadSize = 0;\n      if (this.payloadSizes) {\n        var _this$payloadSizes$ge;\n        payloadSize = (_this$payloadSizes$ge = this.payloadSizes.get(command)) != null ? _this$payloadSizes$ge : 0;\n      }\n      const remainingLen = data.length - index;\n      if (remainingLen < payloadSize + 1) {\n        // If remaining length is not long enough for full payload, save the remaining\n        // data until we receive more data. The data has been split up.\n        this.previousBuffer = data.slice(index);\n        break;\n      } // Only process if the game is still going\n\n      if (this.settings.mode === exports.SlpStreamMode.MANUAL && this.gameEnded) {\n        break;\n      } // Increment by one for the command byte\n\n      index += 1;\n      const payloadPtr = data.slice(index);\n      const payloadDataView = new DataView(data.buffer, index);\n      let payloadLen = 0;\n      try {\n        payloadLen = this._processCommand(command, payloadPtr, payloadDataView);\n      } catch (err) {\n        // Only throw the error if we're not suppressing the errors\n        if (!this.settings.suppressErrors) {\n          throw err;\n        }\n        payloadLen = 0;\n      }\n      index += payloadLen;\n    }\n    callback();\n  }\n  _writeCommand(command, entirePayload, payloadSize) {\n    const payloadBuf = entirePayload.slice(0, payloadSize);\n    const bufToWrite = Buffer.concat([Buffer.from([command]), payloadBuf]); // Forward the raw buffer onwards\n\n    this.emit(exports.SlpStreamEvent.RAW, {\n      command: command,\n      payload: bufToWrite\n    });\n    return new Uint8Array(bufToWrite);\n  }\n  _processCommand(command, entirePayload, dataView) {\n    // Handle the message size command\n    if (command === exports.Command.MESSAGE_SIZES) {\n      const payloadSize = dataView.getUint8(0); // Set the payload sizes\n\n      this.payloadSizes = processReceiveCommands(dataView); // Emit the raw command event\n\n      this._writeCommand(command, entirePayload, payloadSize);\n      this.emit(exports.SlpStreamEvent.COMMAND, {\n        command: command,\n        payload: this.payloadSizes\n      });\n      return payloadSize;\n    }\n    let payloadSize = 0;\n    if (this.payloadSizes) {\n      var _this$payloadSizes$ge2;\n      payloadSize = (_this$payloadSizes$ge2 = this.payloadSizes.get(command)) != null ? _this$payloadSizes$ge2 : 0;\n    } // Fetch the payload and parse it\n\n    let payload;\n    let parsedPayload = null;\n    if (payloadSize > 0) {\n      payload = this._writeCommand(command, entirePayload, payloadSize);\n      parsedPayload = parseMessage(command, payload);\n    }\n    if (!parsedPayload) {\n      return payloadSize;\n    }\n    switch (command) {\n      case exports.Command.GAME_END:\n        // Stop parsing data until we manually restart the stream\n        if (this.settings.mode === exports.SlpStreamMode.MANUAL) {\n          this.gameEnded = true;\n        }\n        break;\n    }\n    this.emit(exports.SlpStreamEvent.COMMAND, {\n      command: command,\n      payload: parsedPayload\n    });\n    return payloadSize;\n  }\n}\nconst processReceiveCommands = dataView => {\n  const payloadSizes = new Map();\n  const payloadLen = dataView.getUint8(0);\n  for (let i = 1; i < payloadLen; i += 3) {\n    const commandByte = dataView.getUint8(i);\n    const payloadSize = dataView.getUint16(i + 1);\n    payloadSizes.set(commandByte, payloadSize);\n  }\n  return payloadSizes;\n};\nconst DEFAULT_NICKNAME = \"unknown\";\n/**\r\n * SlpFile is a class that wraps a Writable stream. It handles the writing of the binary\r\n * header and footer, and also handles the overwriting of the raw data length.\r\n *\r\n * @class SlpFile\r\n * @extends {Writable}\r\n */\n\nclass SlpFile extends stream.Writable {\n  /**\r\n   * Creates an instance of SlpFile.\r\n   * @param {string} filePath The file location to write to.\r\n   * @param {WritableOptions} [opts] Options for writing.\r\n   * @memberof SlpFile\r\n   */\n  constructor(filePath, slpStream, opts) {\n    super(opts);\n    this.filePath = void 0;\n    this.metadata = void 0;\n    this.fileStream = null;\n    this.rawDataLength = 0;\n    this.slpStream = void 0;\n    this.usesExternalStream = false;\n    this.filePath = filePath;\n    this.metadata = {\n      consoleNickname: DEFAULT_NICKNAME,\n      startTime: new Date(),\n      lastFrame: -124,\n      players: {}\n    };\n    this.usesExternalStream = Boolean(slpStream); // Create a new SlpStream if one wasn't already provided\n    // This SLP stream represents a single game not multiple, so use manual mode\n\n    this.slpStream = slpStream ? slpStream : new SlpStream({\n      mode: exports.SlpStreamMode.MANUAL\n    });\n    this._setupListeners();\n    this._initializeNewGame(this.filePath);\n  }\n  /**\r\n   * Get the current file path being written to.\r\n   *\r\n   * @returns {string} The location of the current file path\r\n   * @memberof SlpFile\r\n   */\n\n  path() {\n    return this.filePath;\n  }\n  /**\r\n   * Sets the metadata of the Slippi file, such as consoleNickname, lastFrame, and players.\r\n   * @param metadata The metadata to be written\r\n   */\n\n  setMetadata(metadata) {\n    this.metadata = Object.assign({}, this.metadata, metadata);\n  }\n  _write(chunk, encoding, callback) {\n    if (encoding !== \"buffer\") {\n      throw new Error(`Unsupported stream encoding. Expected 'buffer' got '${encoding}'.`);\n    } // Write it to the file\n\n    if (this.fileStream) {\n      this.fileStream.write(chunk);\n    } // Parse the data manually if it's an internal stream\n\n    if (!this.usesExternalStream) {\n      this.slpStream.write(chunk);\n    } // Keep track of the bytes we've written\n\n    this.rawDataLength += chunk.length;\n    callback();\n  }\n  /**\r\n   * Here we define what to do on each command. We need to populate the metadata field\r\n   * so we keep track of the latest frame, as well as the number of frames each character has\r\n   * been used.\r\n   *\r\n   * @param data The parsed data from a SlpStream\r\n   */\n\n  _onCommand(data) {\n    const {\n      command,\n      payload\n    } = data;\n    switch (command) {\n      case exports.Command.GAME_START:\n        const {\n          players\n        } = payload;\n        lodash.forEach(players, player => {\n          if (player.type === 3) {\n            return;\n          }\n          this.metadata.players[player.playerIndex] = {\n            characterUsage: {},\n            names: {\n              netplay: player.displayName,\n              code: player.connectCode\n            }\n          };\n        });\n        break;\n      case exports.Command.POST_FRAME_UPDATE:\n        // Here we need to update some metadata fields\n        const {\n          frame,\n          playerIndex,\n          isFollower,\n          internalCharacterId\n        } = payload;\n        if (isFollower) {\n          // No need to do this for follower\n          break;\n        } // Update frame index\n\n        this.metadata.lastFrame = frame; // Update character usage\n\n        const prevPlayer = this.metadata.players[playerIndex];\n        const characterUsage = prevPlayer.characterUsage;\n        const curCharFrames = characterUsage[internalCharacterId] || 0;\n        const player = {\n          ...prevPlayer,\n          characterUsage: {\n            ...characterUsage,\n            [internalCharacterId]: curCharFrames + 1\n          }\n        };\n        this.metadata.players[playerIndex] = player;\n        break;\n    }\n  }\n  _setupListeners() {\n    const streamListener = data => {\n      this._onCommand(data);\n    };\n    this.slpStream.on(exports.SlpStreamEvent.COMMAND, streamListener);\n    this.on(\"finish\", () => {\n      // Update file with bytes written\n      const fd = fs__default[\"default\"].openSync(this.filePath, \"r+\");\n      fs__default[\"default\"].writeSync(fd, createUInt32Buffer(this.rawDataLength), 0, 4, 11);\n      fs__default[\"default\"].closeSync(fd); // Unsubscribe from the stream\n\n      this.slpStream.removeListener(exports.SlpStreamEvent.COMMAND, streamListener); // Terminate the internal stream\n\n      if (!this.usesExternalStream) {\n        this.slpStream.end();\n      }\n    });\n  }\n  _initializeNewGame(filePath) {\n    this.fileStream = fs__default[\"default\"].createWriteStream(filePath, {\n      encoding: \"binary\"\n    });\n    const header = Buffer.concat([Buffer.from(\"{U\"), Buffer.from([3]), Buffer.from(\"raw[$U#l\"), Buffer.from([0, 0, 0, 0])]);\n    this.fileStream.write(header);\n  }\n  _final(callback) {\n    let footer = Buffer.concat([Buffer.from(\"U\"), Buffer.from([8]), Buffer.from(\"metadata{\")]); // Write game start time\n\n    const startTimeStr = this.metadata.startTime.toISOString();\n    footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([7]), Buffer.from(\"startAtSU\"), Buffer.from([startTimeStr.length]), Buffer.from(startTimeStr)]); // Write last frame index\n    // TODO: Get last frame\n\n    const lastFrame = this.metadata.lastFrame;\n    footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([9]), Buffer.from(\"lastFramel\"), createInt32Buffer(lastFrame)]); // write the Console Nickname\n\n    const consoleNick = this.metadata.consoleNickname || DEFAULT_NICKNAME;\n    footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([11]), Buffer.from(\"consoleNickSU\"), Buffer.from([consoleNick.length]), Buffer.from(consoleNick)]); // Start writting player specific data\n\n    footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([7]), Buffer.from(\"players{\")]);\n    const players = this.metadata.players;\n    lodash.forEach(players, (player, index) => {\n      // Start player obj with index being the player index\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([index.length]), Buffer.from(`${index}{`)]); // Start characters key for this player\n\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([10]), Buffer.from(\"characters{\")]); // Write character usage\n\n      lodash.forEach(player.characterUsage, (usage, internalId) => {\n        // Write this character\n        footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([internalId.length]), Buffer.from(`${internalId}l`), createUInt32Buffer(usage)]);\n      }); // Close characters\n\n      footer = Buffer.concat([footer, Buffer.from(\"}\")]); // Start names key for this player\n\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([5]), Buffer.from(\"names{\")]); // Write display name\n\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([7]), Buffer.from(\"netplaySU\"), Buffer.from([player.names.netplay.length]), Buffer.from(`${player.names.netplay}`)]); // Write connect code\n\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([4]), Buffer.from(\"codeSU\"), Buffer.from([player.names.code.length]), Buffer.from(`${player.names.code}`)]); // Close names and player\n\n      footer = Buffer.concat([footer, Buffer.from(\"}}\")]);\n    }); // Close players\n\n    footer = Buffer.concat([footer, Buffer.from(\"}\")]); // Write played on\n\n    footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([8]), Buffer.from(\"playedOnSU\"), Buffer.from([7]), Buffer.from(\"network\")]); // Close metadata and file\n\n    footer = Buffer.concat([footer, Buffer.from(\"}}\")]); // End the stream\n\n    if (this.fileStream) {\n      this.fileStream.write(footer, callback);\n    }\n  }\n}\nconst createInt32Buffer = number => {\n  const buf = Buffer.alloc(4);\n  buf.writeInt32BE(number, 0);\n  return buf;\n};\nconst createUInt32Buffer = number => {\n  const buf = Buffer.alloc(4);\n  buf.writeUInt32BE(number, 0);\n  return buf;\n};\n\n/**\r\n * The default function to use for generating new SLP files.\r\n */\n\nfunction getNewFilePath(folder, date) {\n  return path__default[\"default\"].join(folder, `Game_${dateFns.format(date, \"yyyyMMdd\")}T${dateFns.format(date, \"HHmmss\")}.slp`);\n}\nconst defaultSettings = {\n  outputFiles: true,\n  folderPath: \".\",\n  consoleNickname: \"unknown\",\n  newFilename: getNewFilePath\n};\nexports.SlpFileWriterEvent = void 0;\n(function (SlpFileWriterEvent) {\n  SlpFileWriterEvent[\"NEW_FILE\"] = \"new-file\";\n  SlpFileWriterEvent[\"FILE_COMPLETE\"] = \"file-complete\";\n})(exports.SlpFileWriterEvent || (exports.SlpFileWriterEvent = {}));\n/**\r\n * SlpFileWriter lets us not only emit events as an SlpStream but also\r\n * writes the data that is being passed in to an SLP file. Use this if\r\n * you want to process Slippi data in real time but also want to be able\r\n * to write out the data to an SLP file.\r\n *\r\n * @export\r\n * @class SlpFileWriter\r\n * @extends {SlpStream}\r\n */\n\nclass SlpFileWriter extends SlpStream {\n  /**\r\n   * Creates an instance of SlpFileWriter.\r\n   */\n  constructor(options, opts) {\n    super(options, opts);\n    this.currentFile = null;\n    this.options = void 0;\n    this.options = Object.assign({}, defaultSettings, options);\n    this._setupListeners();\n  }\n  _writePayload(payload) {\n    // Write data to the current file\n    if (this.currentFile) {\n      this.currentFile.write(payload);\n    }\n  }\n  _setupListeners() {\n    this.on(exports.SlpStreamEvent.RAW, data => {\n      const {\n        command,\n        payload\n      } = data;\n      switch (command) {\n        case exports.Command.MESSAGE_SIZES:\n          // Create the new game first before writing the payload\n          this._handleNewGame();\n          this._writePayload(payload);\n          break;\n        case exports.Command.GAME_END:\n          // Write payload first before ending the game\n          this._writePayload(payload);\n          this._handleEndGame();\n          break;\n        default:\n          this._writePayload(payload);\n          break;\n      }\n    });\n  }\n  /**\r\n   * Return the name of the SLP file currently being written or null if\r\n   * no file is being written to currently.\r\n   *\r\n   * @returns {(string | null)}\r\n   * @memberof SlpFileWriter\r\n   */\n\n  getCurrentFilename() {\n    if (this.currentFile !== null) {\n      return path__default[\"default\"].resolve(this.currentFile.path());\n    }\n    return null;\n  }\n  /**\r\n   * Ends the current file being written to.\r\n   *\r\n   * @returns {(string | null)}\r\n   * @memberof SlpFileWriter\r\n   */\n\n  endCurrentFile() {\n    this._handleEndGame();\n  }\n  /**\r\n   * Updates the settings to be the desired ones passed in.\r\n   *\r\n   * @param {Partial<SlpFileWriterOptions>} settings\r\n   * @memberof SlpFileWriter\r\n   */\n\n  updateSettings(settings) {\n    this.options = Object.assign({}, this.options, settings);\n  }\n  _handleNewGame() {\n    // Only create a new file if we're outputting files\n    if (this.options.outputFiles) {\n      const filePath = this.options.newFilename(this.options.folderPath, new Date());\n      this.currentFile = new SlpFile(filePath, this); // console.log(`Creating new file at: ${filePath}`);\n\n      this.emit(exports.SlpFileWriterEvent.NEW_FILE, filePath);\n    }\n  }\n  _handleEndGame() {\n    // End the stream\n    if (this.currentFile) {\n      // Set the console nickname\n      this.currentFile.setMetadata({\n        consoleNickname: this.options.consoleNickname\n      });\n      this.currentFile.end(); // console.log(`Finished writing file: ${this.currentFile.path()}`);\n\n      this.emit(exports.SlpFileWriterEvent.FILE_COMPLETE, this.currentFile.path()); // Clear current file\n\n      this.currentFile = null;\n    }\n  }\n}\nclass RollbackCounter {\n  constructor() {\n    this.rollbackFrames = {};\n    this.rollbackFrameCount = 0;\n    this.rollbackPlayerIdx = null;\n    this.lastFrameWasRollback = false;\n    this.currentRollbackLength = 0;\n    this.rollbackLengths = [];\n  }\n  checkIfRollbackFrame(currentFrame, playerIdx) {\n    if (this.rollbackPlayerIdx === null) {\n      // we only want to follow a single player to avoid double counting. So we use whoever is on first.\n      this.rollbackPlayerIdx = playerIdx;\n    } else if (this.rollbackPlayerIdx !== playerIdx) {\n      return;\n    }\n    if (currentFrame && currentFrame.players) {\n      // frame already exists for currentFrameNumber so we must be rolling back\n      // Note: We detect during PreFrameUpdate, but new versions have a\n      // FrameStart command that has already initialized the frame, so we must\n      // check for player data too.\n      if (this.rollbackFrames[currentFrame.frame]) {\n        this.rollbackFrames[currentFrame.frame].push(currentFrame);\n      } else {\n        this.rollbackFrames[currentFrame.frame] = [currentFrame];\n      }\n      this.rollbackFrameCount++;\n      this.currentRollbackLength++;\n      this.lastFrameWasRollback = true;\n    } else if (this.lastFrameWasRollback) {\n      this.rollbackLengths.push(this.currentRollbackLength);\n      this.currentRollbackLength = 0;\n      this.lastFrameWasRollback = false;\n    }\n    return this.lastFrameWasRollback;\n  }\n  getFrames() {\n    return this.rollbackFrames;\n  }\n  getCount() {\n    return this.rollbackFrameCount;\n  }\n  getLengths() {\n    return this.rollbackLengths;\n  }\n}\nconst ITEM_SETTINGS_BIT_COUNT = 40;\nconst MAX_ROLLBACK_FRAMES = 7;\nexports.SlpParserEvent = void 0;\n(function (SlpParserEvent) {\n  SlpParserEvent[\"SETTINGS\"] = \"settings\";\n  SlpParserEvent[\"END\"] = \"end\";\n  SlpParserEvent[\"FRAME\"] = \"frame\";\n  SlpParserEvent[\"FINALIZED_FRAME\"] = \"finalized-frame\";\n  SlpParserEvent[\"ROLLBACK_FRAME\"] = \"rollback-frame\";\n})(exports.SlpParserEvent || (exports.SlpParserEvent = {})); // If strict mode is on, we will do strict validation checking\n// which could throw errors on invalid data.\n// Default to false though since probably only real time applications\n// would care about valid data.\n\nconst defaultSlpParserOptions = {\n  strict: false\n};\nclass SlpParser extends events.EventEmitter {\n  constructor(options) {\n    super();\n    this.frames = {};\n    this.rollbackCounter = new RollbackCounter();\n    this.settings = null;\n    this.gameEnd = null;\n    this.latestFrameIndex = null;\n    this.settingsComplete = false;\n    this.lastFinalizedFrame = exports.Frames.FIRST - 1;\n    this.options = void 0;\n    this.geckoList = null;\n    this.options = Object.assign({}, defaultSlpParserOptions, options);\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  handleCommand(command, payload) {\n    switch (command) {\n      case exports.Command.GAME_START:\n        this._handleGameStart(payload);\n        break;\n      case exports.Command.FRAME_START:\n        this._handleFrameStart(payload);\n        break;\n      case exports.Command.POST_FRAME_UPDATE:\n        // We need to handle the post frame update first since that\n        // will finalize the settings object, before we fire the frame update\n        this._handlePostFrameUpdate(payload);\n        this._handleFrameUpdate(command, payload);\n        break;\n      case exports.Command.PRE_FRAME_UPDATE:\n        this._handleFrameUpdate(command, payload);\n        break;\n      case exports.Command.ITEM_UPDATE:\n        this._handleItemUpdate(payload);\n        break;\n      case exports.Command.FRAME_BOOKEND:\n        this._handleFrameBookend(payload);\n        break;\n      case exports.Command.GAME_END:\n        this._handleGameEnd(payload);\n        break;\n      case exports.Command.GECKO_LIST:\n        this._handleGeckoList(payload);\n        break;\n    }\n  }\n  /**\r\n   * Resets the parser state to their default values.\r\n   */\n\n  reset() {\n    this.frames = {};\n    this.settings = null;\n    this.gameEnd = null;\n    this.latestFrameIndex = null;\n    this.settingsComplete = false;\n    this.lastFinalizedFrame = exports.Frames.FIRST - 1;\n  }\n  getLatestFrameNumber() {\n    var _this$latestFrameInde;\n    return (_this$latestFrameInde = this.latestFrameIndex) != null ? _this$latestFrameInde : exports.Frames.FIRST - 1;\n  }\n  getPlayableFrameCount() {\n    if (this.latestFrameIndex === null) {\n      return 0;\n    }\n    return this.latestFrameIndex < exports.Frames.FIRST_PLAYABLE ? 0 : this.latestFrameIndex - exports.Frames.FIRST_PLAYABLE;\n  }\n  getLatestFrame() {\n    // return this.playerFrames[this.latestFrameIndex];\n    // TODO: Modify this to check if we actually have all the latest frame data and return that\n    // TODO: If we do. For now I'm just going to take a shortcut\n    const allFrames = this.getFrames();\n    const frameIndex = this.latestFrameIndex !== null ? this.latestFrameIndex : exports.Frames.FIRST;\n    const indexToUse = this.gameEnd ? frameIndex : frameIndex - 1;\n    return lodash.get(allFrames, indexToUse) || null;\n  }\n  getSettings() {\n    return this.settingsComplete ? this.settings : null;\n  }\n  getItems() {\n    var _this$settings, _this$settings2;\n    if (((_this$settings = this.settings) == null ? void 0 : _this$settings.itemSpawnBehavior) === exports.ItemSpawnType.OFF) {\n      return null;\n    }\n    const itemBitfield = (_this$settings2 = this.settings) == null ? void 0 : _this$settings2.enabledItems;\n    if (!exists(itemBitfield)) {\n      return null;\n    }\n    const enabledItems = []; // Ideally we would be able to do this with bitshifting instead, but javascript\n    // truncates numbers after 32 bits when doing bitwise operations\n\n    for (let i = 0; i < ITEM_SETTINGS_BIT_COUNT; i++) {\n      if (Math.floor(itemBitfield / 2 ** i) & 1) {\n        enabledItems.push(2 ** i);\n      }\n    }\n    return enabledItems;\n  }\n  getGameEnd() {\n    return this.gameEnd;\n  }\n  getFrames() {\n    return this.frames;\n  }\n  getRollbackFrames() {\n    return {\n      frames: this.rollbackCounter.getFrames(),\n      count: this.rollbackCounter.getCount(),\n      lengths: this.rollbackCounter.getLengths()\n    };\n  }\n  getFrame(num) {\n    return this.frames[num] || null;\n  }\n  getGeckoList() {\n    return this.geckoList;\n  }\n  _handleGeckoList(payload) {\n    this.geckoList = payload;\n  }\n  _handleGameEnd(payload) {\n    // Finalize remaining frames if necessary\n    if (this.latestFrameIndex !== null && this.latestFrameIndex !== this.lastFinalizedFrame) {\n      this._finalizeFrames(this.latestFrameIndex);\n    }\n    payload = payload;\n    this.gameEnd = payload;\n    this.emit(exports.SlpParserEvent.END, this.gameEnd);\n  }\n  _handleGameStart(payload) {\n    this.settings = payload;\n    const players = payload.players;\n    this.settings.players = players.filter(player => player.type !== 3); // Check to see if the file was created after the sheik fix so we know\n    // we don't have to process the first frame of the game for the full settings\n\n    if (payload.slpVersion && semver__default[\"default\"].gte(payload.slpVersion, \"1.6.0\")) {\n      this._completeSettings();\n    }\n  }\n  _handleFrameStart(payload) {\n    const currentFrameNumber = payload.frame;\n    lodash.set(this.frames, [currentFrameNumber, \"start\"], payload);\n  }\n  _handlePostFrameUpdate(payload) {\n    if (this.settingsComplete) {\n      return;\n    } // Finish calculating settings\n\n    if (payload.frame <= exports.Frames.FIRST) {\n      const playerIndex = payload.playerIndex;\n      const playersByIndex = lodash.keyBy(this.settings.players, \"playerIndex\");\n      switch (payload.internalCharacterId) {\n        case 0x7:\n          playersByIndex[playerIndex].characterId = 0x13; // Sheik\n\n          break;\n        case 0x13:\n          playersByIndex[playerIndex].characterId = 0x12; // Zelda\n\n          break;\n      }\n    }\n    if (payload.frame > exports.Frames.FIRST) {\n      this._completeSettings();\n    }\n  }\n  _handleFrameUpdate(command, payload) {\n    payload = payload;\n    const location = command === exports.Command.PRE_FRAME_UPDATE ? \"pre\" : \"post\";\n    const field = payload.isFollower ? \"followers\" : \"players\";\n    const currentFrameNumber = payload.frame;\n    this.latestFrameIndex = currentFrameNumber;\n    if (location === \"pre\" && !payload.isFollower) {\n      const currentFrame = this.frames[currentFrameNumber];\n      const wasRolledback = this.rollbackCounter.checkIfRollbackFrame(currentFrame, payload.playerIndex);\n      if (wasRolledback) {\n        // frame is about to be overwritten\n        this.emit(exports.SlpParserEvent.ROLLBACK_FRAME, currentFrame);\n      }\n    }\n    lodash.set(this.frames, [currentFrameNumber, field, payload.playerIndex, location], payload);\n    lodash.set(this.frames, [currentFrameNumber, \"frame\"], currentFrameNumber); // If file is from before frame bookending, add frame to stats computer here. Does a little\n    // more processing than necessary, but it works\n\n    const settings = this.getSettings();\n    if (settings && (!settings.slpVersion || semver__default[\"default\"].lte(settings.slpVersion, \"2.2.0\"))) {\n      this.emit(exports.SlpParserEvent.FRAME, this.frames[currentFrameNumber]); // Finalize the previous frame since no bookending exists\n\n      this._finalizeFrames(currentFrameNumber - 1);\n    } else {\n      lodash.set(this.frames, [currentFrameNumber, \"isTransferComplete\"], false);\n    }\n  }\n  _handleItemUpdate(payload) {\n    var _this$frames$currentF, _this$frames$currentF2;\n    const currentFrameNumber = payload.frame;\n    const items = (_this$frames$currentF = (_this$frames$currentF2 = this.frames[currentFrameNumber]) == null ? void 0 : _this$frames$currentF2.items) != null ? _this$frames$currentF : [];\n    items.push(payload); // Set items with newest\n\n    lodash.set(this.frames, [currentFrameNumber, \"items\"], items);\n  }\n  _handleFrameBookend(payload) {\n    const latestFinalizedFrame = payload.latestFinalizedFrame;\n    const currentFrameNumber = payload.frame;\n    lodash.set(this.frames, [currentFrameNumber, \"isTransferComplete\"], true); // Fire off a normal frame event\n\n    this.emit(exports.SlpParserEvent.FRAME, this.frames[currentFrameNumber]); // Finalize frames if necessary\n\n    const validLatestFrame = this.settings.gameMode === exports.GameMode.ONLINE;\n    if (validLatestFrame && latestFinalizedFrame >= exports.Frames.FIRST) {\n      // Ensure valid latestFinalizedFrame\n      if (this.options.strict && latestFinalizedFrame < currentFrameNumber - MAX_ROLLBACK_FRAMES) {\n        throw new Error(`latestFinalizedFrame should be within ${MAX_ROLLBACK_FRAMES} frames of ${currentFrameNumber}`);\n      }\n      this._finalizeFrames(latestFinalizedFrame);\n    } else {\n      // Since we don't have a valid finalized frame, just finalize the frame based on MAX_ROLLBACK_FRAMES\n      this._finalizeFrames(currentFrameNumber - MAX_ROLLBACK_FRAMES);\n    }\n  }\n  /**\r\n   * Fires off the FINALIZED_FRAME event for frames up until a certain number\r\n   * @param num The frame to finalize until\r\n   */\n\n  _finalizeFrames(num) {\n    while (this.lastFinalizedFrame < num) {\n      const frameToFinalize = this.lastFinalizedFrame + 1;\n      const frame = this.getFrame(frameToFinalize); // Check that we have all the pre and post frame data for all players if we're in strict mode\n\n      if (this.options.strict) {\n        for (const player of this.settings.players) {\n          const playerFrameInfo = frame.players[player.playerIndex]; // Allow player frame info to be empty in non 1v1 games since\n          // players which have been defeated will have no frame info.\n\n          if (this.settings.players.length > 2 && !playerFrameInfo) {\n            continue;\n          }\n          const {\n            pre,\n            post\n          } = playerFrameInfo;\n          if (!pre || !post) {\n            const preOrPost = pre ? \"pre\" : \"post\";\n            throw new Error(`Could not finalize frame ${frameToFinalize} of ${num}: missing ${preOrPost}-frame update for player ${player.playerIndex}`);\n          }\n        }\n      } // Our frame is complete so finalize the frame\n\n      this.emit(exports.SlpParserEvent.FINALIZED_FRAME, frame);\n      this.lastFinalizedFrame = frameToFinalize;\n    }\n  }\n  _completeSettings() {\n    if (!this.settingsComplete) {\n      this.settingsComplete = true;\n      this.emit(exports.SlpParserEvent.SETTINGS, this.settings);\n    }\n  }\n}\nfunction getWinners(gameEnd, settings, finalPostFrameUpdates) {\n  var _players$find$teamId, _players$find2;\n  const {\n    placements,\n    gameEndMethod,\n    lrasInitiatorIndex\n  } = gameEnd;\n  const {\n    players,\n    isTeams\n  } = settings;\n  if (gameEndMethod === exports.GameEndMethod.NO_CONTEST || gameEndMethod === exports.GameEndMethod.UNRESOLVED) {\n    // The winner is the person who didn't LRAS\n    if (exists(lrasInitiatorIndex) && players.length === 2) {\n      var _players$find;\n      const winnerIndex = (_players$find = players.find(({\n        playerIndex\n      }) => playerIndex !== lrasInitiatorIndex)) == null ? void 0 : _players$find.playerIndex;\n      if (exists(winnerIndex)) {\n        return [{\n          playerIndex: winnerIndex,\n          position: 0\n        }];\n      }\n    }\n    return [];\n  }\n  if (gameEndMethod === exports.GameEndMethod.TIME && players.length === 2) {\n    const nonFollowerUpdates = finalPostFrameUpdates.filter(pfu => !pfu.isFollower);\n    if (nonFollowerUpdates.length !== players.length) {\n      return [];\n    }\n    const p1 = nonFollowerUpdates[0];\n    const p2 = nonFollowerUpdates[1];\n    if (p1.stocksRemaining > p2.stocksRemaining) {\n      return [{\n        playerIndex: p1.playerIndex,\n        position: 0\n      }];\n    } else if (p2.stocksRemaining > p1.stocksRemaining) {\n      return [{\n        playerIndex: p2.playerIndex,\n        position: 0\n      }];\n    }\n    const p1Health = Math.trunc(p1.percent);\n    const p2Health = Math.trunc(p2.percent);\n    if (p1Health < p2Health) {\n      return [{\n        playerIndex: p1.playerIndex,\n        position: 0\n      }];\n    } else if (p2Health < p1Health) {\n      return [{\n        playerIndex: p2.playerIndex,\n        position: 0\n      }];\n    } // If stocks and percents were tied, no winner\n\n    return [];\n  }\n  const firstPosition = placements.find(placement => placement.position === 0);\n  if (!firstPosition) {\n    return [];\n  }\n  const winningTeam = (_players$find$teamId = (_players$find2 = players.find(({\n    playerIndex\n  }) => playerIndex === firstPosition.playerIndex)) == null ? void 0 : _players$find2.teamId) != null ? _players$find$teamId : null;\n  if (isTeams && exists(winningTeam)) {\n    return placements.filter(placement => {\n      var _players$find$teamId2, _players$find3;\n      const teamId = (_players$find$teamId2 = (_players$find3 = players.find(({\n        playerIndex\n      }) => playerIndex === placement.playerIndex)) == null ? void 0 : _players$find3.teamId) != null ? _players$find$teamId2 : null;\n      return teamId === winningTeam;\n    });\n  }\n  return [firstPosition];\n}\nconst SANDBAG_INTERNAL_ID = 32;\nconst FEET_CONVERSION_FACTOR = 0.952462;\nconst METERS_CONVERSION_FACTOR = 1.04167;\nfunction positionToHomeRunDistance(distance, units = \"feet\") {\n  let score = 0;\n  switch (units) {\n    case \"feet\":\n      score = 10 * Math.floor(distance - 70 * FEET_CONVERSION_FACTOR); // convert to float32\n\n      score = Math.fround(score);\n      score = Math.floor(score / 30.4788 * 10) / 10;\n      break;\n    case \"meters\":\n      score = 10 * Math.floor(distance - 70 * METERS_CONVERSION_FACTOR); // convert to float32\n\n      score = Math.fround(score);\n      score = Math.floor(score / 100 * 10) / 10;\n      break;\n    default:\n      throw new Error(`Unsupported units: ${units}`);\n  } // round to 1 decimal\n\n  score = Math.round(score * 10) / 10;\n  return Math.max(0, score);\n}\nfunction extractDistanceInfoFromFrame(settings, lastFrame) {\n  var _sandbagLastFrame$pos;\n  const sandbagLastFrame = Object.values(lastFrame.players).filter(exists).find(playerFrame => playerFrame.post.internalCharacterId === SANDBAG_INTERNAL_ID);\n  if (!sandbagLastFrame) {\n    return null;\n  } // Only return the distance in meters if it's a Japanese replay.\n  // Technically we should check if the replay is PAL but we don't yet support\n  // stadium replays in PAL.\n\n  const units = settings.language === exports.Language.JAPANESE ? \"meters\" : \"feet\";\n  const distance = positionToHomeRunDistance((_sandbagLastFrame$pos = sandbagLastFrame.post.positionX) != null ? _sandbagLastFrame$pos : 0, units);\n  return {\n    distance,\n    units\n  };\n}\n\n/**\r\n * Slippi Game class that wraps a file\r\n */\n\nclass SlippiGame {\n  constructor(input, opts) {\n    this.input = void 0;\n    this.metadata = null;\n    this.finalStats = null;\n    this.parser = void 0;\n    this.readPosition = null;\n    this.actionsComputer = new ActionsComputer();\n    this.conversionComputer = new ConversionComputer();\n    this.comboComputer = new ComboComputer();\n    this.stockComputer = new StockComputer();\n    this.inputComputer = new InputComputer();\n    this.targetBreakComputer = new TargetBreakComputer();\n    this.statsComputer = void 0;\n    if (typeof input === \"string\") {\n      this.input = {\n        source: exports.SlpInputSource.FILE,\n        filePath: input\n      };\n    } else if (input instanceof Buffer) {\n      this.input = {\n        source: exports.SlpInputSource.BUFFER,\n        buffer: input\n      };\n    } else if (input instanceof ArrayBuffer) {\n      this.input = {\n        source: exports.SlpInputSource.BUFFER,\n        buffer: Buffer.from(input)\n      };\n    } else {\n      throw new Error(\"Cannot create SlippiGame with input of that type\");\n    } // Set up stats calculation\n\n    this.statsComputer = new Stats(opts);\n    this.statsComputer.register(this.actionsComputer, this.comboComputer, this.conversionComputer, this.inputComputer, this.stockComputer, this.targetBreakComputer);\n    this.parser = new SlpParser();\n    this.parser.on(exports.SlpParserEvent.SETTINGS, settings => {\n      this.statsComputer.setup(settings);\n    }); // Use finalized frames for stats computation\n\n    this.parser.on(exports.SlpParserEvent.FINALIZED_FRAME, frame => {\n      this.statsComputer.addFrame(frame);\n    });\n  }\n  _process(shouldStop = () => false, file) {\n    if (this.parser.getGameEnd() !== null) {\n      return;\n    }\n    const slpfile = file != null ? file : openSlpFile(this.input); // Generate settings from iterating through file\n\n    this.readPosition = iterateEvents(slpfile, (command, payload) => {\n      if (!payload) {\n        // If payload is falsy, keep iterating. The parser probably just doesn't know\n        // about this command yet\n        return false;\n      }\n      this.parser.handleCommand(command, payload);\n      return shouldStop(command, payload);\n    }, this.readPosition);\n    if (!file) {\n      closeSlpFile(slpfile);\n    }\n  }\n  /**\r\n   * Gets the game settings, these are the settings that describe the starting state of\r\n   * the game such as characters, stage, etc.\r\n   */\n\n  getSettings() {\n    // Settings is only complete after post-frame update\n    this._process(() => this.parser.getSettings() !== null);\n    return this.parser.getSettings();\n  }\n  getItems() {\n    this._process();\n    return this.parser.getItems();\n  }\n  getLatestFrame() {\n    this._process();\n    return this.parser.getLatestFrame();\n  }\n  getGameEnd(options = {}) {\n    if (options != null && options.skipProcessing) {\n      // Read game end block directly\n      const slpfile = openSlpFile(this.input);\n      const gameEnd = getGameEnd(slpfile);\n      closeSlpFile(slpfile);\n      return gameEnd;\n    }\n    this._process();\n    return this.parser.getGameEnd();\n  }\n  getFrames() {\n    this._process();\n    return this.parser.getFrames();\n  }\n  getRollbackFrames() {\n    this._process();\n    return this.parser.getRollbackFrames();\n  }\n  getGeckoList() {\n    this._process(() => this.parser.getGeckoList() !== null);\n    return this.parser.getGeckoList();\n  }\n  getStats() {\n    if (this.finalStats) {\n      return this.finalStats;\n    }\n    this._process();\n    const settings = this.parser.getSettings();\n    if (!settings) {\n      return null;\n    } // Finish processing if we're not up to date\n\n    this.statsComputer.process();\n    const inputs = this.inputComputer.fetch();\n    const stocks = this.stockComputer.fetch();\n    const conversions = this.conversionComputer.fetch();\n    const playableFrameCount = this.parser.getPlayableFrameCount();\n    const overall = generateOverallStats({\n      settings,\n      inputs,\n      conversions,\n      playableFrameCount\n    });\n    const gameEnd = this.parser.getGameEnd();\n    const gameComplete = gameEnd !== null;\n    const stats = {\n      lastFrame: this.parser.getLatestFrameNumber(),\n      playableFrameCount,\n      stocks: stocks,\n      conversions: conversions,\n      combos: this.comboComputer.fetch(),\n      actionCounts: this.actionsComputer.fetch(),\n      overall: overall,\n      gameComplete\n    };\n    if (gameComplete) {\n      // If the game is complete, store a cached version of stats because it should not\n      // change anymore. Ideally the statsCompuer.process and fetch functions would simply do no\n      // work in this case instead but currently the conversions fetch function,\n      // generateOverallStats, and maybe more are doing work on every call.\n      this.finalStats = stats;\n    }\n    return stats;\n  }\n  getStadiumStats() {\n    this._process();\n    const settings = this.parser.getSettings();\n    if (!settings) {\n      return null;\n    }\n    const latestFrame = this.parser.getLatestFrame();\n    const players = latestFrame == null ? void 0 : latestFrame.players;\n    if (!players) {\n      return null;\n    }\n    this.statsComputer.process();\n    switch (settings.gameMode) {\n      case exports.GameMode.TARGET_TEST:\n        return {\n          type: \"target-test\",\n          targetBreaks: this.targetBreakComputer.fetch()\n        };\n      case exports.GameMode.HOME_RUN_CONTEST:\n        const distanceInfo = extractDistanceInfoFromFrame(settings, latestFrame);\n        if (!distanceInfo) {\n          return null;\n        }\n        return {\n          type: \"home-run-contest\",\n          distance: distanceInfo.distance,\n          units: distanceInfo.units\n        };\n      default:\n        return null;\n    }\n  }\n  getMetadata() {\n    if (this.metadata) {\n      return this.metadata;\n    }\n    const slpfile = openSlpFile(this.input);\n    this.metadata = getMetadata(slpfile);\n    closeSlpFile(slpfile);\n    return this.metadata;\n  }\n  getFilePath() {\n    var _this$input$filePath;\n    if (this.input.source !== exports.SlpInputSource.FILE) {\n      return null;\n    }\n    return (_this$input$filePath = this.input.filePath) != null ? _this$input$filePath : null;\n  }\n  getWinners() {\n    // Read game end block directly\n    const slpfile = openSlpFile(this.input);\n    const gameEnd = getGameEnd(slpfile);\n    this._process(() => this.parser.getSettings() !== null, slpfile);\n    const settings = this.parser.getSettings();\n    if (!gameEnd || !settings) {\n      // Technically using the final post frame updates, it should be possible to compute winners for\n      // replays without a gameEnd message. But I'll leave this here anyway\n      closeSlpFile(slpfile);\n      return [];\n    } // If we went to time, let's fetch the post frame updates to compute the winner\n\n    let finalPostFrameUpdates = [];\n    if (gameEnd.gameEndMethod === exports.GameEndMethod.TIME) {\n      finalPostFrameUpdates = extractFinalPostFrameUpdates(slpfile);\n    }\n    closeSlpFile(slpfile);\n    return getWinners(gameEnd, settings, finalPostFrameUpdates);\n  }\n}\nexports.ActionsComputer = ActionsComputer;\nexports.ComboComputer = ComboComputer;\nexports.ConsoleCommunication = ConsoleCommunication;\nexports.ConsoleConnection = ConsoleConnection;\nexports.ConversionComputer = ConversionComputer;\nexports.DolphinConnection = DolphinConnection;\nexports.InputComputer = InputComputer;\nexports.MAX_ROLLBACK_FRAMES = MAX_ROLLBACK_FRAMES;\nexports.NETWORK_MESSAGE = NETWORK_MESSAGE;\nexports.SlippiGame = SlippiGame;\nexports.SlpFile = SlpFile;\nexports.SlpFileWriter = SlpFileWriter;\nexports.SlpParser = SlpParser;\nexports.SlpStream = SlpStream;\nexports.Stats = Stats;\nexports.StockComputer = StockComputer;\nexports.TargetBreakComputer = TargetBreakComputer;\nexports.Timers = Timers;\nexports.animations = animationUtils;\nexports.calcDamageTaken = calcDamageTaken;\nexports.characters = characterUtils;\nexports.closeSlpFile = closeSlpFile;\nexports.didLoseStock = didLoseStock;\nexports.extractFinalPostFrameUpdates = extractFinalPostFrameUpdates;\nexports.frameToGameTimer = frameToGameTimer;\nexports.generateOverallStats = generateOverallStats;\nexports.getGameEnd = getGameEnd;\nexports.getMetadata = getMetadata;\nexports.getSinglesPlayerPermutationsFromSettings = getSinglesPlayerPermutationsFromSettings;\nexports.isCommandGrabbed = isCommandGrabbed;\nexports.isDamaged = isDamaged;\nexports.isDead = isDead;\nexports.isDown = isDown;\nexports.isGrabbed = isGrabbed;\nexports.isInControl = isInControl;\nexports.isTeching = isTeching;\nexports.iterateEvents = iterateEvents;\nexports.moves = moveUtils;\nexports.openSlpFile = openSlpFile;\nexports.parseMessage = parseMessage;\nexports.stages = stageUtils;","map":{"version":3,"names":["Object","defineProperty","exports","value","lodash","require","events","dateFns","fs","stream","ubjson","net","inject","iconv","path","semver","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","fs__default","net__default","inject__default","iconv__default","path__default","semver__default","getDeathDirection","actionStateId","animationUtils","__proto__","characters","name","shortName","colors","DEFAULT_COLOR","UnknownCharacter","id","generateCharacterInfo","info","_info$shortName","_info$colors","getAllCharacters","entries","map","data","parseInt","sort","a","b","getCharacterInfo","externalCharacterId","toString","getCharacterShortName","character","getCharacterName","getCharacterColorName","characterColor","color","characterUtils","moveNames","UnknownMove","getMoveInfo","moveId","moveName","getMoveShortName","move","getMoveName","moveUtils","stageNames","UnknownStage","getStageInfo","stageId","stageName","getStageName","stage","stageUtils","Character","Stage","State","Timers","PUNISH_RESET_FRAMES","RECOVERY_RESET_FRAMES","COMBO_STRING_RESET_FRAMES","getSinglesPlayerPermutationsFromSettings","settings","players","length","playerIndex","opponentIndex","didLoseStock","frame","prevFrame","stocksRemaining","isInControl","state","ground","GROUNDED_CONTROL_START","GROUNDED_CONTROL_END","squat","SQUAT_START","SQUAT_END","groundAttack","GROUND_ATTACK_START","GROUND_ATTACK_END","isGrab","GRAB","isTeching","TECH_START","TECH_END","isDown","DOWN_START","DOWN_END","isDamaged","DAMAGE_START","DAMAGE_END","DAMAGE_FALL","JAB_RESET_UP","JAB_RESET_DOWN","isGrabbed","CAPTURE_START","CAPTURE_END","isCommandGrabbed","COMMAND_GRAB_RANGE1_START","COMMAND_GRAB_RANGE1_END","COMMAND_GRAB_RANGE2_START","COMMAND_GRAB_RANGE2_END","BARREL_WAIT","isDead","DYING_START","DYING_END","calcDamageTaken","_frame$percent","_prevFrame$percent","percent","prevPercent","dashDanceAnimations","DASH","TURN","ActionsComputer","constructor","playerPermutations","Array","Map","setup","indices","playerCounts","wavedashCount","wavelandCount","airDodgeCount","dashDanceCount","spotDodgeCount","ledgegrabCount","rollCount","lCancelCount","success","fail","attackCount","jab1","jab2","jab3","jabm","dash","ftilt","utilt","dtilt","fsmash","usmash","dsmash","nair","fair","bair","uair","dair","grabCount","throwCount","up","forward","back","down","groundTechCount","away","in","neutral","wallTechCount","playerState","animations","actionFrameCounters","set","processFrame","handleActionCompute","fetch","from","values","val","isMissGroundTech","animation","TECH_MISS_DOWN","TECH_MISS_UP","isRolling","ROLL_BACKWARD","ROLL_FORWARD","isGrabAction","THROW_DOWN","DASH_GRAB","isGrabbing","isAerialAttack","AERIAL_ATTACK_START","AERIAL_ATTACK_END","isForwardTilt","ATTACK_FTILT_START","ATTACK_FTILT_END","isForwardSmash","ATTACK_FSMASH_START","ATTACK_FSMASH_END","playerFrame","post","opponentFrame","incrementCount","field","condition","current","currentAnimation","push","currentFrameCounter","actionStateCounter","last3Frames","slice","prevAnimation","prevFrameCounter","isNewAction","didDashDance","isEqual","SPOT_DODGE","AIR_DODGE","CLIFF_CATCH","ATTACK_DASH","ATTACK_JAB1","ATTACK_JAB2","ATTACK_JAB3","ATTACK_JABM","ATTACK_UTILT","ATTACK_DTILT","ATTACK_USMASH","ATTACK_DSMASH","AERIAL_NAIR","AERIAL_FAIR","AERIAL_BAIR","AERIAL_UAIR","AERIAL_DAIR","internalCharacterId","GNW_JAB1","GNW_JABM","GNW_DTILT","GNW_FSMASH","GNW_NAIR","GNW_BAIR","GNW_UAIR","PEACH_FSMASH1","PEACH_FSMASH2","PEACH_FSMASH3","THROW_UP","THROW_FORWARD","THROW_BACK","opponentDir","positionX","facingOpponent","facingDirection","FORWARD_TECH","BACKWARD_TECH","NEUTRAL_TECH","WALL_TECH","MISSED_WALL_TECH","lCancelStatus","handleActionWavedash","counts","last","isSpecialLanding","LANDING_FALL_SPECIAL","isAcceptablePrevious","isWavedashInitiationAnimation","isPossibleWavedash","recentFrames","recentAnimations","keyBy","size","ACTION_KNEE_BEND","isAboveMin","CONTROLLED_JUMP_START","isBelowMax","CONTROLLED_JUMP_END","ComboEvent","ComboComputer","EventEmitter","args","combos","combo","resetCounter","lastHitAnimation","event","allFrames","handleComboCompute","emit","frames","currentFrameNumber","prevFrameNumber","prevPlayerFrame","prevOpponentFrame","oppActionStateId","opntIsDamaged","opntIsGrabbed","opntIsCommandGrabbed","opntDamageTaken","actionChangedSinceHit","actionCounter","prevActionCounter","actionFrameCounterReset","comboStarted","_prevOpponentFrame$pe","_opponentFrame$percen","startFrame","endFrame","startPercent","currentPercent","endPercent","moves","didKill","lastHitBy","lastAttackLanded","hitCount","damage","COMBO_EXTEND","COMBO_START","opntIsTeching","opntIsDowned","opntDidLoseStock","opntIsDying","_opponentFrame$percen2","shouldTerminate","_prevOpponentFrame$pe2","COMBO_END","ConversionComputer","conversions","metadata","lastEndFrameByOppIdx","conversion","terminated","handleConversionCompute","_populateConversionTypes","conversionsToHandle","filter","openingType","groupedConversions","groupBy","sortedConversions","orderBy","isTrade","lastMove","oppEndFrame","isCounterAttack","opntInControl","shouldStartResetCounter","shouldContinueResetCounter","Command","GameMode","Language","TimerType","ItemSpawnType","EnabledItemType","GameEndMethod","Frames","JoystickRegion","InputComputer","inputCount","joystickInputCount","cstickInputCount","buttonInputCount","triggerInputCount","handleInputCompute","pre","FIRST_PLAYABLE","invertedPreviousButtons","physicalButtons","currentButtons","buttonChanges","newInputsPressed","countSetBits","prevAnalogRegion","getJoystickRegion","joystickX","joystickY","currentAnalogRegion","DZ","prevCstickRegion","cStickX","cStickY","currentCstickRegion","physicalLTrigger","physicalRTrigger","x","bits","count","y","region","NE","SE","SW","NW","N","E","S","W","generateOverallStats","inputs","playableFrameCount","inputsByPlayer","originalConversions","conversionsByPlayer","conv","_conv$moves$","conversionsByPlayerByOpening","mapValues","gameMinutes","overall","player","playerInputs","inputCounts","buttons","triggers","cstick","joystick","total","conversionCount","successfulConversionCount","opponentIndices","opp","isTeams","teamId","totalDamage","killCount","successfulConversions","getRatio","inputsPerMinute","digitalInputsPerMinute","openingsPerKill","damagePerOpening","neutralWinRatio","getOpeningRatio","counterHitRatio","beneficialTradeRatio","getBeneficialTradeRatio","ratio","type","openings","opponentOpenings","flatten","playerTrades","opponentTrades","benefitsPlayer","zippedTrades","zip","conversionPair","playerConversion","first","opponentConversion","playerDamage","opponentDamage","defaultOptions","processOnTheFly","Stats","options","lastProcessedFrame","allComputers","assign","v","comp","register","computer","process","i","FIRST","isCompletedFrame","addFrame","playerPostFrame","StockComputer","stocks","stock","handleStockCompute","isPlayerDead","deathAnimation","_prevPlayerFrame$perc","_playerFrame$percent","exists","TARGET_ITEM_TYPE_ID","TargetBreakComputer","targetBreaks","isTargetTestGame","gameMode","TARGET_TEST","handleTargetBreak","_frames$currentFrameN","_frames$currentFrameN2","_frames$currentFrameN3","_frames$prevFrameNumb","_frames$prevFrameNumb2","_frames$prevFrameNumb3","_frames$Frames$FIRST$","_frames$Frames$FIRST","_frames$Frames$FIRST$2","targets","items","item","typeId","target","spawnId","frameDestroyed","positionY","currentTargets","previousTargets","currentTargetIds","previousTargetIds","brokenTargetIds","includes","targetBreak","find","frameToGameTimer","timerType","startingTimerSeconds","DECREASING","centiseconds","Math","ceil","date","Date","format","INCREASING","floor","CommunicationType","ConsoleCommunication","receiveBuf","Buffer","messages","receive","concat","msgSize","readUInt32BE","ubjsonData","decode","getReceiveBuffer","getMessages","toReturn","genHandshakeOut","cursor","clientToken","isRealtime","clientTokenBuf","writeUInt32BE","message","HANDSHAKE","payload","Uint8Array","buf","encode","optimizeArrays","msg","byteLength","ConnectionEvent","ConnectionStatus","Ports","NETWORK_MESSAGE","DEFAULT_CONNECTION_TIMEOUT_MS","CommunicationState","defaultConnectionDetails","consoleNick","gameDataCursor","version","consoleConnectionOptions","autoReconnect","ConsoleConnection","ipAddress","port","connectionStatus","DISCONNECTED","connDetails","client","connection","shouldReconnect","DEFAULT","getStatus","getSettings","getDetails","connect","ip","timeout","_connectOnPort","reconnect","host","_setStatus","CONNECTING","consoleComms","initialDelay","maxDelay","strategy","failAfter","Infinity","_this$connDetails$cli","CONNECT","commState","INITIAL","on","_getInitialCommState","console","log","CONNECTED","LEGACY","_handleReplayData","err","error","prevDataBuf","rcvData","destroy","ERROR","_processMessage","warn","handshakeMsgOut","write","setConnectingStatus","RECONNECT_WAIT","disconnect","openingBytes","dataStart","equals","NORMAL","MESSAGE","KEEP_ALIVE","fakeKeepAlive","REPLAY","readPos","pos","cmp","compare","forcePos","Error","nextPos","nick","nintendontVersion","tokenBuf","DATA","status","STATUS_CHANGE","MAX_PEERS","DolphinMessageType","DolphinConnection","gameCursor","nickname","peer","enet","Promise","resolve","then","createClient","peers","channels","address","newPeer","ping","request","packet","Packet","JSON","stringify","PACKET_FLAG","RELIABLE","send","dataString","parse","dolphin_closed","CONNECT_REPLY","GAME_EVENT","_updateCursor","gameData","START_GAME","END_GAME","next_cursor","toHalfwidth","str","convertChar","charCode","ret","char","charCodeAt","String","fromCharCode","SlpInputSource","getRef","input","source","FILE","filePath","fd","openSync","fileDescriptor","BUFFER","buffer","readRef","ref","offset","position","readSync","copy","getLenRef","fileStats","fstatSync","openSlpFile","rawDataPosition","getRawDataPosition","rawDataLength","getRawDataLength","metadataPosition","metadataLength","getMetadataLength","messageSizes","getMessageSizes","closeSlpFile","file","closeSync","fileSize","rawDataLen","len","MESSAGE_SIZES","payloadLength","messageSizesBuffer","command","getEnabledItems","view","offsets","enabledItems","reduce","acc","byteOffset","index","byte","readUint8","getGameInfoBlock","gameBitfield1","gameBitfield2","gameBitfield3","gameBitfield4","bombRainEnabled","itemSpawnBehavior","readInt8","selfDestructScoreValue","itemSpawnBitfield1","itemSpawnBitfield2","itemSpawnBitfield3","itemSpawnBitfield4","itemSpawnBitfield5","damageRatio","readFloat","iterateEvents","slpFile","callback","startPos","readPosition","stopReadingAt","commandPayloadBuffers","splitMessageBuffer","commandByteBuffer","_commandByteBuffer$","commandByte","undefined","advanceAmount","SPLIT_MESSAGE","_readUint","_readUint2","DataView","readUint16","isLastMessage","readBool","internalCommand","appendBuf","mergedBuf","_splitMessageBuffer$","parsedPayload","parseMessage","shouldStop","GAME_START","getPlayerObject","cfOffset","dashback","readUint32","shieldDrop","controllerFix","nametagLength","nametagOffset","nametagStart","nametagBuf","nameTagString","split","shift","nametag","displayNameLength","displayNameOffset","displayNameStart","displayNameBuf","displayNameString","displayName","connectCodeLength","connectCodeOffset","connectCodeStart","connectCodeBuf","connectCodeString","connectCode","userIdLength","userIdOffset","userIdStart","userIdBuf","userIdString","userId","characterId","startStocks","teamShade","handicap","staminaMode","Boolean","silentCharacter","lowGravity","invisible","blackStockIcon","metal","startOnAngelPlatform","rumbleEnabled","cpuLevel","offenseRatio","defenseRatio","modelScale","matchIdLength","matchIdStart","matchIdBuf","matchIdString","matchId","slpVersion","inGameMode","friendlyFireEnabled","scene","language","gameInfoBlock","randomSeed","isPAL","isFrozenPS","matchInfo","gameNumber","tiebreakerNumber","FRAME_START","readInt32","seed","sceneFrameCounter","PRE_FRAME_UPDATE","isFollower","trigger","rawJoystickX","POST_FRAME_UPDATE","selfInducedSpeeds","airX","attackX","attackY","groundX","shieldSize","currentComboCount","miscActionState","isAirborne","lastGroundId","jumpsRemaining","hurtboxCollisionState","hitlagRemaining","animationIndex","ITEM_UPDATE","velocityX","velocityY","damageTaken","expirationTimer","missileType","turnipFace","chargeShotLaunched","chargePower","owner","FRAME_BOOKEND","latestFinalizedFrame","GAME_END","placements","gameEndMethod","lrasInitiatorIndex","GECKO_LIST","codes","_readUint3","word1","codetype","_readUint4","lineCount","_readUint5","byteLen","contents","canReadFromView","viewLength","getFloat32","getInt32","getInt8","getUint32","getUint16","bitmask","getUint8","getMetadata","ex","getGameEnd","gameEndPayloadSize","gameEndSize","gameEndPosition","gameEndMessage","extractFinalPostFrameUpdates","postFramePayloadSize","frameBookendPayloadSize","postFrameSize","frameBookendSize","frameNum","postFramePosition","postFrameUpdates","postFrameMessage","unshift","SlpStreamMode","defaultSettings$1","suppressErrors","mode","AUTO","SlpStreamEvent","SlpStream","Writable","slpOptions","opts","gameEnded","payloadSizes","previousBuffer","restart","_write","newData","encoding","dataView","payloadSize","_this$payloadSizes$ge","remainingLen","MANUAL","payloadPtr","payloadDataView","payloadLen","_processCommand","_writeCommand","entirePayload","payloadBuf","bufToWrite","RAW","processReceiveCommands","COMMAND","_this$payloadSizes$ge2","DEFAULT_NICKNAME","SlpFile","slpStream","fileStream","usesExternalStream","consoleNickname","startTime","lastFrame","_setupListeners","_initializeNewGame","setMetadata","chunk","_onCommand","characterUsage","names","netplay","code","prevPlayer","curCharFrames","streamListener","writeSync","createUInt32Buffer","removeListener","end","createWriteStream","header","_final","footer","startTimeStr","toISOString","createInt32Buffer","usage","internalId","number","alloc","writeInt32BE","getNewFilePath","folder","join","defaultSettings","outputFiles","folderPath","newFilename","SlpFileWriterEvent","SlpFileWriter","currentFile","_writePayload","_handleNewGame","_handleEndGame","getCurrentFilename","endCurrentFile","updateSettings","NEW_FILE","FILE_COMPLETE","RollbackCounter","rollbackFrames","rollbackFrameCount","rollbackPlayerIdx","lastFrameWasRollback","currentRollbackLength","rollbackLengths","checkIfRollbackFrame","currentFrame","playerIdx","getFrames","getCount","getLengths","ITEM_SETTINGS_BIT_COUNT","MAX_ROLLBACK_FRAMES","SlpParserEvent","defaultSlpParserOptions","strict","SlpParser","rollbackCounter","gameEnd","latestFrameIndex","settingsComplete","lastFinalizedFrame","geckoList","handleCommand","_handleGameStart","_handleFrameStart","_handlePostFrameUpdate","_handleFrameUpdate","_handleItemUpdate","_handleFrameBookend","_handleGameEnd","_handleGeckoList","reset","getLatestFrameNumber","_this$latestFrameInde","getPlayableFrameCount","getLatestFrame","frameIndex","indexToUse","getItems","_this$settings","_this$settings2","OFF","itemBitfield","getRollbackFrames","lengths","getFrame","num","getGeckoList","_finalizeFrames","END","gte","_completeSettings","playersByIndex","location","wasRolledback","ROLLBACK_FRAME","lte","FRAME","_this$frames$currentF","_this$frames$currentF2","validLatestFrame","ONLINE","frameToFinalize","playerFrameInfo","preOrPost","FINALIZED_FRAME","SETTINGS","getWinners","finalPostFrameUpdates","_players$find$teamId","_players$find2","NO_CONTEST","UNRESOLVED","_players$find","winnerIndex","TIME","nonFollowerUpdates","pfu","p1","p2","p1Health","trunc","p2Health","firstPosition","placement","winningTeam","_players$find$teamId2","_players$find3","SANDBAG_INTERNAL_ID","FEET_CONVERSION_FACTOR","METERS_CONVERSION_FACTOR","positionToHomeRunDistance","distance","units","score","fround","round","max","extractDistanceInfoFromFrame","_sandbagLastFrame$pos","sandbagLastFrame","JAPANESE","SlippiGame","finalStats","parser","actionsComputer","conversionComputer","comboComputer","stockComputer","inputComputer","targetBreakComputer","statsComputer","ArrayBuffer","_process","slpfile","skipProcessing","getStats","gameComplete","stats","actionCounts","getStadiumStats","latestFrame","HOME_RUN_CONTEST","distanceInfo","getFilePath","_this$input$filePath","stages"],"sources":["/Users/jaredcortez/node_modules/@slippi/slippi-js/dist/slippi-js.cjs.development.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar lodash = require('lodash');\nvar events = require('events');\nvar dateFns = require('date-fns');\nvar fs = require('fs');\nvar stream = require('stream');\nvar ubjson = require('@shelacek/ubjson');\nvar net = require('net');\nvar inject = require('reconnect-core');\nvar iconv = require('iconv-lite');\nvar path = require('path');\nvar semver = require('semver');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return n;\n}\n\nvar fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);\nvar net__default = /*#__PURE__*/_interopDefaultLegacy(net);\nvar inject__default = /*#__PURE__*/_interopDefaultLegacy(inject);\nvar iconv__default = /*#__PURE__*/_interopDefaultLegacy(iconv);\nvar path__default = /*#__PURE__*/_interopDefaultLegacy(path);\nvar semver__default = /*#__PURE__*/_interopDefaultLegacy(semver);\n\n// eslint-disable-next-line\nfunction getDeathDirection(actionStateId) {\n  if (actionStateId > 0xa) {\n    return null;\n  }\n\n  switch (actionStateId) {\n    case 0:\n      return \"down\";\n\n    case 1:\n      return \"left\";\n\n    case 2:\n      return \"right\";\n\n    default:\n      return \"up\";\n  }\n}\n\nvar animationUtils = {\n  __proto__: null,\n  getDeathDirection: getDeathDirection\n};\n\nvar characters = {\n\t\"0\": {\n\tname: \"Captain Falcon\",\n\tshortName: \"Falcon\",\n\tcolors: [\n\t\t\"Black\",\n\t\t\"Red\",\n\t\t\"White\",\n\t\t\"Green\",\n\t\t\"Blue\"\n\t]\n},\n\t\"1\": {\n\tname: \"Donkey Kong\",\n\tshortName: \"DK\",\n\tcolors: [\n\t\t\"Black\",\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"Green\"\n\t]\n},\n\t\"2\": {\n\tname: \"Fox\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"Green\"\n\t]\n},\n\t\"3\": {\n\tname: \"Mr. Game & Watch\",\n\tshortName: \"G&W\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"Green\"\n\t]\n},\n\t\"4\": {\n\tname: \"Kirby\",\n\tcolors: [\n\t\t\"Yellow\",\n\t\t\"Blue\",\n\t\t\"Red\",\n\t\t\"Green\",\n\t\t\"White\"\n\t]\n},\n\t\"5\": {\n\tname: \"Bowser\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"Black\"\n\t]\n},\n\t\"6\": {\n\tname: \"Link\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"Black\",\n\t\t\"White\"\n\t]\n},\n\t\"7\": {\n\tname: \"Luigi\",\n\tcolors: [\n\t\t\"White\",\n\t\t\"Blue\",\n\t\t\"Red\"\n\t]\n},\n\t\"8\": {\n\tname: \"Mario\",\n\tcolors: [\n\t\t\"Yellow\",\n\t\t\"Black\",\n\t\t\"Blue\",\n\t\t\"Green\"\n\t]\n},\n\t\"9\": {\n\tname: \"Marth\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Green\",\n\t\t\"Black\",\n\t\t\"White\"\n\t]\n},\n\t\"10\": {\n\tname: \"Mewtwo\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"Green\"\n\t]\n},\n\t\"11\": {\n\tname: \"Ness\",\n\tcolors: [\n\t\t\"Yellow\",\n\t\t\"Blue\",\n\t\t\"Green\"\n\t]\n},\n\t\"12\": {\n\tname: \"Peach\",\n\tcolors: [\n\t\t\"Daisy\",\n\t\t\"White\",\n\t\t\"Blue\",\n\t\t\"Green\"\n\t]\n},\n\t\"13\": {\n\tname: \"Pikachu\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Party Hat\",\n\t\t\"Cowboy Hat\"\n\t]\n},\n\t\"14\": {\n\tname: \"Ice Climbers\",\n\tshortName: \"ICs\",\n\tcolors: [\n\t\t\"Green\",\n\t\t\"Orange\",\n\t\t\"Red\"\n\t]\n},\n\t\"15\": {\n\tname: \"Jigglypuff\",\n\tshortName: \"Puff\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"Headband\",\n\t\t\"Crown\"\n\t]\n},\n\t\"16\": {\n\tname: \"Samus\",\n\tcolors: [\n\t\t\"Pink\",\n\t\t\"Black\",\n\t\t\"Green\",\n\t\t\"Purple\"\n\t]\n},\n\t\"17\": {\n\tname: \"Yoshi\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"Yellow\",\n\t\t\"Pink\",\n\t\t\"Cyan\"\n\t]\n},\n\t\"18\": {\n\tname: \"Zelda\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"Green\",\n\t\t\"White\"\n\t]\n},\n\t\"19\": {\n\tname: \"Sheik\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"Green\",\n\t\t\"White\"\n\t]\n},\n\t\"20\": {\n\tname: \"Falco\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"Green\"\n\t]\n},\n\t\"21\": {\n\tname: \"Young Link\",\n\tshortName: \"YLink\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"White\",\n\t\t\"Black\"\n\t]\n},\n\t\"22\": {\n\tname: \"Dr. Mario\",\n\tshortName: \"Doc\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"Green\",\n\t\t\"Black\"\n\t]\n},\n\t\"23\": {\n\tname: \"Roy\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"Green\",\n\t\t\"Yellow\"\n\t]\n},\n\t\"24\": {\n\tname: \"Pichu\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"Green\"\n\t]\n},\n\t\"25\": {\n\tname: \"Ganondorf\",\n\tshortName: \"Ganon\",\n\tcolors: [\n\t\t\"Red\",\n\t\t\"Blue\",\n\t\t\"Green\",\n\t\t\"Purple\"\n\t]\n},\n\t\"26\": {\n\tname: \"Master Hand\"\n},\n\t\"27\": {\n\tname: \"Wireframe (Male)\"\n},\n\t\"28\": {\n\tname: \"Wireframe (Female)\"\n},\n\t\"29\": {\n\tname: \"Gigabowser\"\n},\n\t\"30\": {\n\tname: \"Crazy Hand\"\n},\n\t\"31\": {\n\tname: \"Sandbag\"\n},\n\t\"32\": {\n\tname: \"Popo\"\n}\n};\n\nconst DEFAULT_COLOR = \"Default\";\nconst UnknownCharacter = {\n  id: -1,\n  name: \"Unknown Character\",\n  shortName: \"Unknown\",\n  colors: [DEFAULT_COLOR]\n};\n\nfunction generateCharacterInfo(id, info) {\n  var _info$shortName, _info$colors;\n\n  if (!info) {\n    return UnknownCharacter;\n  }\n\n  return {\n    id,\n    name: info.name,\n    shortName: (_info$shortName = info.shortName) != null ? _info$shortName : info.name,\n    colors: [DEFAULT_COLOR, ...((_info$colors = info.colors) != null ? _info$colors : [])]\n  };\n}\n\nfunction getAllCharacters() {\n  return Object.entries(characters).map(([id, data]) => generateCharacterInfo(parseInt(id, 10), data)).sort((a, b) => a.id - b.id);\n}\nfunction getCharacterInfo(externalCharacterId) {\n  const data = characters[externalCharacterId.toString()];\n  return generateCharacterInfo(externalCharacterId, data);\n}\nfunction getCharacterShortName(externalCharacterId) {\n  const character = getCharacterInfo(externalCharacterId);\n  return character.shortName;\n}\nfunction getCharacterName(externalCharacterId) {\n  const character = getCharacterInfo(externalCharacterId);\n  return character.name;\n} // Return a human-readable color from a characterCode.\n\nfunction getCharacterColorName(externalCharacterId, characterColor) {\n  const character = getCharacterInfo(externalCharacterId);\n  const color = character.colors[characterColor];\n\n  if (color) {\n    return color;\n  }\n\n  return DEFAULT_COLOR;\n}\n\nvar characterUtils = {\n  __proto__: null,\n  UnknownCharacter: UnknownCharacter,\n  getAllCharacters: getAllCharacters,\n  getCharacterInfo: getCharacterInfo,\n  getCharacterShortName: getCharacterShortName,\n  getCharacterName: getCharacterName,\n  getCharacterColorName: getCharacterColorName\n};\n\nvar moveNames = {\n\t\"1\": {\n\tname: \"Miscellaneous\",\n\tshortName: \"misc\"\n},\n\t\"2\": {\n\tname: \"Jab\",\n\tshortName: \"jab\"\n},\n\t\"3\": {\n\tname: \"Jab\",\n\tshortName: \"jab\"\n},\n\t\"4\": {\n\tname: \"Jab\",\n\tshortName: \"jab\"\n},\n\t\"5\": {\n\tname: \"Rapid Jabs\",\n\tshortName: \"rapid-jabs\"\n},\n\t\"6\": {\n\tname: \"Dash Attack\",\n\tshortName: \"dash\"\n},\n\t\"7\": {\n\tname: \"Forward Tilt\",\n\tshortName: \"ftilt\"\n},\n\t\"8\": {\n\tname: \"Up Tilt\",\n\tshortName: \"utilt\"\n},\n\t\"9\": {\n\tname: \"Down Tilt\",\n\tshortName: \"dtilt\"\n},\n\t\"10\": {\n\tname: \"Forward Smash\",\n\tshortName: \"fsmash\"\n},\n\t\"11\": {\n\tname: \"Up Smash\",\n\tshortName: \"usmash\"\n},\n\t\"12\": {\n\tname: \"Down Smash\",\n\tshortName: \"dsmash\"\n},\n\t\"13\": {\n\tname: \"Neutral Air\",\n\tshortName: \"nair\"\n},\n\t\"14\": {\n\tname: \"Forward Air\",\n\tshortName: \"fair\"\n},\n\t\"15\": {\n\tname: \"Back Air\",\n\tshortName: \"bair\"\n},\n\t\"16\": {\n\tname: \"Up Air\",\n\tshortName: \"uair\"\n},\n\t\"17\": {\n\tname: \"Down Air\",\n\tshortName: \"dair\"\n},\n\t\"18\": {\n\tname: \"Neutral B\",\n\tshortName: \"neutral-b\"\n},\n\t\"19\": {\n\tname: \"Side B\",\n\tshortName: \"side-b\"\n},\n\t\"20\": {\n\tname: \"Up B\",\n\tshortName: \"up-b\"\n},\n\t\"21\": {\n\tname: \"Down B\",\n\tshortName: \"down-b\"\n},\n\t\"50\": {\n\tname: \"Getup Attack\",\n\tshortName: \"getup\"\n},\n\t\"51\": {\n\tname: \"Getup Attack (Slow)\",\n\tshortName: \"getup-slow\"\n},\n\t\"52\": {\n\tname: \"Grab Pummel\",\n\tshortName: \"pummel\"\n},\n\t\"53\": {\n\tname: \"Forward Throw\",\n\tshortName: \"fthrow\"\n},\n\t\"54\": {\n\tname: \"Back Throw\",\n\tshortName: \"bthrow\"\n},\n\t\"55\": {\n\tname: \"Up Throw\",\n\tshortName: \"uthrow\"\n},\n\t\"56\": {\n\tname: \"Down Throw\",\n\tshortName: \"dthrow\"\n},\n\t\"61\": {\n\tname: \"Edge Attack (Slow)\",\n\tshortName: \"edge-slow\"\n},\n\t\"62\": {\n\tname: \"Edge Attack\",\n\tshortName: \"edge\"\n}\n};\n\nconst UnknownMove = {\n  id: -1,\n  name: \"Unknown Move\",\n  shortName: \"unknown\"\n};\nfunction getMoveInfo(moveId) {\n  const moveName = moveNames[moveId.toString()];\n\n  if (!moveName) {\n    return UnknownMove;\n  }\n\n  return {\n    id: moveId,\n    name: moveName.name,\n    shortName: moveName.shortName\n  };\n}\nfunction getMoveShortName(moveId) {\n  const move = getMoveInfo(moveId);\n  return move.shortName;\n}\nfunction getMoveName(moveId) {\n  const move = getMoveInfo(moveId);\n  return move.name;\n}\n\nvar moveUtils = {\n  __proto__: null,\n  UnknownMove: UnknownMove,\n  getMoveInfo: getMoveInfo,\n  getMoveShortName: getMoveShortName,\n  getMoveName: getMoveName\n};\n\nvar stageNames = {\n\t\"2\": \"Fountain of Dreams\",\n\t\"3\": \"Pokémon Stadium\",\n\t\"4\": \"Princess Peach's Castle\",\n\t\"5\": \"Kongo Jungle\",\n\t\"6\": \"Brinstar\",\n\t\"7\": \"Corneria\",\n\t\"8\": \"Yoshi's Story\",\n\t\"9\": \"Onett\",\n\t\"10\": \"Mute City\",\n\t\"11\": \"Rainbow Cruise\",\n\t\"12\": \"Jungle Japes\",\n\t\"13\": \"Great Bay\",\n\t\"14\": \"Hyrule Temple\",\n\t\"15\": \"Brinstar Depths\",\n\t\"16\": \"Yoshi's Island\",\n\t\"17\": \"Green Greens\",\n\t\"18\": \"Fourside\",\n\t\"19\": \"Mushroom Kingdom I\",\n\t\"20\": \"Mushroom Kingdom II\",\n\t\"22\": \"Venom\",\n\t\"23\": \"Poké Floats\",\n\t\"24\": \"Big Blue\",\n\t\"25\": \"Icicle Mountain\",\n\t\"26\": \"Icetop\",\n\t\"27\": \"Flat Zone\",\n\t\"28\": \"Dream Land N64\",\n\t\"29\": \"Yoshi's Island N64\",\n\t\"30\": \"Kongo Jungle N64\",\n\t\"31\": \"Battlefield\",\n\t\"32\": \"Final Destination\",\n\t\"33\": \"Target Test (Mario)\",\n\t\"34\": \"Target Test (Captain Falcon)\",\n\t\"35\": \"Target Test (Young Link)\",\n\t\"36\": \"Target Test (Donkey Kong)\",\n\t\"37\": \"Target Test (Dr. Mario)\",\n\t\"38\": \"Target Test (Falco)\",\n\t\"39\": \"Target Test (Fox)\",\n\t\"40\": \"Target Test (Ice Climbers)\",\n\t\"41\": \"Target Test (Kirby)\",\n\t\"42\": \"Target Test (Bowser)\",\n\t\"43\": \"Target Test (Link)\",\n\t\"44\": \"Target Test (Luigi)\",\n\t\"45\": \"Target Test (Marth)\",\n\t\"46\": \"Target Test (Mewtwo)\",\n\t\"47\": \"Target Test (Ness)\",\n\t\"48\": \"Target Test (Peach)\",\n\t\"49\": \"Target Test (Pichu)\",\n\t\"50\": \"Target Test (Pikachu)\",\n\t\"51\": \"Target Test (Jigglypuff)\",\n\t\"52\": \"Target Test (Samus)\",\n\t\"53\": \"Target Test (Sheik)\",\n\t\"54\": \"Target Test (Yoshi)\",\n\t\"55\": \"Target Test (Zelda)\",\n\t\"56\": \"Target Test (Mr. Game & Watch)\",\n\t\"57\": \"Target Test (Roy)\",\n\t\"58\": \"Target Test (Ganondorf)\",\n\t\"84\": \"Home-Run Contest\"\n};\n\nconst UnknownStage = {\n  id: -1,\n  name: \"Unknown Stage\"\n};\nfunction getStageInfo(stageId) {\n  const stageName = stageNames[stageId.toString()];\n\n  if (!stageName) {\n    return UnknownStage;\n  }\n\n  return {\n    id: stageId,\n    name: stageName\n  };\n}\nfunction getStageName(stageId) {\n  const stage = getStageInfo(stageId);\n  return stage.name;\n}\n\nvar stageUtils = {\n  __proto__: null,\n  UnknownStage: UnknownStage,\n  getStageInfo: getStageInfo,\n  getStageName: getStageName\n};\n\nexports.Character = void 0;\n\n(function (Character) {\n  Character[Character[\"CAPTAIN_FALCON\"] = 0] = \"CAPTAIN_FALCON\";\n  Character[Character[\"DONKEY_KONG\"] = 1] = \"DONKEY_KONG\";\n  Character[Character[\"FOX\"] = 2] = \"FOX\";\n  Character[Character[\"GAME_AND_WATCH\"] = 3] = \"GAME_AND_WATCH\";\n  Character[Character[\"KIRBY\"] = 4] = \"KIRBY\";\n  Character[Character[\"BOWSER\"] = 5] = \"BOWSER\";\n  Character[Character[\"LINK\"] = 6] = \"LINK\";\n  Character[Character[\"LUIGI\"] = 7] = \"LUIGI\";\n  Character[Character[\"MARIO\"] = 8] = \"MARIO\";\n  Character[Character[\"MARTH\"] = 9] = \"MARTH\";\n  Character[Character[\"MEWTWO\"] = 10] = \"MEWTWO\";\n  Character[Character[\"NESS\"] = 11] = \"NESS\";\n  Character[Character[\"PEACH\"] = 12] = \"PEACH\";\n  Character[Character[\"PIKACHU\"] = 13] = \"PIKACHU\";\n  Character[Character[\"ICE_CLIMBERS\"] = 14] = \"ICE_CLIMBERS\";\n  Character[Character[\"JIGGLYPUFF\"] = 15] = \"JIGGLYPUFF\";\n  Character[Character[\"SAMUS\"] = 16] = \"SAMUS\";\n  Character[Character[\"YOSHI\"] = 17] = \"YOSHI\";\n  Character[Character[\"ZELDA\"] = 18] = \"ZELDA\";\n  Character[Character[\"SHEIK\"] = 19] = \"SHEIK\";\n  Character[Character[\"FALCO\"] = 20] = \"FALCO\";\n  Character[Character[\"YOUNG_LINK\"] = 21] = \"YOUNG_LINK\";\n  Character[Character[\"DR_MARIO\"] = 22] = \"DR_MARIO\";\n  Character[Character[\"ROY\"] = 23] = \"ROY\";\n  Character[Character[\"PICHU\"] = 24] = \"PICHU\";\n  Character[Character[\"GANONDORF\"] = 25] = \"GANONDORF\";\n  Character[Character[\"MASTER_HAND\"] = 26] = \"MASTER_HAND\";\n  Character[Character[\"WIREFRAME_MALE\"] = 27] = \"WIREFRAME_MALE\";\n  Character[Character[\"WIREFRAME_FEMALE\"] = 28] = \"WIREFRAME_FEMALE\";\n  Character[Character[\"GIGA_BOWSER\"] = 29] = \"GIGA_BOWSER\";\n  Character[Character[\"CRAZY_HAND\"] = 30] = \"CRAZY_HAND\";\n  Character[Character[\"SANDBAG\"] = 31] = \"SANDBAG\";\n  Character[Character[\"POPO\"] = 32] = \"POPO\";\n})(exports.Character || (exports.Character = {}));\n\nexports.Stage = void 0;\n\n(function (Stage) {\n  Stage[Stage[\"FOUNTAIN_OF_DREAMS\"] = 2] = \"FOUNTAIN_OF_DREAMS\";\n  Stage[Stage[\"POKEMON_STADIUM\"] = 3] = \"POKEMON_STADIUM\";\n  Stage[Stage[\"PEACHS_CASTLE\"] = 4] = \"PEACHS_CASTLE\";\n  Stage[Stage[\"KONGO_JUNGLE\"] = 5] = \"KONGO_JUNGLE\";\n  Stage[Stage[\"BRINSTAR\"] = 6] = \"BRINSTAR\";\n  Stage[Stage[\"CORNERIA\"] = 7] = \"CORNERIA\";\n  Stage[Stage[\"YOSHIS_STORY\"] = 8] = \"YOSHIS_STORY\";\n  Stage[Stage[\"ONETT\"] = 9] = \"ONETT\";\n  Stage[Stage[\"MUTE_CITY\"] = 10] = \"MUTE_CITY\";\n  Stage[Stage[\"RAINBOW_CRUISE\"] = 11] = \"RAINBOW_CRUISE\";\n  Stage[Stage[\"JUNGLE_JAPES\"] = 12] = \"JUNGLE_JAPES\";\n  Stage[Stage[\"GREAT_BAY\"] = 13] = \"GREAT_BAY\";\n  Stage[Stage[\"HYRULE_TEMPLE\"] = 14] = \"HYRULE_TEMPLE\";\n  Stage[Stage[\"BRINSTAR_DEPTHS\"] = 15] = \"BRINSTAR_DEPTHS\";\n  Stage[Stage[\"YOSHIS_ISLAND\"] = 16] = \"YOSHIS_ISLAND\";\n  Stage[Stage[\"GREEN_GREENS\"] = 17] = \"GREEN_GREENS\";\n  Stage[Stage[\"FOURSIDE\"] = 18] = \"FOURSIDE\";\n  Stage[Stage[\"MUSHROOM_KINGDOM\"] = 19] = \"MUSHROOM_KINGDOM\";\n  Stage[Stage[\"MUSHROOM_KINGDOM_2\"] = 20] = \"MUSHROOM_KINGDOM_2\";\n  Stage[Stage[\"VENOM\"] = 22] = \"VENOM\";\n  Stage[Stage[\"POKE_FLOATS\"] = 23] = \"POKE_FLOATS\";\n  Stage[Stage[\"BIG_BLUE\"] = 24] = \"BIG_BLUE\";\n  Stage[Stage[\"ICICLE_MOUNTAIN\"] = 25] = \"ICICLE_MOUNTAIN\";\n  Stage[Stage[\"ICETOP\"] = 26] = \"ICETOP\";\n  Stage[Stage[\"FLAT_ZONE\"] = 27] = \"FLAT_ZONE\";\n  Stage[Stage[\"DREAMLAND\"] = 28] = \"DREAMLAND\";\n  Stage[Stage[\"YOSHIS_ISLAND_N64\"] = 29] = \"YOSHIS_ISLAND_N64\";\n  Stage[Stage[\"KONGO_JUNGLE_N64\"] = 30] = \"KONGO_JUNGLE_N64\";\n  Stage[Stage[\"BATTLEFIELD\"] = 31] = \"BATTLEFIELD\";\n  Stage[Stage[\"FINAL_DESTINATION\"] = 32] = \"FINAL_DESTINATION\";\n  Stage[Stage[\"TARGET_TEST_MARIO\"] = 33] = \"TARGET_TEST_MARIO\";\n  Stage[Stage[\"TARGET_TEST_CAPTAIN_FALCON\"] = 34] = \"TARGET_TEST_CAPTAIN_FALCON\";\n  Stage[Stage[\"TARGET_TEST_YOUNG_LINK\"] = 35] = \"TARGET_TEST_YOUNG_LINK\";\n  Stage[Stage[\"TARGET_TEST_DONKEY_KONG\"] = 36] = \"TARGET_TEST_DONKEY_KONG\";\n  Stage[Stage[\"TARGET_TEST_DR_MARIO\"] = 37] = \"TARGET_TEST_DR_MARIO\";\n  Stage[Stage[\"TARGET_TEST_FALCO\"] = 38] = \"TARGET_TEST_FALCO\";\n  Stage[Stage[\"TARGET_TEST_FOX\"] = 39] = \"TARGET_TEST_FOX\";\n  Stage[Stage[\"TARGET_TEST_ICE_CLIMBERS\"] = 40] = \"TARGET_TEST_ICE_CLIMBERS\";\n  Stage[Stage[\"TARGET_TEST_KIRBY\"] = 41] = \"TARGET_TEST_KIRBY\";\n  Stage[Stage[\"TARGET_TEST_BOWSER\"] = 42] = \"TARGET_TEST_BOWSER\";\n  Stage[Stage[\"TARGET_TEST_LINK\"] = 43] = \"TARGET_TEST_LINK\";\n  Stage[Stage[\"TARGET_TEST_LUIGI\"] = 44] = \"TARGET_TEST_LUIGI\";\n  Stage[Stage[\"TARGET_TEST_MARTH\"] = 45] = \"TARGET_TEST_MARTH\";\n  Stage[Stage[\"TARGET_TEST_MEWTWO\"] = 46] = \"TARGET_TEST_MEWTWO\";\n  Stage[Stage[\"TARGET_TEST_NESS\"] = 47] = \"TARGET_TEST_NESS\";\n  Stage[Stage[\"TARGET_TEST_PEACH\"] = 48] = \"TARGET_TEST_PEACH\";\n  Stage[Stage[\"TARGET_TEST_PICHU\"] = 49] = \"TARGET_TEST_PICHU\";\n  Stage[Stage[\"TARGET_TEST_PIKACHU\"] = 50] = \"TARGET_TEST_PIKACHU\";\n  Stage[Stage[\"TARGET_TEST_JIGGLYPUFF\"] = 51] = \"TARGET_TEST_JIGGLYPUFF\";\n  Stage[Stage[\"TARGET_TEST_SAMUS\"] = 52] = \"TARGET_TEST_SAMUS\";\n  Stage[Stage[\"TARGET_TEST_SHEIK\"] = 53] = \"TARGET_TEST_SHEIK\";\n  Stage[Stage[\"TARGET_TEST_YOSHI\"] = 54] = \"TARGET_TEST_YOSHI\";\n  Stage[Stage[\"TARGET_TEST_ZELDA\"] = 55] = \"TARGET_TEST_ZELDA\";\n  Stage[Stage[\"TARGET_TEST_GAME_AND_WATCH\"] = 56] = \"TARGET_TEST_GAME_AND_WATCH\";\n  Stage[Stage[\"TARGET_TEST_ROY\"] = 57] = \"TARGET_TEST_ROY\";\n  Stage[Stage[\"TARGET_TEST_GANONDORF\"] = 58] = \"TARGET_TEST_GANONDORF\";\n  Stage[Stage[\"RACE_TO_THE_FINISH\"] = 82] = \"RACE_TO_THE_FINISH\";\n  Stage[Stage[\"GRAB_THE_TROPHIES\"] = 83] = \"GRAB_THE_TROPHIES\";\n  Stage[Stage[\"HOME_RUN_CONTEST\"] = 84] = \"HOME_RUN_CONTEST\";\n  Stage[Stage[\"ALL_STAR_LOBBY\"] = 85] = \"ALL_STAR_LOBBY\";\n  Stage[Stage[\"EVENT_ONE\"] = 202] = \"EVENT_ONE\";\n  Stage[Stage[\"EVENT_EIGHTEEN\"] = 203] = \"EVENT_EIGHTEEN\";\n  Stage[Stage[\"EVENT_THREE\"] = 204] = \"EVENT_THREE\";\n  Stage[Stage[\"EVENT_FOUR\"] = 205] = \"EVENT_FOUR\";\n  Stage[Stage[\"EVENT_FIVE\"] = 206] = \"EVENT_FIVE\";\n  Stage[Stage[\"EVENT_SIX\"] = 207] = \"EVENT_SIX\";\n  Stage[Stage[\"EVENT_SEVEN\"] = 208] = \"EVENT_SEVEN\";\n  Stage[Stage[\"EVENT_EIGHT\"] = 209] = \"EVENT_EIGHT\";\n  Stage[Stage[\"EVENT_NINE\"] = 210] = \"EVENT_NINE\";\n  Stage[Stage[\"EVENT_TEN_PART_ONE\"] = 211] = \"EVENT_TEN_PART_ONE\";\n  Stage[Stage[\"EVENT_ELEVEN\"] = 212] = \"EVENT_ELEVEN\";\n  Stage[Stage[\"EVENT_TWELVE\"] = 213] = \"EVENT_TWELVE\";\n  Stage[Stage[\"EVENT_THIRTEEN\"] = 214] = \"EVENT_THIRTEEN\";\n  Stage[Stage[\"EVENT_FOURTEEN\"] = 215] = \"EVENT_FOURTEEN\";\n  Stage[Stage[\"EVENT_THIRTY_SEVEN\"] = 216] = \"EVENT_THIRTY_SEVEN\";\n  Stage[Stage[\"EVENT_SIXTEEN\"] = 217] = \"EVENT_SIXTEEN\";\n  Stage[Stage[\"EVENT_SEVENTEEN\"] = 218] = \"EVENT_SEVENTEEN\";\n  Stage[Stage[\"EVENT_TWO\"] = 219] = \"EVENT_TWO\";\n  Stage[Stage[\"EVENT_NINETEEN\"] = 220] = \"EVENT_NINETEEN\";\n  Stage[Stage[\"EVENT_TWENTY_PART_ONE\"] = 221] = \"EVENT_TWENTY_PART_ONE\";\n  Stage[Stage[\"EVENT_TWENTY_ONE\"] = 222] = \"EVENT_TWENTY_ONE\";\n  Stage[Stage[\"EVENT_TWENTY_TWO\"] = 223] = \"EVENT_TWENTY_TWO\";\n  Stage[Stage[\"EVENT_TWENTY_SEVEN\"] = 224] = \"EVENT_TWENTY_SEVEN\";\n  Stage[Stage[\"EVENT_TWENTY_FOUR\"] = 225] = \"EVENT_TWENTY_FOUR\";\n  Stage[Stage[\"EVENT_TWENTY_FIVE\"] = 226] = \"EVENT_TWENTY_FIVE\";\n  Stage[Stage[\"EVENT_TWENTY_SIX\"] = 227] = \"EVENT_TWENTY_SIX\";\n  Stage[Stage[\"EVENT_TWENTY_THREE\"] = 228] = \"EVENT_TWENTY_THREE\";\n  Stage[Stage[\"EVENT_TWENTY_EIGHT\"] = 229] = \"EVENT_TWENTY_EIGHT\";\n  Stage[Stage[\"EVENT_TWENTY_NINE\"] = 230] = \"EVENT_TWENTY_NINE\";\n  Stage[Stage[\"EVENT_THIRTY_PART_ONE\"] = 231] = \"EVENT_THIRTY_PART_ONE\";\n  Stage[Stage[\"EVENT_THIRTY_ONE\"] = 232] = \"EVENT_THIRTY_ONE\";\n  Stage[Stage[\"EVENT_THIRTY_TWO\"] = 233] = \"EVENT_THIRTY_TWO\";\n  Stage[Stage[\"EVENT_THIRTY_THREE\"] = 234] = \"EVENT_THIRTY_THREE\";\n  Stage[Stage[\"EVENT_THIRTY_FOUR\"] = 235] = \"EVENT_THIRTY_FOUR\";\n  Stage[Stage[\"EVENT_FORTY_EIGHT\"] = 236] = \"EVENT_FORTY_EIGHT\";\n  Stage[Stage[\"EVENT_THIRTY_SIX_PART_ONE\"] = 237] = \"EVENT_THIRTY_SIX_PART_ONE\";\n  Stage[Stage[\"EVENT_FIFTEEN\"] = 238] = \"EVENT_FIFTEEN\";\n  Stage[Stage[\"EVENT_THIRTY_EIGHT\"] = 239] = \"EVENT_THIRTY_EIGHT\";\n  Stage[Stage[\"EVENT_THIRTY_NINE\"] = 240] = \"EVENT_THIRTY_NINE\";\n  Stage[Stage[\"EVENT_FORTY_PART_ONE\"] = 241] = \"EVENT_FORTY_PART_ONE\";\n  Stage[Stage[\"EVENT_FORTY_ONE\"] = 242] = \"EVENT_FORTY_ONE\";\n  Stage[Stage[\"EVENT_FORTY_TWO\"] = 243] = \"EVENT_FORTY_TWO\";\n  Stage[Stage[\"EVENT_FORTY_THREE\"] = 244] = \"EVENT_FORTY_THREE\";\n  Stage[Stage[\"EVENT_FORTY_FOUR\"] = 245] = \"EVENT_FORTY_FOUR\";\n  Stage[Stage[\"EVENT_FORTY_FIVE\"] = 246] = \"EVENT_FORTY_FIVE\";\n  Stage[Stage[\"EVENT_FORTY_SIX\"] = 247] = \"EVENT_FORTY_SIX\";\n  Stage[Stage[\"EVENT_FORTY_SEVEN\"] = 248] = \"EVENT_FORTY_SEVEN\";\n  Stage[Stage[\"EVENT_THIRTY_FIVE\"] = 249] = \"EVENT_THIRTY_FIVE\";\n  Stage[Stage[\"EVENT_FORTY_NINE_PART_ONE\"] = 250] = \"EVENT_FORTY_NINE_PART_ONE\";\n  Stage[Stage[\"EVENT_FIFTY\"] = 251] = \"EVENT_FIFTY\";\n  Stage[Stage[\"EVENT_FIFTY_ONE\"] = 252] = \"EVENT_FIFTY_ONE\";\n  Stage[Stage[\"EVENT_TEN_PART_TWO\"] = 253] = \"EVENT_TEN_PART_TWO\";\n  Stage[Stage[\"EVENT_TEN_PART_THREE\"] = 254] = \"EVENT_TEN_PART_THREE\";\n  Stage[Stage[\"EVENT_TEN_PART_FOUR\"] = 255] = \"EVENT_TEN_PART_FOUR\";\n  Stage[Stage[\"EVENT_TEN_PART_FIVE\"] = 256] = \"EVENT_TEN_PART_FIVE\";\n  Stage[Stage[\"EVENT_TWENTY_PART_TWO\"] = 257] = \"EVENT_TWENTY_PART_TWO\";\n  Stage[Stage[\"EVENT_TWENTY_PART_THREE\"] = 258] = \"EVENT_TWENTY_PART_THREE\";\n  Stage[Stage[\"EVENT_TWENTY_PART_FOUR\"] = 259] = \"EVENT_TWENTY_PART_FOUR\";\n  Stage[Stage[\"EVENT_TWENTY_PART_FIVE\"] = 260] = \"EVENT_TWENTY_PART_FIVE\";\n  Stage[Stage[\"EVENT_THIRTY_PART_TWO\"] = 261] = \"EVENT_THIRTY_PART_TWO\";\n  Stage[Stage[\"EVENT_THIRTY_PART_THREE\"] = 262] = \"EVENT_THIRTY_PART_THREE\";\n  Stage[Stage[\"EVENT_THIRTY_PART_FOUR\"] = 263] = \"EVENT_THIRTY_PART_FOUR\";\n  Stage[Stage[\"EVENT_FORTY_PART_TWO\"] = 264] = \"EVENT_FORTY_PART_TWO\";\n  Stage[Stage[\"EVENT_FORTY_PART_THREE\"] = 265] = \"EVENT_FORTY_PART_THREE\";\n  Stage[Stage[\"EVENT_FORTY_PART_FOUR\"] = 266] = \"EVENT_FORTY_PART_FOUR\";\n  Stage[Stage[\"EVENT_FORTY_PART_FIVE\"] = 267] = \"EVENT_FORTY_PART_FIVE\";\n  Stage[Stage[\"EVENT_FORTY_NINE_PART_TWO\"] = 268] = \"EVENT_FORTY_NINE_PART_TWO\";\n  Stage[Stage[\"EVENT_FORTY_NINE_PART_THREE\"] = 269] = \"EVENT_FORTY_NINE_PART_THREE\";\n  Stage[Stage[\"EVENT_FORTY_NINE_PART_FOUR\"] = 270] = \"EVENT_FORTY_NINE_PART_FOUR\";\n  Stage[Stage[\"EVENT_FORTY_NINE_PART_FIVE\"] = 271] = \"EVENT_FORTY_NINE_PART_FIVE\";\n  Stage[Stage[\"EVENT_FORTY_NINE_PART_SIX\"] = 272] = \"EVENT_FORTY_NINE_PART_SIX\";\n  Stage[Stage[\"EVENT_THIRTY_SIX_PART_TWO\"] = 273] = \"EVENT_THIRTY_SIX_PART_TWO\";\n  Stage[Stage[\"MULTI_MAN_MELEE\"] = 285] = \"MULTI_MAN_MELEE\";\n})(exports.Stage || (exports.Stage = {}));\n\nexports.State = void 0;\n\n(function (State) {\n  // Animation ID ranges\n  State[State[\"DAMAGE_START\"] = 75] = \"DAMAGE_START\";\n  State[State[\"DAMAGE_END\"] = 91] = \"DAMAGE_END\";\n  State[State[\"CAPTURE_START\"] = 223] = \"CAPTURE_START\";\n  State[State[\"CAPTURE_END\"] = 232] = \"CAPTURE_END\";\n  State[State[\"GUARD_START\"] = 178] = \"GUARD_START\";\n  State[State[\"GUARD_END\"] = 182] = \"GUARD_END\";\n  State[State[\"GROUNDED_CONTROL_START\"] = 14] = \"GROUNDED_CONTROL_START\";\n  State[State[\"GROUNDED_CONTROL_END\"] = 24] = \"GROUNDED_CONTROL_END\";\n  State[State[\"SQUAT_START\"] = 39] = \"SQUAT_START\";\n  State[State[\"SQUAT_END\"] = 41] = \"SQUAT_END\";\n  State[State[\"DOWN_START\"] = 183] = \"DOWN_START\";\n  State[State[\"DOWN_END\"] = 198] = \"DOWN_END\";\n  State[State[\"TECH_START\"] = 199] = \"TECH_START\";\n  State[State[\"TECH_END\"] = 204] = \"TECH_END\";\n  State[State[\"DYING_START\"] = 0] = \"DYING_START\";\n  State[State[\"DYING_END\"] = 10] = \"DYING_END\";\n  State[State[\"CONTROLLED_JUMP_START\"] = 24] = \"CONTROLLED_JUMP_START\";\n  State[State[\"CONTROLLED_JUMP_END\"] = 34] = \"CONTROLLED_JUMP_END\";\n  State[State[\"GROUND_ATTACK_START\"] = 44] = \"GROUND_ATTACK_START\";\n  State[State[\"GROUND_ATTACK_END\"] = 64] = \"GROUND_ATTACK_END\";\n  State[State[\"AERIAL_ATTACK_START\"] = 65] = \"AERIAL_ATTACK_START\";\n  State[State[\"AERIAL_ATTACK_END\"] = 74] = \"AERIAL_ATTACK_END\";\n  State[State[\"ATTACK_FTILT_START\"] = 51] = \"ATTACK_FTILT_START\";\n  State[State[\"ATTACK_FTILT_END\"] = 55] = \"ATTACK_FTILT_END\";\n  State[State[\"ATTACK_FSMASH_START\"] = 58] = \"ATTACK_FSMASH_START\";\n  State[State[\"ATTACK_FSMASH_END\"] = 62] = \"ATTACK_FSMASH_END\"; // Animation ID specific\n\n  State[State[\"ROLL_FORWARD\"] = 233] = \"ROLL_FORWARD\";\n  State[State[\"ROLL_BACKWARD\"] = 234] = \"ROLL_BACKWARD\";\n  State[State[\"SPOT_DODGE\"] = 235] = \"SPOT_DODGE\";\n  State[State[\"AIR_DODGE\"] = 236] = \"AIR_DODGE\";\n  State[State[\"ACTION_WAIT\"] = 14] = \"ACTION_WAIT\";\n  State[State[\"ACTION_DASH\"] = 20] = \"ACTION_DASH\";\n  State[State[\"ACTION_KNEE_BEND\"] = 24] = \"ACTION_KNEE_BEND\";\n  State[State[\"GUARD_ON\"] = 178] = \"GUARD_ON\";\n  State[State[\"TECH_MISS_UP\"] = 183] = \"TECH_MISS_UP\";\n  State[State[\"JAB_RESET_UP\"] = 185] = \"JAB_RESET_UP\";\n  State[State[\"TECH_MISS_DOWN\"] = 191] = \"TECH_MISS_DOWN\";\n  State[State[\"JAB_RESET_DOWN\"] = 193] = \"JAB_RESET_DOWN\";\n  State[State[\"NEUTRAL_TECH\"] = 199] = \"NEUTRAL_TECH\";\n  State[State[\"FORWARD_TECH\"] = 200] = \"FORWARD_TECH\";\n  State[State[\"BACKWARD_TECH\"] = 201] = \"BACKWARD_TECH\";\n  State[State[\"WALL_TECH\"] = 202] = \"WALL_TECH\";\n  State[State[\"MISSED_WALL_TECH\"] = 247] = \"MISSED_WALL_TECH\";\n  State[State[\"DASH\"] = 20] = \"DASH\";\n  State[State[\"TURN\"] = 18] = \"TURN\";\n  State[State[\"LANDING_FALL_SPECIAL\"] = 43] = \"LANDING_FALL_SPECIAL\";\n  State[State[\"JUMP_FORWARD\"] = 25] = \"JUMP_FORWARD\";\n  State[State[\"JUMP_BACKWARD\"] = 26] = \"JUMP_BACKWARD\";\n  State[State[\"FALL_FORWARD\"] = 30] = \"FALL_FORWARD\";\n  State[State[\"FALL_BACKWARD\"] = 31] = \"FALL_BACKWARD\";\n  State[State[\"GRAB\"] = 212] = \"GRAB\";\n  State[State[\"DASH_GRAB\"] = 214] = \"DASH_GRAB\";\n  State[State[\"GRAB_WAIT\"] = 216] = \"GRAB_WAIT\";\n  State[State[\"PUMMEL\"] = 217] = \"PUMMEL\";\n  State[State[\"CLIFF_CATCH\"] = 252] = \"CLIFF_CATCH\";\n  State[State[\"THROW_UP\"] = 221] = \"THROW_UP\";\n  State[State[\"THROW_FORWARD\"] = 219] = \"THROW_FORWARD\";\n  State[State[\"THROW_DOWN\"] = 222] = \"THROW_DOWN\";\n  State[State[\"THROW_BACK\"] = 220] = \"THROW_BACK\";\n  State[State[\"DAMAGE_FALL\"] = 38] = \"DAMAGE_FALL\";\n  State[State[\"ATTACK_JAB1\"] = 44] = \"ATTACK_JAB1\";\n  State[State[\"ATTACK_JAB2\"] = 45] = \"ATTACK_JAB2\";\n  State[State[\"ATTACK_JAB3\"] = 46] = \"ATTACK_JAB3\";\n  State[State[\"ATTACK_JABM\"] = 47] = \"ATTACK_JABM\";\n  State[State[\"ATTACK_DASH\"] = 50] = \"ATTACK_DASH\";\n  State[State[\"ATTACK_UTILT\"] = 56] = \"ATTACK_UTILT\";\n  State[State[\"ATTACK_DTILT\"] = 57] = \"ATTACK_DTILT\";\n  State[State[\"ATTACK_USMASH\"] = 63] = \"ATTACK_USMASH\";\n  State[State[\"ATTACK_DSMASH\"] = 64] = \"ATTACK_DSMASH\";\n  State[State[\"AERIAL_NAIR\"] = 65] = \"AERIAL_NAIR\";\n  State[State[\"AERIAL_FAIR\"] = 66] = \"AERIAL_FAIR\";\n  State[State[\"AERIAL_BAIR\"] = 67] = \"AERIAL_BAIR\";\n  State[State[\"AERIAL_UAIR\"] = 68] = \"AERIAL_UAIR\";\n  State[State[\"AERIAL_DAIR\"] = 69] = \"AERIAL_DAIR\"; // Weird GnW IDs\n\n  State[State[\"GNW_JAB1\"] = 341] = \"GNW_JAB1\";\n  State[State[\"GNW_JABM\"] = 342] = \"GNW_JABM\";\n  State[State[\"GNW_DTILT\"] = 345] = \"GNW_DTILT\";\n  State[State[\"GNW_FSMASH\"] = 346] = \"GNW_FSMASH\";\n  State[State[\"GNW_NAIR\"] = 347] = \"GNW_NAIR\";\n  State[State[\"GNW_BAIR\"] = 348] = \"GNW_BAIR\";\n  State[State[\"GNW_UAIR\"] = 349] = \"GNW_UAIR\"; // Peach FSMASH ID\n  // FSMASH1 = Golf Club, FSMASH2 = Frying Pan, FSMASH3 = Tennis Racket\n\n  State[State[\"PEACH_FSMASH1\"] = 349] = \"PEACH_FSMASH1\";\n  State[State[\"PEACH_FSMASH2\"] = 350] = \"PEACH_FSMASH2\";\n  State[State[\"PEACH_FSMASH3\"] = 351] = \"PEACH_FSMASH3\"; // Command Grabs\n\n  State[State[\"BARREL_WAIT\"] = 293] = \"BARREL_WAIT\";\n  State[State[\"COMMAND_GRAB_RANGE1_START\"] = 266] = \"COMMAND_GRAB_RANGE1_START\";\n  State[State[\"COMMAND_GRAB_RANGE1_END\"] = 304] = \"COMMAND_GRAB_RANGE1_END\";\n  State[State[\"COMMAND_GRAB_RANGE2_START\"] = 327] = \"COMMAND_GRAB_RANGE2_START\";\n  State[State[\"COMMAND_GRAB_RANGE2_END\"] = 338] = \"COMMAND_GRAB_RANGE2_END\";\n})(exports.State || (exports.State = {}));\n\nconst Timers = {\n  PUNISH_RESET_FRAMES: 45,\n  RECOVERY_RESET_FRAMES: 45,\n  COMBO_STRING_RESET_FRAMES: 45\n};\nfunction getSinglesPlayerPermutationsFromSettings(settings) {\n  if (!settings || settings.players.length !== 2) {\n    // Only return opponent indices for singles\n    return [];\n  }\n\n  return [{\n    playerIndex: settings.players[0].playerIndex,\n    opponentIndex: settings.players[1].playerIndex\n  }, {\n    playerIndex: settings.players[1].playerIndex,\n    opponentIndex: settings.players[0].playerIndex\n  }];\n}\nfunction didLoseStock(frame, prevFrame) {\n  if (!frame || !prevFrame) {\n    return false;\n  }\n\n  return prevFrame.stocksRemaining - frame.stocksRemaining > 0;\n}\nfunction isInControl(state) {\n  const ground = state >= exports.State.GROUNDED_CONTROL_START && state <= exports.State.GROUNDED_CONTROL_END;\n  const squat = state >= exports.State.SQUAT_START && state <= exports.State.SQUAT_END;\n  const groundAttack = state > exports.State.GROUND_ATTACK_START && state <= exports.State.GROUND_ATTACK_END;\n  const isGrab = state === exports.State.GRAB; // TODO: Add grounded b moves?\n\n  return ground || squat || groundAttack || isGrab;\n}\nfunction isTeching(state) {\n  return state >= exports.State.TECH_START && state <= exports.State.TECH_END;\n}\nfunction isDown(state) {\n  return state >= exports.State.DOWN_START && state <= exports.State.DOWN_END;\n}\nfunction isDamaged(state) {\n  return state >= exports.State.DAMAGE_START && state <= exports.State.DAMAGE_END || state === exports.State.DAMAGE_FALL || state === exports.State.JAB_RESET_UP || state === exports.State.JAB_RESET_DOWN;\n}\nfunction isGrabbed(state) {\n  return state >= exports.State.CAPTURE_START && state <= exports.State.CAPTURE_END;\n} // TODO: Find better implementation of 3 seperate ranges\n\nfunction isCommandGrabbed(state) {\n  return (state >= exports.State.COMMAND_GRAB_RANGE1_START && state <= exports.State.COMMAND_GRAB_RANGE1_END || state >= exports.State.COMMAND_GRAB_RANGE2_START && state <= exports.State.COMMAND_GRAB_RANGE2_END) && state !== exports.State.BARREL_WAIT;\n}\nfunction isDead(state) {\n  return state >= exports.State.DYING_START && state <= exports.State.DYING_END;\n}\nfunction calcDamageTaken(frame, prevFrame) {\n  var _frame$percent, _prevFrame$percent;\n\n  const percent = (_frame$percent = frame.percent) != null ? _frame$percent : 0;\n  const prevPercent = (_prevFrame$percent = prevFrame.percent) != null ? _prevFrame$percent : 0;\n  return percent - prevPercent;\n}\n\nconst dashDanceAnimations = [exports.State.DASH, exports.State.TURN, exports.State.DASH];\nclass ActionsComputer {\n  constructor() {\n    this.playerPermutations = new Array();\n    this.state = new Map();\n  }\n\n  setup(settings) {\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.playerPermutations.forEach(indices => {\n      const playerCounts = {\n        playerIndex: indices.playerIndex,\n        wavedashCount: 0,\n        wavelandCount: 0,\n        airDodgeCount: 0,\n        dashDanceCount: 0,\n        spotDodgeCount: 0,\n        ledgegrabCount: 0,\n        rollCount: 0,\n        lCancelCount: {\n          success: 0,\n          fail: 0\n        },\n        attackCount: {\n          jab1: 0,\n          jab2: 0,\n          jab3: 0,\n          jabm: 0,\n          dash: 0,\n          ftilt: 0,\n          utilt: 0,\n          dtilt: 0,\n          fsmash: 0,\n          usmash: 0,\n          dsmash: 0,\n          nair: 0,\n          fair: 0,\n          bair: 0,\n          uair: 0,\n          dair: 0\n        },\n        grabCount: {\n          success: 0,\n          fail: 0\n        },\n        throwCount: {\n          up: 0,\n          forward: 0,\n          back: 0,\n          down: 0\n        },\n        groundTechCount: {\n          // tech away/in are in reference to the opponents position and not the stage\n          away: 0,\n          in: 0,\n          neutral: 0,\n          fail: 0\n        },\n        wallTechCount: {\n          success: 0,\n          fail: 0\n        }\n      };\n      const playerState = {\n        playerCounts: playerCounts,\n        animations: [],\n        actionFrameCounters: []\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  processFrame(frame) {\n    this.playerPermutations.forEach(indices => {\n      const state = this.state.get(indices);\n\n      if (state) {\n        handleActionCompute(state, indices, frame);\n      }\n    });\n  }\n\n  fetch() {\n    return Array.from(this.state.values()).map(val => val.playerCounts);\n  }\n\n}\n\nfunction isMissGroundTech(animation) {\n  return animation === exports.State.TECH_MISS_DOWN || animation === exports.State.TECH_MISS_UP;\n}\n\nfunction isRolling(animation) {\n  return animation === exports.State.ROLL_BACKWARD || animation === exports.State.ROLL_FORWARD;\n}\n\nfunction isGrabAction(animation) {\n  // Includes Grab pull, wait, pummel, and throws\n  return animation > exports.State.GRAB && animation <= exports.State.THROW_DOWN && animation !== exports.State.DASH_GRAB;\n}\n\nfunction isGrabbing(animation) {\n  return animation === exports.State.GRAB || animation === exports.State.DASH_GRAB;\n}\n\nfunction isAerialAttack(animation) {\n  return animation >= exports.State.AERIAL_ATTACK_START && animation <= exports.State.AERIAL_ATTACK_END;\n}\n\nfunction isForwardTilt(animation) {\n  return animation >= exports.State.ATTACK_FTILT_START && animation <= exports.State.ATTACK_FTILT_END;\n}\n\nfunction isForwardSmash(animation) {\n  return animation >= exports.State.ATTACK_FSMASH_START && animation <= exports.State.ATTACK_FSMASH_END;\n}\n\nfunction handleActionCompute(state, indices, frame) {\n  const playerFrame = frame.players[indices.playerIndex].post;\n  const opponentFrame = frame.players[indices.opponentIndex].post;\n\n  const incrementCount = (field, condition) => {\n    if (!condition) {\n      return;\n    }\n\n    const current = lodash.get(state.playerCounts, field, 0);\n    lodash.set(state.playerCounts, field, current + 1);\n  }; // Manage animation state\n\n\n  const currentAnimation = playerFrame.actionStateId;\n  state.animations.push(currentAnimation);\n  const currentFrameCounter = playerFrame.actionStateCounter;\n  state.actionFrameCounters.push(currentFrameCounter); // Grab last 3 frames\n\n  const last3Frames = state.animations.slice(-3);\n  const prevAnimation = last3Frames[last3Frames.length - 2];\n  const prevFrameCounter = state.actionFrameCounters[state.actionFrameCounters.length - 2]; // New action if new animation or frame counter goes back down (repeated action)\n\n  const isNewAction = currentAnimation !== prevAnimation || prevFrameCounter > currentFrameCounter;\n\n  if (!isNewAction) {\n    return;\n  } // Increment counts based on conditions\n\n\n  const didDashDance = lodash.isEqual(last3Frames, dashDanceAnimations);\n  incrementCount(\"dashDanceCount\", didDashDance);\n  incrementCount(\"rollCount\", isRolling(currentAnimation));\n  incrementCount(\"spotDodgeCount\", currentAnimation === exports.State.SPOT_DODGE);\n  incrementCount(\"airDodgeCount\", currentAnimation === exports.State.AIR_DODGE);\n  incrementCount(\"ledgegrabCount\", currentAnimation === exports.State.CLIFF_CATCH); // Grabs\n\n  incrementCount(\"grabCount.success\", isGrabbing(prevAnimation) && isGrabAction(currentAnimation));\n  incrementCount(\"grabCount.fail\", isGrabbing(prevAnimation) && !isGrabAction(currentAnimation));\n\n  if (currentAnimation === exports.State.DASH_GRAB && prevAnimation === exports.State.ATTACK_DASH) {\n    state.playerCounts.attackCount.dash -= 1; // subtract from dash attack if boost grab\n  } // Basic attacks\n\n\n  incrementCount(\"attackCount.jab1\", currentAnimation === exports.State.ATTACK_JAB1);\n  incrementCount(\"attackCount.jab2\", currentAnimation === exports.State.ATTACK_JAB2);\n  incrementCount(\"attackCount.jab3\", currentAnimation === exports.State.ATTACK_JAB3);\n  incrementCount(\"attackCount.jabm\", currentAnimation === exports.State.ATTACK_JABM);\n  incrementCount(\"attackCount.dash\", currentAnimation === exports.State.ATTACK_DASH);\n  incrementCount(\"attackCount.ftilt\", isForwardTilt(currentAnimation));\n  incrementCount(\"attackCount.utilt\", currentAnimation === exports.State.ATTACK_UTILT);\n  incrementCount(\"attackCount.dtilt\", currentAnimation === exports.State.ATTACK_DTILT);\n  incrementCount(\"attackCount.fsmash\", isForwardSmash(currentAnimation));\n  incrementCount(\"attackCount.usmash\", currentAnimation === exports.State.ATTACK_USMASH);\n  incrementCount(\"attackCount.dsmash\", currentAnimation === exports.State.ATTACK_DSMASH);\n  incrementCount(\"attackCount.nair\", currentAnimation === exports.State.AERIAL_NAIR);\n  incrementCount(\"attackCount.fair\", currentAnimation === exports.State.AERIAL_FAIR);\n  incrementCount(\"attackCount.bair\", currentAnimation === exports.State.AERIAL_BAIR);\n  incrementCount(\"attackCount.uair\", currentAnimation === exports.State.AERIAL_UAIR);\n  incrementCount(\"attackCount.dair\", currentAnimation === exports.State.AERIAL_DAIR); // GnW is weird and has unique IDs for some moves\n\n  if (playerFrame.internalCharacterId === 0x18) {\n    incrementCount(\"attackCount.jab1\", currentAnimation === exports.State.GNW_JAB1);\n    incrementCount(\"attackCount.jabm\", currentAnimation === exports.State.GNW_JABM);\n    incrementCount(\"attackCount.dtilt\", currentAnimation === exports.State.GNW_DTILT);\n    incrementCount(\"attackCount.fsmash\", currentAnimation === exports.State.GNW_FSMASH);\n    incrementCount(\"attackCount.nair\", currentAnimation === exports.State.GNW_NAIR);\n    incrementCount(\"attackCount.bair\", currentAnimation === exports.State.GNW_BAIR);\n    incrementCount(\"attackCount.uair\", currentAnimation === exports.State.GNW_UAIR);\n  } // Peach is also weird and has a unique ID for her fsmash\n  // FSMASH1 = Golf Club, FSMASH2 = Frying Pan, FSMASH3 = Tennis Racket\n\n\n  if (playerFrame.internalCharacterId === 0x09) {\n    incrementCount(\"attackCount.fsmash\", currentAnimation === exports.State.PEACH_FSMASH1);\n    incrementCount(\"attackCount.fsmash\", currentAnimation === exports.State.PEACH_FSMASH2);\n    incrementCount(\"attackCount.fsmash\", currentAnimation === exports.State.PEACH_FSMASH3);\n  } // Throws\n\n\n  incrementCount(\"throwCount.up\", currentAnimation === exports.State.THROW_UP);\n  incrementCount(\"throwCount.forward\", currentAnimation === exports.State.THROW_FORWARD);\n  incrementCount(\"throwCount.down\", currentAnimation === exports.State.THROW_DOWN);\n  incrementCount(\"throwCount.back\", currentAnimation === exports.State.THROW_BACK); // Techs\n\n  const opponentDir = playerFrame.positionX > opponentFrame.positionX ? -1 : 1;\n  const facingOpponent = playerFrame.facingDirection === opponentDir;\n  incrementCount(\"groundTechCount.fail\", isMissGroundTech(currentAnimation));\n  incrementCount(\"groundTechCount.in\", currentAnimation === exports.State.FORWARD_TECH && facingOpponent);\n  incrementCount(\"groundTechCount.in\", currentAnimation === exports.State.BACKWARD_TECH && !facingOpponent);\n  incrementCount(\"groundTechCount.neutral\", currentAnimation === exports.State.NEUTRAL_TECH);\n  incrementCount(\"groundTechCount.away\", currentAnimation === exports.State.BACKWARD_TECH && facingOpponent);\n  incrementCount(\"groundTechCount.away\", currentAnimation === exports.State.FORWARD_TECH && !facingOpponent);\n  incrementCount(\"wallTechCount.success\", currentAnimation === exports.State.WALL_TECH);\n  incrementCount(\"wallTechCount.fail\", currentAnimation === exports.State.MISSED_WALL_TECH);\n\n  if (isAerialAttack(currentAnimation)) {\n    incrementCount(\"lCancelCount.success\", playerFrame.lCancelStatus === 1);\n    incrementCount(\"lCancelCount.fail\", playerFrame.lCancelStatus === 2);\n  } // Handles wavedash detection (and waveland)\n\n\n  handleActionWavedash(state.playerCounts, state.animations);\n}\n\nfunction handleActionWavedash(counts, animations) {\n  const currentAnimation = lodash.last(animations);\n  const prevAnimation = animations[animations.length - 2];\n  const isSpecialLanding = currentAnimation === exports.State.LANDING_FALL_SPECIAL;\n  const isAcceptablePrevious = isWavedashInitiationAnimation(prevAnimation);\n  const isPossibleWavedash = isSpecialLanding && isAcceptablePrevious;\n\n  if (!isPossibleWavedash) {\n    return;\n  } // Here we special landed, it might be a wavedash, let's check\n  // We grab the last 8 frames here because that should be enough time to execute a\n  // wavedash. This number could be tweaked if we find false negatives\n\n\n  const recentFrames = animations.slice(-8);\n  const recentAnimations = lodash.keyBy(recentFrames, animation => animation);\n\n  if (lodash.size(recentAnimations) === 2 && recentAnimations[exports.State.AIR_DODGE]) {\n    // If the only other animation is air dodge, this might be really late to the point\n    // where it was actually an air dodge. Air dodge animation is really long\n    return;\n  }\n\n  if (recentAnimations[exports.State.AIR_DODGE]) {\n    // If one of the recent animations was an air dodge, let's remove that from the\n    // air dodge counter, we don't want to count air dodges used to wavedash/land\n    counts.airDodgeCount -= 1;\n  }\n\n  if (recentAnimations[exports.State.ACTION_KNEE_BEND]) {\n    // If a jump was started recently, we will consider this a wavedash\n    counts.wavedashCount += 1;\n  } else {\n    // If there was no jump recently, this is a waveland\n    counts.wavelandCount += 1;\n  }\n}\n\nfunction isWavedashInitiationAnimation(animation) {\n  if (animation === exports.State.AIR_DODGE) {\n    return true;\n  }\n\n  const isAboveMin = animation >= exports.State.CONTROLLED_JUMP_START;\n  const isBelowMax = animation <= exports.State.CONTROLLED_JUMP_END;\n  return isAboveMin && isBelowMax;\n}\n\nvar ComboEvent;\n\n(function (ComboEvent) {\n  ComboEvent[\"COMBO_START\"] = \"COMBO_START\";\n  ComboEvent[\"COMBO_EXTEND\"] = \"COMBO_EXTEND\";\n  ComboEvent[\"COMBO_END\"] = \"COMBO_END\";\n})(ComboEvent || (ComboEvent = {}));\n\nclass ComboComputer extends events.EventEmitter {\n  constructor(...args) {\n    super(...args);\n    this.playerPermutations = new Array();\n    this.state = new Map();\n    this.combos = new Array();\n    this.settings = null;\n  }\n\n  setup(settings) {\n    // Reset the state\n    this.settings = settings;\n    this.state = new Map();\n    this.combos = [];\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.playerPermutations.forEach(indices => {\n      const playerState = {\n        combo: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n        event: null\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  processFrame(frame, allFrames) {\n    this.playerPermutations.forEach(indices => {\n      const state = this.state.get(indices);\n\n      if (state) {\n        handleComboCompute(allFrames, state, indices, frame, this.combos); // Emit an event for the new combo\n\n        if (state.event !== null) {\n          this.emit(state.event, {\n            combo: lodash.last(this.combos),\n            settings: this.settings\n          });\n          state.event = null;\n        }\n      }\n    });\n  }\n\n  fetch() {\n    return this.combos;\n  }\n\n}\n\nfunction handleComboCompute(frames, state, indices, frame, combos) {\n  const currentFrameNumber = frame.frame;\n  const playerFrame = frame.players[indices.playerIndex].post;\n  const opponentFrame = frame.players[indices.opponentIndex].post;\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame = null;\n  let prevOpponentFrame = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber].players[indices.playerIndex].post;\n    prevOpponentFrame = frames[prevFrameNumber].players[indices.opponentIndex].post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0; // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  } // If opponent took damage and was put in some kind of stun this frame, either\n  // start a combo or count the moves for the existing combo\n\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    let comboStarted = false;\n\n    if (!state.combo) {\n      var _prevOpponentFrame$pe, _opponentFrame$percen;\n\n      state.combo = {\n        playerIndex: indices.opponentIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? (_prevOpponentFrame$pe = prevOpponentFrame.percent) != null ? _prevOpponentFrame$pe : 0 : 0,\n        currentPercent: (_opponentFrame$percen = opponentFrame.percent) != null ? _opponentFrame$percen : 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        lastHitBy: indices.playerIndex\n      };\n      combos.push(state.combo); // Track whether this is a new combo or not\n\n      comboStarted = true;\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded,\n          hitCount: 0,\n          damage: 0\n        };\n        state.combo.moves.push(state.move); // Make sure we don't overwrite the START event\n\n        if (!comboStarted) {\n          state.event = ComboEvent.COMBO_EXTEND;\n        }\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      } // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n\n\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n\n    if (comboStarted) {\n      state.event = ComboEvent.COMBO_START;\n    }\n  }\n\n  if (!state.combo) {\n    // The rest of the function handles combo termination logic, so if we don't\n    // have a combo started, there is no need to continue\n    return;\n  }\n\n  const opntIsTeching = isTeching(oppActionStateId);\n  const opntIsDowned = isDown(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n  const opntIsDying = isDead(oppActionStateId); // Update percent if opponent didn't lose stock\n\n  if (!opntDidLoseStock) {\n    var _opponentFrame$percen2;\n\n    state.combo.currentPercent = (_opponentFrame$percen2 = opponentFrame.percent) != null ? _opponentFrame$percen2 : 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed || opntIsTeching || opntIsDowned || opntIsDying) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  } else {\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false; // Termination condition 1 - player kills opponent\n\n  if (opntDidLoseStock) {\n    state.combo.didKill = true;\n    shouldTerminate = true;\n  } // Termination condition 2 - combo resets on time\n\n\n  if (state.resetCounter > Timers.COMBO_STRING_RESET_FRAMES) {\n    shouldTerminate = true;\n  } // If combo should terminate, mark the end states and add it to list\n\n\n  if (shouldTerminate) {\n    var _prevOpponentFrame$pe2;\n\n    state.combo.endFrame = playerFrame.frame;\n    state.combo.endPercent = prevOpponentFrame ? (_prevOpponentFrame$pe2 = prevOpponentFrame.percent) != null ? _prevOpponentFrame$pe2 : 0 : 0;\n    state.event = ComboEvent.COMBO_END;\n    state.combo = null;\n    state.move = null;\n  }\n}\n\nclass ConversionComputer extends events.EventEmitter {\n  constructor() {\n    super();\n    this.playerPermutations = new Array();\n    this.conversions = new Array();\n    this.state = new Map();\n    this.metadata = void 0;\n    this.settings = null;\n    this.metadata = {\n      lastEndFrameByOppIdx: {}\n    };\n  }\n\n  setup(settings) {\n    // Reset the state\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.conversions = [];\n    this.state = new Map();\n    this.metadata = {\n      lastEndFrameByOppIdx: {}\n    };\n    this.settings = settings;\n    this.playerPermutations.forEach(indices => {\n      const playerState = {\n        conversion: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  processFrame(frame, allFrames) {\n    this.playerPermutations.forEach(indices => {\n      const state = this.state.get(indices);\n\n      if (state) {\n        const terminated = handleConversionCompute(allFrames, state, indices, frame, this.conversions);\n\n        if (terminated) {\n          this.emit(\"CONVERSION\", {\n            combo: lodash.last(this.conversions),\n            settings: this.settings\n          });\n        }\n      }\n    });\n  }\n\n  fetch() {\n    this._populateConversionTypes();\n\n    return this.conversions;\n  }\n\n  _populateConversionTypes() {\n    // Post-processing step: set the openingTypes\n    const conversionsToHandle = lodash.filter(this.conversions, conversion => {\n      return conversion.openingType === \"unknown\";\n    }); // Group new conversions by startTime and sort\n\n    const groupedConversions = lodash.groupBy(conversionsToHandle, \"startFrame\");\n    const sortedConversions = lodash.orderBy(groupedConversions, conversions => lodash.get(conversions, [0, \"startFrame\"])); // Set the opening types on the conversions we need to handle\n\n    sortedConversions.forEach(conversions => {\n      const isTrade = conversions.length >= 2;\n      conversions.forEach(conversion => {\n        // Set end frame for this conversion\n        this.metadata.lastEndFrameByOppIdx[conversion.playerIndex] = conversion.endFrame;\n\n        if (isTrade) {\n          // If trade, just short-circuit\n          conversion.openingType = \"trade\";\n          return;\n        } // If not trade, check the opponent endFrame\n\n\n        const lastMove = lodash.last(conversion.moves);\n        const oppEndFrame = this.metadata.lastEndFrameByOppIdx[lastMove ? lastMove.playerIndex : conversion.playerIndex];\n        const isCounterAttack = oppEndFrame && oppEndFrame > conversion.startFrame;\n        conversion.openingType = isCounterAttack ? \"counter-attack\" : \"neutral-win\";\n      });\n    });\n  }\n\n}\n\nfunction handleConversionCompute(frames, state, indices, frame, conversions) {\n  const currentFrameNumber = frame.frame;\n  const playerFrame = frame.players[indices.playerIndex].post;\n  const opponentFrame = frame.players[indices.opponentIndex].post;\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame = null;\n  let prevOpponentFrame = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber].players[indices.playerIndex].post;\n    prevOpponentFrame = frames[prevFrameNumber].players[indices.opponentIndex].post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0; // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  } // If opponent took damage and was put in some kind of stun this frame, either\n  // start a conversion or\n\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    if (!state.conversion) {\n      var _prevOpponentFrame$pe, _opponentFrame$percen;\n\n      state.conversion = {\n        playerIndex: indices.opponentIndex,\n        lastHitBy: indices.playerIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? (_prevOpponentFrame$pe = prevOpponentFrame.percent) != null ? _prevOpponentFrame$pe : 0 : 0,\n        currentPercent: (_opponentFrame$percen = opponentFrame.percent) != null ? _opponentFrame$percen : 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        openingType: \"unknown\" // Will be updated later\n\n      };\n      conversions.push(state.conversion);\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded,\n          hitCount: 0,\n          damage: 0\n        };\n        state.conversion.moves.push(state.move);\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      } // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n\n\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n  }\n\n  if (!state.conversion) {\n    // The rest of the function handles conversion termination logic, so if we don't\n    // have a conversion started, there is no need to continue\n    return false;\n  }\n\n  const opntInControl = isInControl(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame); // Update percent if opponent didn't lose stock\n\n  if (!opntDidLoseStock) {\n    var _opponentFrame$percen2;\n\n    state.conversion.currentPercent = (_opponentFrame$percen2 = opponentFrame.percent) != null ? _opponentFrame$percen2 : 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  }\n\n  const shouldStartResetCounter = state.resetCounter === 0 && opntInControl;\n  const shouldContinueResetCounter = state.resetCounter > 0;\n\n  if (shouldStartResetCounter || shouldContinueResetCounter) {\n    // This will increment the reset timer under the following conditions:\n    // 1) if we were punishing opponent but they have now entered an actionable state\n    // 2) if counter has already started counting meaning opponent has entered actionable state\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false; // Termination condition 1 - player kills opponent\n\n  if (opntDidLoseStock) {\n    state.conversion.didKill = true;\n    shouldTerminate = true;\n  } // Termination condition 2 - conversion resets on time\n\n\n  if (state.resetCounter > Timers.PUNISH_RESET_FRAMES) {\n    shouldTerminate = true;\n  } // If conversion should terminate, mark the end states and add it to list\n\n\n  if (shouldTerminate) {\n    var _prevOpponentFrame$pe2;\n\n    state.conversion.endFrame = playerFrame.frame;\n    state.conversion.endPercent = prevOpponentFrame ? (_prevOpponentFrame$pe2 = prevOpponentFrame.percent) != null ? _prevOpponentFrame$pe2 : 0 : 0;\n    state.conversion = null;\n    state.move = null;\n  }\n\n  return shouldTerminate;\n}\n\nexports.Command = void 0;\n\n(function (Command) {\n  Command[Command[\"SPLIT_MESSAGE\"] = 16] = \"SPLIT_MESSAGE\";\n  Command[Command[\"MESSAGE_SIZES\"] = 53] = \"MESSAGE_SIZES\";\n  Command[Command[\"GAME_START\"] = 54] = \"GAME_START\";\n  Command[Command[\"PRE_FRAME_UPDATE\"] = 55] = \"PRE_FRAME_UPDATE\";\n  Command[Command[\"POST_FRAME_UPDATE\"] = 56] = \"POST_FRAME_UPDATE\";\n  Command[Command[\"GAME_END\"] = 57] = \"GAME_END\";\n  Command[Command[\"FRAME_START\"] = 58] = \"FRAME_START\";\n  Command[Command[\"ITEM_UPDATE\"] = 59] = \"ITEM_UPDATE\";\n  Command[Command[\"FRAME_BOOKEND\"] = 60] = \"FRAME_BOOKEND\";\n  Command[Command[\"GECKO_LIST\"] = 61] = \"GECKO_LIST\";\n})(exports.Command || (exports.Command = {}));\n\nexports.GameMode = void 0;\n\n(function (GameMode) {\n  GameMode[GameMode[\"VS\"] = 2] = \"VS\";\n  GameMode[GameMode[\"ONLINE\"] = 8] = \"ONLINE\";\n  GameMode[GameMode[\"TARGET_TEST\"] = 15] = \"TARGET_TEST\";\n  GameMode[GameMode[\"HOME_RUN_CONTEST\"] = 32] = \"HOME_RUN_CONTEST\";\n})(exports.GameMode || (exports.GameMode = {}));\n\nexports.Language = void 0;\n\n(function (Language) {\n  Language[Language[\"JAPANESE\"] = 0] = \"JAPANESE\";\n  Language[Language[\"ENGLISH\"] = 1] = \"ENGLISH\";\n})(exports.Language || (exports.Language = {}));\n\nexports.TimerType = void 0;\n\n(function (TimerType) {\n  TimerType[TimerType[\"NONE\"] = 0] = \"NONE\";\n  TimerType[TimerType[\"DECREASING\"] = 2] = \"DECREASING\";\n  TimerType[TimerType[\"INCREASING\"] = 3] = \"INCREASING\";\n})(exports.TimerType || (exports.TimerType = {}));\n\nexports.ItemSpawnType = void 0;\n\n(function (ItemSpawnType) {\n  ItemSpawnType[ItemSpawnType[\"OFF\"] = 255] = \"OFF\";\n  ItemSpawnType[ItemSpawnType[\"VERY_LOW\"] = 0] = \"VERY_LOW\";\n  ItemSpawnType[ItemSpawnType[\"LOW\"] = 1] = \"LOW\";\n  ItemSpawnType[ItemSpawnType[\"MEDIUM\"] = 2] = \"MEDIUM\";\n  ItemSpawnType[ItemSpawnType[\"HIGH\"] = 3] = \"HIGH\";\n  ItemSpawnType[ItemSpawnType[\"VERY_HIGH\"] = 4] = \"VERY_HIGH\";\n})(exports.ItemSpawnType || (exports.ItemSpawnType = {}));\n\nexports.EnabledItemType = void 0;\n\n(function (EnabledItemType) {\n  EnabledItemType[EnabledItemType[\"METAL_BOX\"] = 1] = \"METAL_BOX\";\n  EnabledItemType[EnabledItemType[\"CLOAKING_DEVICE\"] = 2] = \"CLOAKING_DEVICE\";\n  EnabledItemType[EnabledItemType[\"POKEBALL\"] = 4] = \"POKEBALL\"; // Bits 4 through 8 of item bitfield 1 are unknown\n\n  EnabledItemType[EnabledItemType[\"UNKNOWN_ITEM_BIT_4\"] = 8] = \"UNKNOWN_ITEM_BIT_4\";\n  EnabledItemType[EnabledItemType[\"UNKNOWN_ITEM_BIT_5\"] = 16] = \"UNKNOWN_ITEM_BIT_5\";\n  EnabledItemType[EnabledItemType[\"UNKNOWN_ITEM_BIT_6\"] = 32] = \"UNKNOWN_ITEM_BIT_6\";\n  EnabledItemType[EnabledItemType[\"UNKNOWN_ITEM_BIT_7\"] = 64] = \"UNKNOWN_ITEM_BIT_7\";\n  EnabledItemType[EnabledItemType[\"UNKNOWN_ITEM_BIT_8\"] = 128] = \"UNKNOWN_ITEM_BIT_8\";\n  EnabledItemType[EnabledItemType[\"FAN\"] = 256] = \"FAN\";\n  EnabledItemType[EnabledItemType[\"FIRE_FLOWER\"] = 512] = \"FIRE_FLOWER\";\n  EnabledItemType[EnabledItemType[\"SUPER_MUSHROOM\"] = 1024] = \"SUPER_MUSHROOM\";\n  EnabledItemType[EnabledItemType[\"POISON_MUSHROOM\"] = 2048] = \"POISON_MUSHROOM\";\n  EnabledItemType[EnabledItemType[\"HAMMER\"] = 4096] = \"HAMMER\";\n  EnabledItemType[EnabledItemType[\"WARP_STAR\"] = 8192] = \"WARP_STAR\";\n  EnabledItemType[EnabledItemType[\"SCREW_ATTACK\"] = 16384] = \"SCREW_ATTACK\";\n  EnabledItemType[EnabledItemType[\"BUNNY_HOOD\"] = 32768] = \"BUNNY_HOOD\";\n  EnabledItemType[EnabledItemType[\"RAY_GUN\"] = 65536] = \"RAY_GUN\";\n  EnabledItemType[EnabledItemType[\"FREEZIE\"] = 131072] = \"FREEZIE\";\n  EnabledItemType[EnabledItemType[\"FOOD\"] = 262144] = \"FOOD\";\n  EnabledItemType[EnabledItemType[\"MOTION_SENSOR_BOMB\"] = 524288] = \"MOTION_SENSOR_BOMB\";\n  EnabledItemType[EnabledItemType[\"FLIPPER\"] = 1048576] = \"FLIPPER\";\n  EnabledItemType[EnabledItemType[\"SUPER_SCOPE\"] = 2097152] = \"SUPER_SCOPE\";\n  EnabledItemType[EnabledItemType[\"STAR_ROD\"] = 4194304] = \"STAR_ROD\";\n  EnabledItemType[EnabledItemType[\"LIPS_STICK\"] = 8388608] = \"LIPS_STICK\";\n  EnabledItemType[EnabledItemType[\"HEART_CONTAINER\"] = 16777216] = \"HEART_CONTAINER\";\n  EnabledItemType[EnabledItemType[\"MAXIM_TOMATO\"] = 33554432] = \"MAXIM_TOMATO\";\n  EnabledItemType[EnabledItemType[\"STARMAN\"] = 67108864] = \"STARMAN\";\n  EnabledItemType[EnabledItemType[\"HOME_RUN_BAT\"] = 134217728] = \"HOME_RUN_BAT\";\n  EnabledItemType[EnabledItemType[\"BEAM_SWORD\"] = 268435456] = \"BEAM_SWORD\";\n  EnabledItemType[EnabledItemType[\"PARASOL\"] = 536870912] = \"PARASOL\";\n  EnabledItemType[EnabledItemType[\"GREEN_SHELL\"] = 1073741824] = \"GREEN_SHELL\";\n  EnabledItemType[EnabledItemType[\"RED_SHELL\"] = 2147483648] = \"RED_SHELL\";\n  EnabledItemType[EnabledItemType[\"CAPSULE\"] = 4294967296] = \"CAPSULE\";\n  EnabledItemType[EnabledItemType[\"BOX\"] = 8589934592] = \"BOX\";\n  EnabledItemType[EnabledItemType[\"BARREL\"] = 17179869184] = \"BARREL\";\n  EnabledItemType[EnabledItemType[\"EGG\"] = 34359738368] = \"EGG\";\n  EnabledItemType[EnabledItemType[\"PARTY_BALL\"] = 68719476736] = \"PARTY_BALL\";\n  EnabledItemType[EnabledItemType[\"BARREL_CANNON\"] = 137438953472] = \"BARREL_CANNON\";\n  EnabledItemType[EnabledItemType[\"BOMB_OMB\"] = 274877906944] = \"BOMB_OMB\";\n  EnabledItemType[EnabledItemType[\"MR_SATURN\"] = 549755813888] = \"MR_SATURN\";\n})(exports.EnabledItemType || (exports.EnabledItemType = {}));\n\nexports.GameEndMethod = void 0;\n\n(function (GameEndMethod) {\n  GameEndMethod[GameEndMethod[\"UNRESOLVED\"] = 0] = \"UNRESOLVED\";\n  GameEndMethod[GameEndMethod[\"RESOLVED\"] = 3] = \"RESOLVED\"; // The following options are only returned in version 2.0.0 onwards\n\n  GameEndMethod[GameEndMethod[\"TIME\"] = 1] = \"TIME\";\n  GameEndMethod[GameEndMethod[\"GAME\"] = 2] = \"GAME\";\n  GameEndMethod[GameEndMethod[\"NO_CONTEST\"] = 7] = \"NO_CONTEST\";\n})(exports.GameEndMethod || (exports.GameEndMethod = {}));\n\nexports.Frames = void 0;\n\n(function (Frames) {\n  Frames[Frames[\"FIRST\"] = -123] = \"FIRST\";\n  Frames[Frames[\"FIRST_PLAYABLE\"] = -39] = \"FIRST_PLAYABLE\";\n})(exports.Frames || (exports.Frames = {}));\n\nvar JoystickRegion;\n\n(function (JoystickRegion) {\n  JoystickRegion[JoystickRegion[\"DZ\"] = 0] = \"DZ\";\n  JoystickRegion[JoystickRegion[\"NE\"] = 1] = \"NE\";\n  JoystickRegion[JoystickRegion[\"SE\"] = 2] = \"SE\";\n  JoystickRegion[JoystickRegion[\"SW\"] = 3] = \"SW\";\n  JoystickRegion[JoystickRegion[\"NW\"] = 4] = \"NW\";\n  JoystickRegion[JoystickRegion[\"N\"] = 5] = \"N\";\n  JoystickRegion[JoystickRegion[\"E\"] = 6] = \"E\";\n  JoystickRegion[JoystickRegion[\"S\"] = 7] = \"S\";\n  JoystickRegion[JoystickRegion[\"W\"] = 8] = \"W\";\n})(JoystickRegion || (JoystickRegion = {}));\n\nclass InputComputer {\n  constructor() {\n    this.state = new Map();\n    this.playerPermutations = new Array();\n  }\n\n  setup(settings) {\n    // Reset the state\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.playerPermutations.forEach(indices => {\n      const playerState = {\n        playerIndex: indices.playerIndex,\n        opponentIndex: indices.opponentIndex,\n        inputCount: 0,\n        joystickInputCount: 0,\n        cstickInputCount: 0,\n        buttonInputCount: 0,\n        triggerInputCount: 0\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  processFrame(frame, allFrames) {\n    this.playerPermutations.forEach(indices => {\n      const state = this.state.get(indices);\n\n      if (state) {\n        handleInputCompute(allFrames, state, indices, frame);\n      }\n    });\n  }\n\n  fetch() {\n    return Array.from(this.state.values());\n  }\n\n}\n\nfunction handleInputCompute(frames, state, indices, frame) {\n  const playerFrame = frame.players[indices.playerIndex].pre;\n  const currentFrameNumber = playerFrame.frame;\n  const prevFrameNumber = currentFrameNumber - 1;\n  const prevPlayerFrame = frames[prevFrameNumber] ? frames[prevFrameNumber].players[indices.playerIndex].pre : null;\n\n  if (currentFrameNumber < exports.Frames.FIRST_PLAYABLE || !prevPlayerFrame) {\n    // Don't count inputs until the game actually starts\n    return;\n  } // First count the number of buttons that go from 0 to 1\n  // Increment action count by amount of button presses\n\n\n  const invertedPreviousButtons = ~prevPlayerFrame.physicalButtons;\n  const currentButtons = playerFrame.physicalButtons;\n  const buttonChanges = invertedPreviousButtons & currentButtons & 0xfff;\n  const newInputsPressed = countSetBits(buttonChanges);\n  state.inputCount += newInputsPressed;\n  state.buttonInputCount += newInputsPressed; // Increment action count when sticks change from one region to another.\n  // Don't increment when stick returns to deadzone\n\n  const prevAnalogRegion = getJoystickRegion(prevPlayerFrame.joystickX, prevPlayerFrame.joystickY);\n  const currentAnalogRegion = getJoystickRegion(playerFrame.joystickX, playerFrame.joystickY);\n\n  if (prevAnalogRegion !== currentAnalogRegion && currentAnalogRegion !== JoystickRegion.DZ) {\n    state.inputCount += 1;\n    state.joystickInputCount += 1;\n  } // Do the same for c-stick\n\n\n  const prevCstickRegion = getJoystickRegion(prevPlayerFrame.cStickX, prevPlayerFrame.cStickY);\n  const currentCstickRegion = getJoystickRegion(playerFrame.cStickX, playerFrame.cStickY);\n\n  if (prevCstickRegion !== currentCstickRegion && currentCstickRegion !== JoystickRegion.DZ) {\n    state.inputCount += 1;\n    state.cstickInputCount += 1;\n  } // Increment action on analog trigger... I'm not sure when. This needs revision\n  // Currently will update input count when the button gets pressed past 0.3\n  // Changes from hard shield to light shield should probably count as inputs but\n  // are not counted here\n\n\n  if (prevPlayerFrame.physicalLTrigger < 0.3 && playerFrame.physicalLTrigger >= 0.3) {\n    state.inputCount += 1;\n    state.triggerInputCount += 1;\n  }\n\n  if (prevPlayerFrame.physicalRTrigger < 0.3 && playerFrame.physicalRTrigger >= 0.3) {\n    state.inputCount += 1;\n    state.triggerInputCount += 1;\n  }\n}\n\nfunction countSetBits(x) {\n  // This function solves the Hamming Weight problem. Effectively it counts the number of\n  // bits in the input that are set to 1\n  // This implementation is supposedly very efficient when most bits are zero.\n  // Found: https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation\n  let bits = x;\n  let count;\n\n  for (count = 0; bits; count += 1) {\n    bits &= bits - 1;\n  }\n\n  return count;\n}\n\nfunction getJoystickRegion(x, y) {\n  let region = JoystickRegion.DZ;\n\n  if (x >= 0.2875 && y >= 0.2875) {\n    region = JoystickRegion.NE;\n  } else if (x >= 0.2875 && y <= -0.2875) {\n    region = JoystickRegion.SE;\n  } else if (x <= -0.2875 && y <= -0.2875) {\n    region = JoystickRegion.SW;\n  } else if (x <= -0.2875 && y >= 0.2875) {\n    region = JoystickRegion.NW;\n  } else if (y >= 0.2875) {\n    region = JoystickRegion.N;\n  } else if (x >= 0.2875) {\n    region = JoystickRegion.E;\n  } else if (y <= -0.2875) {\n    region = JoystickRegion.S;\n  } else if (x <= -0.2875) {\n    region = JoystickRegion.W;\n  }\n\n  return region;\n}\n\nfunction generateOverallStats({\n  settings,\n  inputs,\n  conversions,\n  playableFrameCount\n}) {\n  const inputsByPlayer = lodash.keyBy(inputs, \"playerIndex\");\n  const originalConversions = conversions;\n  const conversionsByPlayer = lodash.groupBy(conversions, conv => {\n    var _conv$moves$;\n\n    return (_conv$moves$ = conv.moves[0]) == null ? void 0 : _conv$moves$.playerIndex;\n  });\n  const conversionsByPlayerByOpening = lodash.mapValues(conversionsByPlayer, conversions => lodash.groupBy(conversions, \"openingType\"));\n  const gameMinutes = playableFrameCount / 3600;\n  const overall = settings.players.map(player => {\n    const playerIndex = player.playerIndex;\n    const playerInputs = lodash.get(inputsByPlayer, playerIndex) || {};\n    const inputCounts = {\n      buttons: lodash.get(playerInputs, \"buttonInputCount\"),\n      triggers: lodash.get(playerInputs, \"triggerInputCount\"),\n      cstick: lodash.get(playerInputs, \"cstickInputCount\"),\n      joystick: lodash.get(playerInputs, \"joystickInputCount\"),\n      total: lodash.get(playerInputs, \"inputCount\")\n    }; // const conversions = get(conversionsByPlayer, playerIndex) || [];\n    // const successfulConversions = conversions.filter((conversion) => conversion.moves.length > 1);\n\n    let conversionCount = 0;\n    let successfulConversionCount = 0;\n    const opponentIndices = settings.players.filter(opp => {\n      // We want players which aren't ourselves\n      if (opp.playerIndex === playerIndex) {\n        return false;\n      } // Make sure they're not on our team either\n\n\n      return !settings.isTeams || opp.teamId !== player.teamId;\n    }).map(opp => opp.playerIndex);\n    let totalDamage = 0;\n    let killCount = 0; // These are the conversions that we did on our opponents\n\n    originalConversions // Filter down to conversions of our opponent\n    .filter(conversion => conversion.playerIndex !== playerIndex).forEach(conversion => {\n      conversionCount++; // We killed the opponent\n\n      if (conversion.didKill && conversion.lastHitBy === playerIndex) {\n        killCount += 1;\n      }\n\n      if (conversion.moves.length > 1 && conversion.moves[0].playerIndex === playerIndex) {\n        successfulConversionCount++;\n      }\n\n      conversion.moves.forEach(move => {\n        if (move.playerIndex === playerIndex) {\n          totalDamage += move.damage;\n        }\n      });\n    });\n    return {\n      playerIndex: playerIndex,\n      inputCounts: inputCounts,\n      conversionCount: conversionCount,\n      totalDamage: totalDamage,\n      killCount: killCount,\n      successfulConversions: getRatio(successfulConversionCount, conversionCount),\n      inputsPerMinute: getRatio(inputCounts.total, gameMinutes),\n      digitalInputsPerMinute: getRatio(inputCounts.buttons, gameMinutes),\n      openingsPerKill: getRatio(conversionCount, killCount),\n      damagePerOpening: getRatio(totalDamage, conversionCount),\n      neutralWinRatio: getOpeningRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices, \"neutral-win\"),\n      counterHitRatio: getOpeningRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices, \"counter-attack\"),\n      beneficialTradeRatio: getBeneficialTradeRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices)\n    };\n  });\n  return overall;\n}\n\nfunction getRatio(count, total) {\n  return {\n    count: count,\n    total: total,\n    ratio: total ? count / total : null\n  };\n}\n\nfunction getOpeningRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices, type) {\n  const openings = lodash.get(conversionsByPlayerByOpening, [playerIndex, type]) || [];\n  const opponentOpenings = lodash.flatten(opponentIndices.map(opponentIndex => lodash.get(conversionsByPlayerByOpening, [opponentIndex, type]) || []));\n  return getRatio(openings.length, openings.length + opponentOpenings.length);\n}\n\nfunction getBeneficialTradeRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices) {\n  const playerTrades = lodash.get(conversionsByPlayerByOpening, [playerIndex, \"trade\"]) || [];\n  const opponentTrades = lodash.flatten(opponentIndices.map(opponentIndex => lodash.get(conversionsByPlayerByOpening, [opponentIndex, \"trade\"]) || []));\n  const benefitsPlayer = []; // Figure out which punishes benefited this player\n\n  const zippedTrades = lodash.zip(playerTrades, opponentTrades);\n  zippedTrades.forEach(conversionPair => {\n    const playerConversion = lodash.first(conversionPair);\n    const opponentConversion = lodash.last(conversionPair);\n\n    if (playerConversion && opponentConversion) {\n      const playerDamage = playerConversion.currentPercent - playerConversion.startPercent;\n      const opponentDamage = opponentConversion.currentPercent - opponentConversion.startPercent;\n\n      if (playerConversion.didKill && !opponentConversion.didKill) {\n        benefitsPlayer.push(playerConversion);\n      } else if (playerDamage > opponentDamage) {\n        benefitsPlayer.push(playerConversion);\n      }\n    }\n  });\n  return getRatio(benefitsPlayer.length, playerTrades.length);\n}\n\nconst defaultOptions = {\n  processOnTheFly: false\n};\nclass Stats {\n  constructor(options) {\n    this.options = void 0;\n    this.lastProcessedFrame = null;\n    this.frames = {};\n    this.players = [];\n    this.allComputers = new Array();\n    this.options = Object.assign({}, defaultOptions, options);\n  }\n  /**\r\n   * Should reset the frames to their default values.\r\n   */\n\n\n  setup(settings) {\n    // Reset the frames since it's a new game\n    this.frames = {};\n    this.players = settings.players.map(v => v.playerIndex); // Forward the settings on to the individual stat computer\n\n    this.allComputers.forEach(comp => comp.setup(settings));\n  }\n\n  register(...computer) {\n    this.allComputers.push(...computer);\n  }\n\n  process() {\n    if (this.players.length === 0) {\n      return;\n    }\n\n    let i = this.lastProcessedFrame !== null ? this.lastProcessedFrame + 1 : exports.Frames.FIRST;\n\n    while (this.frames[i]) {\n      const frame = this.frames[i]; // Don't attempt to compute stats on frames that have not been fully received\n\n      if (!isCompletedFrame(this.players, frame)) {\n        return;\n      }\n\n      this.allComputers.forEach(comp => comp.processFrame(frame, this.frames));\n      this.lastProcessedFrame = i;\n      i++;\n    }\n  }\n\n  addFrame(frame) {\n    this.frames[frame.frame] = frame;\n\n    if (this.options.processOnTheFly) {\n      this.process();\n    }\n  }\n\n}\n\nfunction isCompletedFrame(players, frame) {\n  if (!frame) {\n    return false;\n  } // This function checks whether we have successfully received an entire frame.\n  // It is not perfect because it does not wait for follower frames. Fortunately,\n  // follower frames are not used for any stat calculations so this doesn't matter\n  // for our purposes.\n\n\n  for (const player of players) {\n    const playerPostFrame = lodash.get(frame, [\"players\", player, \"post\"]);\n\n    if (!playerPostFrame) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nclass StockComputer {\n  constructor() {\n    this.state = new Map();\n    this.playerPermutations = new Array();\n    this.stocks = new Array();\n  }\n\n  setup(settings) {\n    // Reset state\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.stocks = [];\n    this.playerPermutations.forEach(indices => {\n      const playerState = {\n        stock: null\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  processFrame(frame, allFrames) {\n    this.playerPermutations.forEach(indices => {\n      const state = this.state.get(indices);\n\n      if (state) {\n        handleStockCompute(allFrames, state, indices, frame, this.stocks);\n      }\n    });\n  }\n\n  fetch() {\n    return this.stocks;\n  }\n\n}\n\nfunction handleStockCompute(frames, state, indices, frame, stocks) {\n  const playerFrame = frame.players[indices.playerIndex].post;\n  const currentFrameNumber = playerFrame.frame;\n  const prevFrameNumber = currentFrameNumber - 1;\n  const prevPlayerFrame = frames[prevFrameNumber] ? frames[prevFrameNumber].players[indices.playerIndex].post : null; // If there is currently no active stock, wait until the player is no longer spawning.\n  // Once the player is no longer spawning, start the stock\n\n  if (!state.stock) {\n    const isPlayerDead = isDead(playerFrame.actionStateId);\n\n    if (isPlayerDead) {\n      return;\n    }\n\n    state.stock = {\n      playerIndex: indices.playerIndex,\n      startFrame: currentFrameNumber,\n      endFrame: null,\n      startPercent: 0,\n      endPercent: null,\n      currentPercent: 0,\n      count: playerFrame.stocksRemaining,\n      deathAnimation: null\n    };\n    stocks.push(state.stock);\n  } else if (prevPlayerFrame && didLoseStock(playerFrame, prevPlayerFrame)) {\n    var _prevPlayerFrame$perc;\n\n    state.stock.endFrame = playerFrame.frame;\n    state.stock.endPercent = (_prevPlayerFrame$perc = prevPlayerFrame.percent) != null ? _prevPlayerFrame$perc : 0;\n    state.stock.deathAnimation = playerFrame.actionStateId;\n    state.stock = null;\n  } else {\n    var _playerFrame$percent;\n\n    state.stock.currentPercent = (_playerFrame$percent = playerFrame.percent) != null ? _playerFrame$percent : 0;\n  }\n}\n\n// Based on https://github.com/wilsonzlin/edgesearch/blob/d03816dd4b18d3d2eb6d08cb1ae14f96f046141d/demo/wiki/client/src/util/util.ts\n// Ensures value is not null or undefined.\n// != does no type validation so we don't need to explcitly check for undefined.\nfunction exists(value) {\n  return value != null;\n}\n\nconst TARGET_ITEM_TYPE_ID = 209;\nclass TargetBreakComputer {\n  constructor() {\n    this.targetBreaks = new Array();\n    this.isTargetTestGame = false;\n  }\n\n  setup(settings) {\n    // Reset the state\n    this.targetBreaks = [];\n    this.isTargetTestGame = settings.gameMode === exports.GameMode.TARGET_TEST;\n  }\n\n  processFrame(frame, allFrames) {\n    if (!this.isTargetTestGame) {\n      return;\n    }\n\n    handleTargetBreak(allFrames, frame, this.targetBreaks);\n  }\n\n  fetch() {\n    return this.targetBreaks;\n  }\n\n}\n\nfunction handleTargetBreak(frames, frame, targetBreaks) {\n  var _frames$currentFrameN, _frames$currentFrameN2, _frames$currentFrameN3, _frames$prevFrameNumb, _frames$prevFrameNumb2, _frames$prevFrameNumb3;\n\n  const currentFrameNumber = frame.frame;\n  const prevFrameNumber = currentFrameNumber - 1; // Add all targets on the first frame\n\n  if (currentFrameNumber === exports.Frames.FIRST) {\n    var _frames$Frames$FIRST$, _frames$Frames$FIRST, _frames$Frames$FIRST$2;\n\n    const targets = (_frames$Frames$FIRST$ = (_frames$Frames$FIRST = frames[exports.Frames.FIRST]) == null ? void 0 : (_frames$Frames$FIRST$2 = _frames$Frames$FIRST.items) == null ? void 0 : _frames$Frames$FIRST$2.filter(item => item.typeId === TARGET_ITEM_TYPE_ID)) != null ? _frames$Frames$FIRST$ : [];\n    targets.forEach(target => {\n      targetBreaks.push({\n        spawnId: target.spawnId,\n        frameDestroyed: null,\n        positionX: target.positionX,\n        positionY: target.positionY\n      });\n    });\n  }\n\n  const currentTargets = (_frames$currentFrameN = (_frames$currentFrameN2 = frames[currentFrameNumber]) == null ? void 0 : (_frames$currentFrameN3 = _frames$currentFrameN2.items) == null ? void 0 : _frames$currentFrameN3.filter(item => item.typeId === TARGET_ITEM_TYPE_ID)) != null ? _frames$currentFrameN : [];\n  const previousTargets = (_frames$prevFrameNumb = (_frames$prevFrameNumb2 = frames[prevFrameNumber]) == null ? void 0 : (_frames$prevFrameNumb3 = _frames$prevFrameNumb2.items) == null ? void 0 : _frames$prevFrameNumb3.filter(item => item.typeId === TARGET_ITEM_TYPE_ID)) != null ? _frames$prevFrameNumb : [];\n  const currentTargetIds = currentTargets.map(item => item.spawnId).filter(exists);\n  const previousTargetIds = previousTargets.map(item => item.spawnId).filter(exists); // Check if any targets were destroyed\n\n  const brokenTargetIds = previousTargetIds.filter(id => !currentTargetIds.includes(id));\n  brokenTargetIds.forEach(id => {\n    // Update the target break\n    const targetBreak = targetBreaks.find(targetBreak => targetBreak.spawnId === id);\n\n    if (targetBreak) {\n      targetBreak.frameDestroyed = currentFrameNumber;\n    }\n  });\n}\n\nfunction frameToGameTimer(frame, options) {\n  const {\n    timerType,\n    startingTimerSeconds\n  } = options;\n\n  if (timerType === exports.TimerType.DECREASING) {\n    if (!exists(startingTimerSeconds)) {\n      return \"Unknown\";\n    }\n\n    const centiseconds = Math.ceil((60 - frame % 60) % 60 * 99 / 59);\n    const date = new Date(0, 0, 0, 0, 0, startingTimerSeconds - frame / 60, centiseconds * 10);\n    return dateFns.format(date, \"mm:ss.SS\");\n  }\n\n  if (timerType === exports.TimerType.INCREASING) {\n    const centiseconds = Math.floor(frame % 60 * 99 / 59);\n    const date = new Date(0, 0, 0, 0, 0, frame / 60, centiseconds * 10);\n    return dateFns.format(date, \"mm:ss.SS\");\n  }\n\n  return \"Infinite\";\n}\n\nexports.CommunicationType = void 0;\n\n(function (CommunicationType) {\n  CommunicationType[CommunicationType[\"HANDSHAKE\"] = 1] = \"HANDSHAKE\";\n  CommunicationType[CommunicationType[\"REPLAY\"] = 2] = \"REPLAY\";\n  CommunicationType[CommunicationType[\"KEEP_ALIVE\"] = 3] = \"KEEP_ALIVE\";\n})(exports.CommunicationType || (exports.CommunicationType = {})); // This class is responsible for handling the communication protocol between the Wii and the\n// desktop app\n\n\nclass ConsoleCommunication {\n  constructor() {\n    this.receiveBuf = Buffer.from([]);\n    this.messages = new Array();\n  }\n\n  receive(data) {\n    this.receiveBuf = Buffer.concat([this.receiveBuf, data]);\n\n    while (this.receiveBuf.length >= 4) {\n      // First get the size of the message we are expecting\n      const msgSize = this.receiveBuf.readUInt32BE(0);\n\n      if (this.receiveBuf.length < msgSize + 4) {\n        // If we haven't received all the data yet, let's wait for more\n        return;\n      } // Here we have received all the data, so let's decode it\n\n\n      const ubjsonData = this.receiveBuf.slice(4, msgSize + 4);\n      this.messages.push(ubjson.decode(ubjsonData)); // Remove the processed data from receiveBuf\n\n      this.receiveBuf = this.receiveBuf.slice(msgSize + 4);\n    }\n  }\n\n  getReceiveBuffer() {\n    return this.receiveBuf;\n  }\n\n  getMessages() {\n    const toReturn = this.messages;\n    this.messages = [];\n    return toReturn;\n  }\n\n  genHandshakeOut(cursor, clientToken, isRealtime = false) {\n    const clientTokenBuf = Buffer.from([0, 0, 0, 0]);\n    clientTokenBuf.writeUInt32BE(clientToken, 0);\n    const message = {\n      type: exports.CommunicationType.HANDSHAKE,\n      payload: {\n        cursor: cursor,\n        clientToken: Uint8Array.from(clientTokenBuf),\n        isRealtime: isRealtime\n      }\n    };\n    const buf = ubjson.encode(message, {\n      optimizeArrays: true\n    });\n    const msg = Buffer.concat([Buffer.from([0, 0, 0, 0]), Buffer.from(buf)]);\n    msg.writeUInt32BE(buf.byteLength, 0);\n    return msg;\n  }\n\n}\n\nexports.ConnectionEvent = void 0;\n\n(function (ConnectionEvent) {\n  ConnectionEvent[\"CONNECT\"] = \"connect\";\n  ConnectionEvent[\"MESSAGE\"] = \"message\";\n  ConnectionEvent[\"HANDSHAKE\"] = \"handshake\";\n  ConnectionEvent[\"STATUS_CHANGE\"] = \"statusChange\";\n  ConnectionEvent[\"DATA\"] = \"data\";\n  ConnectionEvent[\"ERROR\"] = \"error\";\n})(exports.ConnectionEvent || (exports.ConnectionEvent = {}));\n\nexports.ConnectionStatus = void 0;\n\n(function (ConnectionStatus) {\n  ConnectionStatus[ConnectionStatus[\"DISCONNECTED\"] = 0] = \"DISCONNECTED\";\n  ConnectionStatus[ConnectionStatus[\"CONNECTING\"] = 1] = \"CONNECTING\";\n  ConnectionStatus[ConnectionStatus[\"CONNECTED\"] = 2] = \"CONNECTED\";\n  ConnectionStatus[ConnectionStatus[\"RECONNECT_WAIT\"] = 3] = \"RECONNECT_WAIT\";\n})(exports.ConnectionStatus || (exports.ConnectionStatus = {}));\n\nexports.Ports = void 0;\n\n(function (Ports) {\n  Ports[Ports[\"DEFAULT\"] = 51441] = \"DEFAULT\";\n  Ports[Ports[\"LEGACY\"] = 666] = \"LEGACY\";\n  Ports[Ports[\"RELAY_START\"] = 53741] = \"RELAY_START\";\n})(exports.Ports || (exports.Ports = {}));\n\nconst NETWORK_MESSAGE = \"HELO\\0\";\nconst DEFAULT_CONNECTION_TIMEOUT_MS = 20000;\nvar CommunicationState;\n\n(function (CommunicationState) {\n  CommunicationState[\"INITIAL\"] = \"initial\";\n  CommunicationState[\"LEGACY\"] = \"legacy\";\n  CommunicationState[\"NORMAL\"] = \"normal\";\n})(CommunicationState || (CommunicationState = {}));\n\nconst defaultConnectionDetails = {\n  consoleNick: \"unknown\",\n  gameDataCursor: /*#__PURE__*/Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0]),\n  version: \"\",\n  clientToken: 0\n};\nconst consoleConnectionOptions = {\n  autoReconnect: true\n};\n/**\r\n * Responsible for maintaining connection to a Slippi relay connection or Wii connection.\r\n * Events are emitted whenever data is received.\r\n *\r\n * Basic usage example:\r\n *\r\n * ```javascript\r\n * const { ConsoleConnection } = require(\"@slippi/slippi-js\");\r\n *\r\n * const connection = new ConsoleConnection();\r\n * connection.connect(\"localhost\", 667); // You should set these values appropriately\r\n *\r\n * connection.on(\"data\", (data) => {\r\n *   // Received data from console\r\n *   console.log(data);\r\n * });\r\n *\r\n * connection.on(\"statusChange\", (status) => {\r\n *   console.log(`status changed: ${status}`);\r\n * });\r\n * ```\r\n */\n\nclass ConsoleConnection extends events.EventEmitter {\n  constructor(options) {\n    super();\n    this.ipAddress = void 0;\n    this.port = void 0;\n    this.isRealtime = void 0;\n    this.connectionStatus = exports.ConnectionStatus.DISCONNECTED;\n    this.connDetails = { ...defaultConnectionDetails\n    };\n    this.client = null;\n    this.connection = null;\n    this.options = void 0;\n    this.shouldReconnect = false;\n    this.ipAddress = \"0.0.0.0\";\n    this.port = exports.Ports.DEFAULT;\n    this.isRealtime = false;\n    this.options = Object.assign({}, consoleConnectionOptions, options);\n  }\n  /**\r\n   * @returns The current connection status.\r\n   */\n\n\n  getStatus() {\n    return this.connectionStatus;\n  }\n  /**\r\n   * @returns The IP address and port of the current connection.\r\n   */\n\n\n  getSettings() {\n    return {\n      ipAddress: this.ipAddress,\n      port: this.port\n    };\n  }\n  /**\r\n   * @returns The specific details about the connected console.\r\n   */\n\n\n  getDetails() {\n    return { ...this.connDetails\n    };\n  }\n  /**\r\n   * Initiate a connection to the Wii or Slippi relay.\r\n   * @param ip   The IP address of the Wii or Slippi relay.\r\n   * @param port The port to connect to.\r\n   * @param isRealtime Optional. A flag to tell the Wii to send data as quickly as possible\r\n   * @param timeout Optional. The timeout in milliseconds when attempting to connect\r\n   *                to the Wii or relay.\r\n   */\n\n\n  connect(ip, port, isRealtime = false, timeout = DEFAULT_CONNECTION_TIMEOUT_MS) {\n    this.ipAddress = ip;\n    this.port = port;\n    this.isRealtime = isRealtime;\n\n    this._connectOnPort(ip, port, timeout);\n  }\n\n  _connectOnPort(ip, port, timeout) {\n    // set up reconnect\n    const reconnect = inject__default[\"default\"](() => net__default[\"default\"].connect({\n      host: ip,\n      port: port,\n      timeout: timeout\n    })); // Indicate we are connecting\n\n    this._setStatus(exports.ConnectionStatus.CONNECTING); // Prepare console communication obj for talking UBJSON\n\n\n    const consoleComms = new ConsoleCommunication(); // TODO: reconnect on failed reconnect, not sure how\n    // TODO: to do this\n\n    const connection = reconnect({\n      initialDelay: 2000,\n      maxDelay: 10000,\n      strategy: \"fibonacci\",\n      failAfter: Infinity\n    }, client => {\n      var _this$connDetails$cli;\n\n      this.emit(exports.ConnectionEvent.CONNECT); // We successfully connected so turn on auto-reconnect\n\n      this.shouldReconnect = this.options.autoReconnect;\n      this.client = client;\n      let commState = CommunicationState.INITIAL;\n      client.on(\"data\", data => {\n        if (commState === CommunicationState.INITIAL) {\n          commState = this._getInitialCommState(data);\n          console.log(`Connected to ${ip}:${port} with type: ${commState}`);\n\n          this._setStatus(exports.ConnectionStatus.CONNECTED);\n\n          console.log(data.toString(\"hex\"));\n        }\n\n        if (commState === CommunicationState.LEGACY) {\n          // If the first message received was not a handshake message, either we\n          // connected to an old Nintendont version or a relay instance\n          this._handleReplayData(data);\n\n          return;\n        }\n\n        try {\n          consoleComms.receive(data);\n        } catch (err) {\n          console.error(\"Failed to process new data from server...\", {\n            error: err,\n            prevDataBuf: consoleComms.getReceiveBuffer(),\n            rcvData: data\n          });\n          client.destroy();\n          this.emit(exports.ConnectionEvent.ERROR, err);\n          return;\n        }\n\n        const messages = consoleComms.getMessages(); // Process all of the received messages\n\n        try {\n          messages.forEach(message => this._processMessage(message));\n        } catch (err) {\n          // Disconnect client to send another handshake message\n          console.error(err);\n          client.destroy();\n          this.emit(exports.ConnectionEvent.ERROR, err);\n        }\n      });\n      client.on(\"timeout\", () => {\n        // const previouslyConnected = this.connectionStatus === ConnectionStatus.CONNECTED;\n        console.warn(`Attempted connection to ${ip}:${port} timed out after ${timeout}ms`);\n        client.destroy();\n      });\n      client.on(\"end\", () => {\n        console.log(\"disconnect\");\n\n        if (!this.shouldReconnect) {\n          client.destroy();\n        }\n      });\n      client.on(\"close\", () => {\n        console.log(\"connection was closed\");\n      });\n      const handshakeMsgOut = consoleComms.genHandshakeOut(this.connDetails.gameDataCursor, (_this$connDetails$cli = this.connDetails.clientToken) != null ? _this$connDetails$cli : 0, this.isRealtime);\n      client.write(handshakeMsgOut);\n    });\n\n    const setConnectingStatus = () => {\n      // Indicate we are connecting\n      this._setStatus(this.shouldReconnect ? exports.ConnectionStatus.RECONNECT_WAIT : exports.ConnectionStatus.CONNECTING);\n    };\n\n    connection.on(\"connect\", setConnectingStatus);\n    connection.on(\"reconnect\", setConnectingStatus);\n    connection.on(\"disconnect\", () => {\n      if (!this.shouldReconnect) {\n        connection.reconnect = false;\n        connection.disconnect();\n\n        this._setStatus(exports.ConnectionStatus.DISCONNECTED);\n      } // TODO: Figure out how to set RECONNECT_WAIT state here. Currently it will stay on\n      // TODO: Connecting... forever\n\n    });\n    connection.on(\"error\", err => {\n      console.warn(`Connection on port ${port} encountered an error.`, err);\n\n      this._setStatus(exports.ConnectionStatus.DISCONNECTED);\n\n      this.emit(exports.ConnectionEvent.ERROR, `Connection on port ${port} encountered an error.\\n${err}`);\n    });\n    this.connection = connection;\n    connection.connect(port);\n  }\n  /**\r\n   * Terminate the current connection.\r\n   */\n\n\n  disconnect() {\n    // Prevent reconnections and disconnect\n    if (this.connection) {\n      this.connection.reconnect = false;\n      this.connection.disconnect();\n      this.connection = null;\n    }\n\n    if (this.client) {\n      this.client.destroy();\n    }\n  }\n\n  _getInitialCommState(data) {\n    if (data.length < 13) {\n      return CommunicationState.LEGACY;\n    }\n\n    const openingBytes = Buffer.from([0x7b, 0x69, 0x04, 0x74, 0x79, 0x70, 0x65, 0x55, 0x01]);\n    const dataStart = data.slice(4, 13);\n    return dataStart.equals(openingBytes) ? CommunicationState.NORMAL : CommunicationState.LEGACY;\n  }\n\n  _processMessage(message) {\n    this.emit(exports.ConnectionEvent.MESSAGE, message);\n\n    switch (message.type) {\n      case exports.CommunicationType.KEEP_ALIVE:\n        // console.log(\"Keep alive message received\");\n        // TODO: This is the jankiest shit ever but it will allow for relay connections not\n        // TODO: to time out as long as the main connection is still receving keep alive messages\n        // TODO: Need to figure out a better solution for this. There should be no need to have an\n        // TODO: active Wii connection for the relay connection to keep itself alive\n        const fakeKeepAlive = Buffer.from(NETWORK_MESSAGE);\n\n        this._handleReplayData(fakeKeepAlive);\n\n        break;\n\n      case exports.CommunicationType.REPLAY:\n        const readPos = Uint8Array.from(message.payload.pos);\n        const cmp = Buffer.compare(this.connDetails.gameDataCursor, readPos);\n\n        if (!message.payload.forcePos && cmp !== 0) {\n          // The readPos is not the one we are waiting on, throw error\n          throw new Error(`Position of received data is incorrect. Expected: ${this.connDetails.gameDataCursor.toString()}, Received: ${readPos.toString()}`);\n        }\n\n        if (message.payload.forcePos) {\n          console.warn(\"Overflow occured in Nintendont, data has likely been skipped and replay corrupted. \" + \"Expected, Received:\", this.connDetails.gameDataCursor, readPos);\n        }\n\n        this.connDetails.gameDataCursor = Uint8Array.from(message.payload.nextPos);\n        const data = Uint8Array.from(message.payload.data);\n\n        this._handleReplayData(data);\n\n        break;\n\n      case exports.CommunicationType.HANDSHAKE:\n        const {\n          nick,\n          nintendontVersion\n        } = message.payload;\n\n        if (nick) {\n          this.connDetails.consoleNick = nick;\n        }\n\n        const tokenBuf = Buffer.from(message.payload.clientToken);\n        this.connDetails.clientToken = tokenBuf.readUInt32BE(0);\n\n        if (nintendontVersion) {\n          this.connDetails.version = nintendontVersion;\n        }\n\n        this.connDetails.gameDataCursor = Uint8Array.from(message.payload.pos);\n        this.emit(exports.ConnectionEvent.HANDSHAKE, this.connDetails);\n        break;\n    }\n  }\n\n  _handleReplayData(data) {\n    this.emit(exports.ConnectionEvent.DATA, data);\n  }\n\n  _setStatus(status) {\n    // Don't fire the event if the status hasn't actually changed\n    if (this.connectionStatus !== status) {\n      this.connectionStatus = status;\n      this.emit(exports.ConnectionEvent.STATUS_CHANGE, this.connectionStatus);\n    }\n  }\n\n}\n\nconst MAX_PEERS = 32;\nexports.DolphinMessageType = void 0;\n\n(function (DolphinMessageType) {\n  DolphinMessageType[\"CONNECT_REPLY\"] = \"connect_reply\";\n  DolphinMessageType[\"GAME_EVENT\"] = \"game_event\";\n  DolphinMessageType[\"START_GAME\"] = \"start_game\";\n  DolphinMessageType[\"END_GAME\"] = \"end_game\";\n})(exports.DolphinMessageType || (exports.DolphinMessageType = {}));\n\nclass DolphinConnection extends events.EventEmitter {\n  constructor() {\n    super();\n    this.ipAddress = void 0;\n    this.port = void 0;\n    this.connectionStatus = exports.ConnectionStatus.DISCONNECTED;\n    this.gameCursor = 0;\n    this.nickname = \"unknown\";\n    this.version = \"\";\n    this.peer = null;\n    this.ipAddress = \"0.0.0.0\";\n    this.port = exports.Ports.DEFAULT;\n  }\n  /**\r\n   * @returns The current connection status.\r\n   */\n\n\n  getStatus() {\n    return this.connectionStatus;\n  }\n  /**\r\n   * @returns The IP address and port of the current connection.\r\n   */\n\n\n  getSettings() {\n    return {\n      ipAddress: this.ipAddress,\n      port: this.port\n    };\n  }\n\n  getDetails() {\n    return {\n      consoleNick: this.nickname,\n      gameDataCursor: this.gameCursor,\n      version: this.version\n    };\n  }\n\n  async connect(ip, port) {\n    console.log(`Connecting to: ${ip}:${port}`);\n    this.ipAddress = ip;\n    this.port = port;\n    const enet = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('enet')); }); // Create the enet client\n\n    const client = enet.createClient({\n      peers: MAX_PEERS,\n      channels: 3,\n      down: 0,\n      up: 0\n    }, err => {\n      if (err) {\n        console.error(err);\n        return;\n      }\n    });\n    this.peer = client.connect({\n      address: this.ipAddress,\n      port: this.port\n    }, 3, 1337, // Data to send, not sure what this is or what this represents\n    (err, newPeer) => {\n      if (err) {\n        console.error(err);\n        return;\n      }\n\n      newPeer.ping();\n      this.emit(exports.ConnectionEvent.CONNECT);\n\n      this._setStatus(exports.ConnectionStatus.CONNECTED);\n    });\n    this.peer.on(\"connect\", () => {\n      // Reset the game cursor to the beginning of the game. Do we need to do this or\n      // should it just continue from where it left off?\n      this.gameCursor = 0;\n      const request = {\n        type: \"connect_request\",\n        cursor: this.gameCursor\n      };\n      const packet = new enet.Packet(JSON.stringify(request), enet.PACKET_FLAG.RELIABLE);\n      this.peer.send(0, packet);\n    });\n    this.peer.on(\"message\", packet => {\n      const data = packet.data();\n\n      if (data.length === 0) {\n        return;\n      }\n\n      const dataString = data.toString(\"ascii\");\n      const message = JSON.parse(dataString);\n      const {\n        dolphin_closed\n      } = message;\n\n      if (dolphin_closed) {\n        // We got a disconnection request\n        this.disconnect();\n        return;\n      }\n\n      this.emit(exports.ConnectionEvent.MESSAGE, message);\n\n      switch (message.type) {\n        case exports.DolphinMessageType.CONNECT_REPLY:\n          this.connectionStatus = exports.ConnectionStatus.CONNECTED;\n          this.gameCursor = message.cursor;\n          this.nickname = message.nick;\n          this.version = message.version;\n          this.emit(exports.ConnectionEvent.HANDSHAKE, this.getDetails());\n          break;\n\n        case exports.DolphinMessageType.GAME_EVENT:\n          {\n            const {\n              payload\n            } = message; //TODO: remove after game start and end messages have been in stable Ishii for a bit\n\n            if (!payload) {\n              // We got a disconnection request\n              this.disconnect();\n              return;\n            }\n\n            this._updateCursor(message, dataString);\n\n            const gameData = Buffer.from(payload, \"base64\");\n\n            this._handleReplayData(gameData);\n\n            break;\n          }\n\n        case exports.DolphinMessageType.START_GAME:\n          {\n            this._updateCursor(message, dataString);\n\n            break;\n          }\n\n        case exports.DolphinMessageType.END_GAME:\n          {\n            this._updateCursor(message, dataString);\n\n            break;\n          }\n      }\n    });\n    this.peer.on(\"disconnect\", () => {\n      this.disconnect();\n    });\n\n    this._setStatus(exports.ConnectionStatus.CONNECTING);\n  }\n\n  disconnect() {\n    if (this.peer) {\n      this.peer.disconnect();\n      this.peer = null;\n    }\n\n    this._setStatus(exports.ConnectionStatus.DISCONNECTED);\n  }\n\n  _handleReplayData(data) {\n    this.emit(exports.ConnectionEvent.DATA, data);\n  }\n\n  _setStatus(status) {\n    // Don't fire the event if the status hasn't actually changed\n    if (this.connectionStatus !== status) {\n      this.connectionStatus = status;\n      this.emit(exports.ConnectionEvent.STATUS_CHANGE, this.connectionStatus);\n    }\n  }\n\n  _updateCursor(message, dataString) {\n    const {\n      cursor,\n      next_cursor\n    } = message;\n\n    if (this.gameCursor !== cursor) {\n      const err = new Error(`Unexpected game data cursor. Expected: ${this.gameCursor} but got: ${cursor}. Payload: ${dataString}`);\n      console.warn(err);\n      this.emit(exports.ConnectionEvent.ERROR, err);\n    }\n\n    this.gameCursor = next_cursor;\n  }\n\n}\n\nfunction toHalfwidth(str) {\n  // Converts a fullwidth character to halfwidth\n  const convertChar = charCode => {\n    /**\r\n     * Standard full width encodings\r\n     * https://en.wikipedia.org/wiki/Halfwidth_and_Fullwidth_Forms_(Unicode_block)\r\n     */\n    if (charCode > 0xff00 && charCode < 0xff5f) {\n      return 0x0020 + (charCode - 0xff00);\n    } // space:\n\n\n    if (charCode === 0x3000) {\n      return 0x0020;\n    }\n    /**\r\n     * Exceptions found in Melee/Japanese keyboards\r\n     */\n    // single quote: '\n\n\n    if (charCode === 0x2019) {\n      return 0x0027;\n    } // double quote: \"\n\n\n    if (charCode === 0x201d) {\n      return 0x0022;\n    }\n\n    return charCode;\n  };\n\n  const ret = lodash.map(str, char => convertChar(char.charCodeAt(0)));\n  return String.fromCharCode(...ret);\n}\n\nexports.SlpInputSource = void 0;\n\n(function (SlpInputSource) {\n  SlpInputSource[\"BUFFER\"] = \"buffer\";\n  SlpInputSource[\"FILE\"] = \"file\";\n})(exports.SlpInputSource || (exports.SlpInputSource = {}));\n\nfunction getRef(input) {\n  switch (input.source) {\n    case exports.SlpInputSource.FILE:\n      if (!input.filePath) {\n        throw new Error(\"File source requires a file path\");\n      }\n\n      const fd = fs__default[\"default\"].openSync(input.filePath, \"r\");\n      return {\n        source: input.source,\n        fileDescriptor: fd\n      };\n\n    case exports.SlpInputSource.BUFFER:\n      return {\n        source: input.source,\n        buffer: input.buffer\n      };\n\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n}\n\nfunction readRef(ref, buffer, offset, length, position) {\n  switch (ref.source) {\n    case exports.SlpInputSource.FILE:\n      return fs__default[\"default\"].readSync(ref.fileDescriptor, buffer, offset, length, position);\n\n    case exports.SlpInputSource.BUFFER:\n      return ref.buffer.copy(buffer, offset, position, position + length);\n\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n}\n\nfunction getLenRef(ref) {\n  switch (ref.source) {\n    case exports.SlpInputSource.FILE:\n      const fileStats = fs__default[\"default\"].fstatSync(ref.fileDescriptor);\n      return fileStats.size;\n\n    case exports.SlpInputSource.BUFFER:\n      return ref.buffer.length;\n\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n}\n/**\r\n * Opens a file at path\r\n */\n\n\nfunction openSlpFile(input) {\n  const ref = getRef(input);\n  const rawDataPosition = getRawDataPosition(ref);\n  const rawDataLength = getRawDataLength(ref, rawDataPosition);\n  const metadataPosition = rawDataPosition + rawDataLength + 10; // remove metadata string\n\n  const metadataLength = getMetadataLength(ref, metadataPosition);\n  const messageSizes = getMessageSizes(ref, rawDataPosition);\n  return {\n    ref,\n    rawDataPosition,\n    rawDataLength,\n    metadataPosition,\n    metadataLength,\n    messageSizes\n  };\n}\nfunction closeSlpFile(file) {\n  switch (file.ref.source) {\n    case exports.SlpInputSource.FILE:\n      fs__default[\"default\"].closeSync(file.ref.fileDescriptor);\n      break;\n  }\n} // This function gets the position where the raw data starts\n\nfunction getRawDataPosition(ref) {\n  const buffer = new Uint8Array(1);\n  readRef(ref, buffer, 0, buffer.length, 0);\n\n  if (buffer[0] === 0x36) {\n    return 0;\n  }\n\n  if (buffer[0] !== \"{\".charCodeAt(0)) {\n    return 0; // return error?\n  }\n\n  return 15;\n}\n\nfunction getRawDataLength(ref, position) {\n  const fileSize = getLenRef(ref);\n\n  if (position === 0) {\n    return fileSize;\n  }\n\n  const buffer = new Uint8Array(4);\n  readRef(ref, buffer, 0, buffer.length, position - 4);\n  const rawDataLen = buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];\n\n  if (rawDataLen > 0) {\n    // If this method manages to read a number, it's probably trustworthy\n    return rawDataLen;\n  } // If the above does not return a valid data length,\n  // return a file size based on file length. This enables\n  // some support for severed files\n\n\n  return fileSize - position;\n}\n\nfunction getMetadataLength(ref, position) {\n  const len = getLenRef(ref);\n  return len - position - 1;\n}\n\nfunction getMessageSizes(ref, position) {\n  const messageSizes = {}; // Support old file format\n\n  if (position === 0) {\n    messageSizes[0x36] = 0x140;\n    messageSizes[0x37] = 0x6;\n    messageSizes[0x38] = 0x46;\n    messageSizes[0x39] = 0x1;\n    return messageSizes;\n  }\n\n  const buffer = new Uint8Array(2);\n  readRef(ref, buffer, 0, buffer.length, position);\n\n  if (buffer[0] !== exports.Command.MESSAGE_SIZES) {\n    return {};\n  }\n\n  const payloadLength = buffer[1];\n  messageSizes[0x35] = payloadLength;\n  const messageSizesBuffer = new Uint8Array(payloadLength - 1);\n  readRef(ref, messageSizesBuffer, 0, messageSizesBuffer.length, position + 2);\n\n  for (let i = 0; i < payloadLength - 1; i += 3) {\n    const command = messageSizesBuffer[i]; // Get size of command\n\n    messageSizes[command] = messageSizesBuffer[i + 1] << 8 | messageSizesBuffer[i + 2];\n  }\n\n  return messageSizes;\n}\n\nfunction getEnabledItems(view) {\n  const offsets = [0x1, 0x100, 0x10000, 0x1000000, 0x100000000];\n  const enabledItems = offsets.reduce((acc, byteOffset, index) => {\n    const byte = readUint8(view, 0x28 + index);\n    return acc + byte * byteOffset;\n  }, 0);\n  return enabledItems;\n}\n\nfunction getGameInfoBlock(view) {\n  const offset = 0x5;\n  return {\n    gameBitfield1: readUint8(view, 0x0 + offset),\n    gameBitfield2: readUint8(view, 0x1 + offset),\n    gameBitfield3: readUint8(view, 0x2 + offset),\n    gameBitfield4: readUint8(view, 0x3 + offset),\n    bombRainEnabled: (readUint8(view, 0x6 + offset) & 0xff) > 0 ? true : false,\n    itemSpawnBehavior: readInt8(view, 0xb + offset),\n    selfDestructScoreValue: readInt8(view, 0xc + offset),\n    //stageId: readUint16(view, 0xe + offset),\n    //gameTimer: readUint32(view, 0x10 + offset),\n    itemSpawnBitfield1: readUint8(view, 0x23 + offset),\n    itemSpawnBitfield2: readUint8(view, 0x24 + offset),\n    itemSpawnBitfield3: readUint8(view, 0x25 + offset),\n    itemSpawnBitfield4: readUint8(view, 0x26 + offset),\n    itemSpawnBitfield5: readUint8(view, 0x27 + offset),\n    damageRatio: readFloat(view, 0x30 + offset)\n  };\n}\n/**\r\n * Iterates through slp events and parses payloads\r\n */\n\n\nfunction iterateEvents(slpFile, callback, startPos = null) {\n  const ref = slpFile.ref;\n  let readPosition = startPos !== null && startPos > 0 ? startPos : slpFile.rawDataPosition;\n  const stopReadingAt = slpFile.rawDataPosition + slpFile.rawDataLength; // Generate read buffers for each\n\n  const commandPayloadBuffers = lodash.mapValues(slpFile.messageSizes, size => new Uint8Array(size + 1));\n  let splitMessageBuffer = new Uint8Array(0);\n  const commandByteBuffer = new Uint8Array(1);\n\n  while (readPosition < stopReadingAt) {\n    var _commandByteBuffer$;\n\n    readRef(ref, commandByteBuffer, 0, 1, readPosition);\n    let commandByte = (_commandByteBuffer$ = commandByteBuffer[0]) != null ? _commandByteBuffer$ : 0;\n    let buffer = commandPayloadBuffers[commandByte];\n\n    if (buffer === undefined) {\n      // If we don't have an entry for this command, return false to indicate failed read\n      return readPosition;\n    }\n\n    if (buffer.length > stopReadingAt - readPosition) {\n      return readPosition;\n    }\n\n    const advanceAmount = buffer.length;\n    readRef(ref, buffer, 0, buffer.length, readPosition);\n\n    if (commandByte === exports.Command.SPLIT_MESSAGE) {\n      var _readUint, _readUint2;\n\n      // Here we have a split message, we will collect data from them until the last\n      // message of the list is received\n      const view = new DataView(buffer.buffer);\n      const size = (_readUint = readUint16(view, 0x201)) != null ? _readUint : 512;\n      const isLastMessage = readBool(view, 0x204);\n      const internalCommand = (_readUint2 = readUint8(view, 0x203)) != null ? _readUint2 : 0; // If this is the first message, initialize the splitMessageBuffer\n      // with the internal command byte because our parseMessage function\n      // seems to expect a command byte at the start\n\n      if (splitMessageBuffer.length === 0) {\n        splitMessageBuffer = new Uint8Array(1);\n        splitMessageBuffer[0] = internalCommand;\n      } // Collect new data into splitMessageBuffer\n\n\n      const appendBuf = buffer.slice(0x1, 0x1 + size);\n      const mergedBuf = new Uint8Array(splitMessageBuffer.length + appendBuf.length);\n      mergedBuf.set(splitMessageBuffer);\n      mergedBuf.set(appendBuf, splitMessageBuffer.length);\n      splitMessageBuffer = mergedBuf;\n\n      if (isLastMessage) {\n        var _splitMessageBuffer$;\n\n        commandByte = (_splitMessageBuffer$ = splitMessageBuffer[0]) != null ? _splitMessageBuffer$ : 0;\n        buffer = splitMessageBuffer;\n        splitMessageBuffer = new Uint8Array(0);\n      }\n    }\n\n    const parsedPayload = parseMessage(commandByte, buffer);\n    const shouldStop = callback(commandByte, parsedPayload, buffer);\n\n    if (shouldStop) {\n      break;\n    }\n\n    readPosition += advanceAmount;\n  }\n\n  return readPosition;\n}\nfunction parseMessage(command, payload) {\n  const view = new DataView(payload.buffer);\n\n  switch (command) {\n    case exports.Command.GAME_START:\n      const getPlayerObject = playerIndex => {\n        // Controller Fix stuff\n        const cfOffset = playerIndex * 0x8;\n        const dashback = readUint32(view, 0x141 + cfOffset);\n        const shieldDrop = readUint32(view, 0x145 + cfOffset);\n        let controllerFix = \"None\";\n\n        if (dashback !== shieldDrop) {\n          controllerFix = \"Mixed\";\n        } else if (dashback === 1) {\n          controllerFix = \"UCF\";\n        } else if (dashback === 2) {\n          controllerFix = \"Dween\";\n        } // Nametag stuff\n\n\n        const nametagLength = 0x10;\n        const nametagOffset = playerIndex * nametagLength;\n        const nametagStart = 0x161 + nametagOffset;\n        const nametagBuf = payload.slice(nametagStart, nametagStart + nametagLength);\n        const nameTagString = iconv__default[\"default\"].decode(nametagBuf, \"Shift_JIS\").split(\"\\0\").shift();\n        const nametag = nameTagString ? toHalfwidth(nameTagString) : \"\"; // Display name\n\n        const displayNameLength = 0x1f;\n        const displayNameOffset = playerIndex * displayNameLength;\n        const displayNameStart = 0x1a5 + displayNameOffset;\n        const displayNameBuf = payload.slice(displayNameStart, displayNameStart + displayNameLength);\n        const displayNameString = iconv__default[\"default\"].decode(displayNameBuf, \"Shift_JIS\").split(\"\\0\").shift();\n        const displayName = displayNameString ? toHalfwidth(displayNameString) : \"\"; // Connect code\n\n        const connectCodeLength = 0xa;\n        const connectCodeOffset = playerIndex * connectCodeLength;\n        const connectCodeStart = 0x221 + connectCodeOffset;\n        const connectCodeBuf = payload.slice(connectCodeStart, connectCodeStart + connectCodeLength);\n        const connectCodeString = iconv__default[\"default\"].decode(connectCodeBuf, \"Shift_JIS\").split(\"\\0\").shift();\n        const connectCode = connectCodeString ? toHalfwidth(connectCodeString) : \"\";\n        const userIdLength = 0x1d;\n        const userIdOffset = playerIndex * userIdLength;\n        const userIdStart = 0x249 + userIdOffset;\n        const userIdBuf = payload.slice(userIdStart, userIdStart + userIdLength);\n        const userIdString = iconv__default[\"default\"].decode(userIdBuf, \"utf8\").split(\"\\0\").shift();\n        const userId = userIdString != null ? userIdString : \"\";\n        const offset = playerIndex * 0x24;\n        return {\n          playerIndex,\n          port: playerIndex + 1,\n          characterId: readUint8(view, 0x65 + offset),\n          type: readUint8(view, 0x66 + offset),\n          startStocks: readUint8(view, 0x67 + offset),\n          characterColor: readUint8(view, 0x68 + offset),\n          teamShade: readUint8(view, 0x6c + offset),\n          handicap: readUint8(view, 0x6d + offset),\n          teamId: readUint8(view, 0x6e + offset),\n          staminaMode: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x01)),\n          silentCharacter: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x02)),\n          lowGravity: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x04)),\n          invisible: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x08)),\n          blackStockIcon: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x10)),\n          metal: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x20)),\n          startOnAngelPlatform: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x40)),\n          rumbleEnabled: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x80)),\n          cpuLevel: readUint8(view, 0x74 + offset),\n          offenseRatio: readFloat(view, 0x7d + offset),\n          defenseRatio: readFloat(view, 0x81 + offset),\n          modelScale: readFloat(view, 0x85 + offset),\n          controllerFix,\n          nametag,\n          displayName,\n          connectCode,\n          userId\n        };\n      };\n\n      const matchIdLength = 51;\n      const matchIdStart = 0x2be;\n      const matchIdBuf = payload.slice(matchIdStart, matchIdStart + matchIdLength);\n      const matchIdString = iconv__default[\"default\"].decode(matchIdBuf, \"utf8\").split(\"\\0\").shift();\n      const matchId = matchIdString != null ? matchIdString : \"\";\n      return {\n        slpVersion: `${readUint8(view, 0x1)}.${readUint8(view, 0x2)}.${readUint8(view, 0x3)}`,\n        timerType: readUint8(view, 0x5, 0x03),\n        inGameMode: readUint8(view, 0x5, 0xe0),\n        friendlyFireEnabled: !!readUint8(view, 0x6, 0x01),\n        isTeams: readBool(view, 0xd),\n        itemSpawnBehavior: readUint8(view, 0x10),\n        stageId: readUint16(view, 0x13),\n        startingTimerSeconds: readUint32(view, 0x15),\n        enabledItems: getEnabledItems(view),\n        players: [0, 1, 2, 3].map(getPlayerObject),\n        scene: readUint8(view, 0x1a3),\n        gameMode: readUint8(view, 0x1a4),\n        language: readUint8(view, 0x2bd),\n        gameInfoBlock: getGameInfoBlock(view),\n        randomSeed: readUint32(view, 0x13d),\n        isPAL: readBool(view, 0x1a1),\n        isFrozenPS: readBool(view, 0x1a2),\n        matchInfo: {\n          matchId,\n          gameNumber: readUint32(view, 0x2f1),\n          tiebreakerNumber: readUint32(view, 0x2f5)\n        }\n      };\n\n    case exports.Command.FRAME_START:\n      return {\n        frame: readInt32(view, 0x1),\n        seed: readUint32(view, 0x5),\n        sceneFrameCounter: readUint32(view, 0x9)\n      };\n\n    case exports.Command.PRE_FRAME_UPDATE:\n      return {\n        frame: readInt32(view, 0x1),\n        playerIndex: readUint8(view, 0x5),\n        isFollower: readBool(view, 0x6),\n        seed: readUint32(view, 0x7),\n        actionStateId: readUint16(view, 0xb),\n        positionX: readFloat(view, 0xd),\n        positionY: readFloat(view, 0x11),\n        facingDirection: readFloat(view, 0x15),\n        joystickX: readFloat(view, 0x19),\n        joystickY: readFloat(view, 0x1d),\n        cStickX: readFloat(view, 0x21),\n        cStickY: readFloat(view, 0x25),\n        trigger: readFloat(view, 0x29),\n        buttons: readUint32(view, 0x2d),\n        physicalButtons: readUint16(view, 0x31),\n        physicalLTrigger: readFloat(view, 0x33),\n        physicalRTrigger: readFloat(view, 0x37),\n        rawJoystickX: readInt8(view, 0x3b),\n        percent: readFloat(view, 0x3c)\n      };\n\n    case exports.Command.POST_FRAME_UPDATE:\n      const selfInducedSpeeds = {\n        airX: readFloat(view, 0x35),\n        y: readFloat(view, 0x39),\n        attackX: readFloat(view, 0x3d),\n        attackY: readFloat(view, 0x41),\n        groundX: readFloat(view, 0x45)\n      };\n      return {\n        frame: readInt32(view, 0x1),\n        playerIndex: readUint8(view, 0x5),\n        isFollower: readBool(view, 0x6),\n        internalCharacterId: readUint8(view, 0x7),\n        actionStateId: readUint16(view, 0x8),\n        positionX: readFloat(view, 0xa),\n        positionY: readFloat(view, 0xe),\n        facingDirection: readFloat(view, 0x12),\n        percent: readFloat(view, 0x16),\n        shieldSize: readFloat(view, 0x1a),\n        lastAttackLanded: readUint8(view, 0x1e),\n        currentComboCount: readUint8(view, 0x1f),\n        lastHitBy: readUint8(view, 0x20),\n        stocksRemaining: readUint8(view, 0x21),\n        actionStateCounter: readFloat(view, 0x22),\n        miscActionState: readFloat(view, 0x2b),\n        isAirborne: readBool(view, 0x2f),\n        lastGroundId: readUint16(view, 0x30),\n        jumpsRemaining: readUint8(view, 0x32),\n        lCancelStatus: readUint8(view, 0x33),\n        hurtboxCollisionState: readUint8(view, 0x34),\n        selfInducedSpeeds: selfInducedSpeeds,\n        hitlagRemaining: readFloat(view, 0x49),\n        animationIndex: readUint32(view, 0x4d)\n      };\n\n    case exports.Command.ITEM_UPDATE:\n      return {\n        frame: readInt32(view, 0x1),\n        typeId: readUint16(view, 0x5),\n        state: readUint8(view, 0x7),\n        facingDirection: readFloat(view, 0x8),\n        velocityX: readFloat(view, 0xc),\n        velocityY: readFloat(view, 0x10),\n        positionX: readFloat(view, 0x14),\n        positionY: readFloat(view, 0x18),\n        damageTaken: readUint16(view, 0x1c),\n        expirationTimer: readFloat(view, 0x1e),\n        spawnId: readUint32(view, 0x22),\n        missileType: readUint8(view, 0x26),\n        turnipFace: readUint8(view, 0x27),\n        chargeShotLaunched: readUint8(view, 0x28),\n        chargePower: readUint8(view, 0x29),\n        owner: readInt8(view, 0x2a)\n      };\n\n    case exports.Command.FRAME_BOOKEND:\n      return {\n        frame: readInt32(view, 0x1),\n        latestFinalizedFrame: readInt32(view, 0x5)\n      };\n\n    case exports.Command.GAME_END:\n      const placements = [0, 1, 2, 3].map(playerIndex => {\n        const position = readInt8(view, 0x3 + playerIndex);\n        return {\n          playerIndex,\n          position\n        };\n      });\n      return {\n        gameEndMethod: readUint8(view, 0x1),\n        lrasInitiatorIndex: readInt8(view, 0x2),\n        placements\n      };\n\n    case exports.Command.GECKO_LIST:\n      const codes = [];\n      let pos = 1;\n\n      while (pos < payload.length) {\n        var _readUint3;\n\n        const word1 = (_readUint3 = readUint32(view, pos)) != null ? _readUint3 : 0;\n        const codetype = word1 >> 24 & 0xfe;\n        const address = (word1 & 0x01ffffff) + 0x80000000;\n        let offset = 8; // Default code length, most codes are this length\n\n        if (codetype === 0xc0 || codetype === 0xc2) {\n          var _readUint4;\n\n          const lineCount = (_readUint4 = readUint32(view, pos + 4)) != null ? _readUint4 : 0;\n          offset = 8 + lineCount * 8;\n        } else if (codetype === 0x06) {\n          var _readUint5;\n\n          const byteLen = (_readUint5 = readUint32(view, pos + 4)) != null ? _readUint5 : 0;\n          offset = 8 + (byteLen + 7 & 0xfffffff8);\n        } else if (codetype === 0x08) {\n          offset = 16;\n        }\n\n        codes.push({\n          type: codetype,\n          address: address,\n          contents: payload.slice(pos, pos + offset)\n        });\n        pos += offset;\n      }\n\n      return {\n        contents: payload.slice(1),\n        codes: codes\n      };\n\n    default:\n      return null;\n  }\n}\n\nfunction canReadFromView(view, offset, length) {\n  const viewLength = view.byteLength;\n  return offset + length <= viewLength;\n}\n\nfunction readFloat(view, offset) {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getFloat32(offset);\n}\n\nfunction readInt32(view, offset) {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getInt32(offset);\n}\n\nfunction readInt8(view, offset) {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return view.getInt8(offset);\n}\n\nfunction readUint32(view, offset) {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getUint32(offset);\n}\n\nfunction readUint16(view, offset) {\n  if (!canReadFromView(view, offset, 2)) {\n    return null;\n  }\n\n  return view.getUint16(offset);\n}\n\nfunction readUint8(view, offset, bitmask = 0xff) {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return view.getUint8(offset) & bitmask;\n}\n\nfunction readBool(view, offset) {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return !!view.getUint8(offset);\n}\n\nfunction getMetadata(slpFile) {\n  if (slpFile.metadataLength <= 0) {\n    // This will happen on a severed incomplete file\n    // $FlowFixMe\n    return null;\n  }\n\n  const buffer = new Uint8Array(slpFile.metadataLength);\n  readRef(slpFile.ref, buffer, 0, buffer.length, slpFile.metadataPosition);\n  let metadata = null;\n\n  try {\n    metadata = ubjson.decode(buffer);\n  } catch (ex) {// Do nothing\n    // console.log(ex);\n  } // $FlowFixMe\n\n\n  return metadata;\n}\nfunction getGameEnd(slpFile) {\n  const {\n    ref,\n    rawDataPosition,\n    rawDataLength,\n    messageSizes\n  } = slpFile;\n  const gameEndPayloadSize = messageSizes[exports.Command.GAME_END];\n\n  if (!exists(gameEndPayloadSize) || gameEndPayloadSize <= 0) {\n    return null;\n  } // Add one to account for command byte\n\n\n  const gameEndSize = gameEndPayloadSize + 1;\n  const gameEndPosition = rawDataPosition + rawDataLength - gameEndSize;\n  const buffer = new Uint8Array(gameEndSize);\n  readRef(ref, buffer, 0, buffer.length, gameEndPosition);\n\n  if (buffer[0] !== exports.Command.GAME_END) {\n    // This isn't even a game end payload\n    return null;\n  }\n\n  const gameEndMessage = parseMessage(exports.Command.GAME_END, buffer);\n\n  if (!gameEndMessage) {\n    return null;\n  }\n\n  return gameEndMessage;\n}\nfunction extractFinalPostFrameUpdates(slpFile) {\n  const {\n    ref,\n    rawDataPosition,\n    rawDataLength,\n    messageSizes\n  } = slpFile; // The following should exist on all replay versions\n\n  const postFramePayloadSize = messageSizes[exports.Command.POST_FRAME_UPDATE];\n  const gameEndPayloadSize = messageSizes[exports.Command.GAME_END];\n  const frameBookendPayloadSize = messageSizes[exports.Command.FRAME_BOOKEND]; // Technically this should not be possible\n\n  if (!exists(postFramePayloadSize)) {\n    return [];\n  }\n\n  const gameEndSize = gameEndPayloadSize ? gameEndPayloadSize + 1 : 0;\n  const postFrameSize = postFramePayloadSize + 1;\n  const frameBookendSize = frameBookendPayloadSize ? frameBookendPayloadSize + 1 : 0;\n  let frameNum = null;\n  let postFramePosition = rawDataPosition + rawDataLength - gameEndSize - frameBookendSize - postFrameSize;\n  const postFrameUpdates = [];\n\n  do {\n    const buffer = new Uint8Array(postFrameSize);\n    readRef(ref, buffer, 0, buffer.length, postFramePosition);\n\n    if (buffer[0] !== exports.Command.POST_FRAME_UPDATE) {\n      break;\n    }\n\n    const postFrameMessage = parseMessage(exports.Command.POST_FRAME_UPDATE, buffer);\n\n    if (!postFrameMessage) {\n      break;\n    }\n\n    if (frameNum === null) {\n      frameNum = postFrameMessage.frame;\n    } else if (frameNum !== postFrameMessage.frame) {\n      // If post frame message is found but the frame doesn't match, it's not part of the final frame\n      break;\n    }\n\n    postFrameUpdates.unshift(postFrameMessage);\n    postFramePosition -= postFrameSize;\n  } while (postFramePosition >= rawDataPosition);\n\n  return postFrameUpdates;\n}\n\nexports.SlpStreamMode = void 0;\n\n(function (SlpStreamMode) {\n  SlpStreamMode[\"AUTO\"] = \"AUTO\";\n  SlpStreamMode[\"MANUAL\"] = \"MANUAL\";\n})(exports.SlpStreamMode || (exports.SlpStreamMode = {}));\n\nconst defaultSettings$1 = {\n  suppressErrors: false,\n  mode: exports.SlpStreamMode.AUTO\n};\nexports.SlpStreamEvent = void 0;\n\n(function (SlpStreamEvent) {\n  SlpStreamEvent[\"RAW\"] = \"slp-raw\";\n  SlpStreamEvent[\"COMMAND\"] = \"slp-command\";\n})(exports.SlpStreamEvent || (exports.SlpStreamEvent = {}));\n/**\r\n * SlpStream is a writable stream of Slippi data. It passes the data being written in\r\n * and emits an event based on what kind of Slippi messages were processed.\r\n *\r\n * SlpStream emits two events: \"slp-raw\" and \"slp-command\". The \"slp-raw\" event emits the raw buffer\r\n * bytes whenever it processes each command. You can manually parse this or write it to a\r\n * file. The \"slp-command\" event returns the parsed payload which you can access the attributes.\r\n *\r\n * @class SlpStream\r\n * @extends {Writable}\r\n */\n\n\nclass SlpStream extends stream.Writable {\n  // True only if in manual mode and the game has completed\n\n  /**\r\n   *Creates an instance of SlpStream.\r\n   * @param {Partial<SlpStreamSettings>} [slpOptions]\r\n   * @param {WritableOptions} [opts]\r\n   * @memberof SlpStream\r\n   */\n  constructor(slpOptions, opts) {\n    super(opts);\n    this.gameEnded = false;\n    this.settings = void 0;\n    this.payloadSizes = null;\n    this.previousBuffer = Buffer.from([]);\n    this.settings = Object.assign({}, defaultSettings$1, slpOptions);\n  }\n\n  restart() {\n    this.gameEnded = false;\n    this.payloadSizes = null;\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  _write(newData, encoding, callback) {\n    if (encoding !== \"buffer\") {\n      throw new Error(`Unsupported stream encoding. Expected 'buffer' got '${encoding}'.`);\n    } // Join the current data with the old data\n\n\n    const data = Uint8Array.from(Buffer.concat([this.previousBuffer, newData])); // Clear previous data\n\n    this.previousBuffer = Buffer.from([]);\n    const dataView = new DataView(data.buffer); // Iterate through the data\n\n    let index = 0;\n\n    while (index < data.length) {\n      // We want to filter out the network messages\n      if (Buffer.from(data.slice(index, index + 5)).toString() === NETWORK_MESSAGE) {\n        index += 5;\n        continue;\n      } // Make sure we have enough data to read a full payload\n\n\n      const command = dataView.getUint8(index);\n      let payloadSize = 0;\n\n      if (this.payloadSizes) {\n        var _this$payloadSizes$ge;\n\n        payloadSize = (_this$payloadSizes$ge = this.payloadSizes.get(command)) != null ? _this$payloadSizes$ge : 0;\n      }\n\n      const remainingLen = data.length - index;\n\n      if (remainingLen < payloadSize + 1) {\n        // If remaining length is not long enough for full payload, save the remaining\n        // data until we receive more data. The data has been split up.\n        this.previousBuffer = data.slice(index);\n        break;\n      } // Only process if the game is still going\n\n\n      if (this.settings.mode === exports.SlpStreamMode.MANUAL && this.gameEnded) {\n        break;\n      } // Increment by one for the command byte\n\n\n      index += 1;\n      const payloadPtr = data.slice(index);\n      const payloadDataView = new DataView(data.buffer, index);\n      let payloadLen = 0;\n\n      try {\n        payloadLen = this._processCommand(command, payloadPtr, payloadDataView);\n      } catch (err) {\n        // Only throw the error if we're not suppressing the errors\n        if (!this.settings.suppressErrors) {\n          throw err;\n        }\n\n        payloadLen = 0;\n      }\n\n      index += payloadLen;\n    }\n\n    callback();\n  }\n\n  _writeCommand(command, entirePayload, payloadSize) {\n    const payloadBuf = entirePayload.slice(0, payloadSize);\n    const bufToWrite = Buffer.concat([Buffer.from([command]), payloadBuf]); // Forward the raw buffer onwards\n\n    this.emit(exports.SlpStreamEvent.RAW, {\n      command: command,\n      payload: bufToWrite\n    });\n    return new Uint8Array(bufToWrite);\n  }\n\n  _processCommand(command, entirePayload, dataView) {\n    // Handle the message size command\n    if (command === exports.Command.MESSAGE_SIZES) {\n      const payloadSize = dataView.getUint8(0); // Set the payload sizes\n\n      this.payloadSizes = processReceiveCommands(dataView); // Emit the raw command event\n\n      this._writeCommand(command, entirePayload, payloadSize);\n\n      this.emit(exports.SlpStreamEvent.COMMAND, {\n        command: command,\n        payload: this.payloadSizes\n      });\n      return payloadSize;\n    }\n\n    let payloadSize = 0;\n\n    if (this.payloadSizes) {\n      var _this$payloadSizes$ge2;\n\n      payloadSize = (_this$payloadSizes$ge2 = this.payloadSizes.get(command)) != null ? _this$payloadSizes$ge2 : 0;\n    } // Fetch the payload and parse it\n\n\n    let payload;\n    let parsedPayload = null;\n\n    if (payloadSize > 0) {\n      payload = this._writeCommand(command, entirePayload, payloadSize);\n      parsedPayload = parseMessage(command, payload);\n    }\n\n    if (!parsedPayload) {\n      return payloadSize;\n    }\n\n    switch (command) {\n      case exports.Command.GAME_END:\n        // Stop parsing data until we manually restart the stream\n        if (this.settings.mode === exports.SlpStreamMode.MANUAL) {\n          this.gameEnded = true;\n        }\n\n        break;\n    }\n\n    this.emit(exports.SlpStreamEvent.COMMAND, {\n      command: command,\n      payload: parsedPayload\n    });\n    return payloadSize;\n  }\n\n}\n\nconst processReceiveCommands = dataView => {\n  const payloadSizes = new Map();\n  const payloadLen = dataView.getUint8(0);\n\n  for (let i = 1; i < payloadLen; i += 3) {\n    const commandByte = dataView.getUint8(i);\n    const payloadSize = dataView.getUint16(i + 1);\n    payloadSizes.set(commandByte, payloadSize);\n  }\n\n  return payloadSizes;\n};\n\nconst DEFAULT_NICKNAME = \"unknown\";\n/**\r\n * SlpFile is a class that wraps a Writable stream. It handles the writing of the binary\r\n * header and footer, and also handles the overwriting of the raw data length.\r\n *\r\n * @class SlpFile\r\n * @extends {Writable}\r\n */\n\nclass SlpFile extends stream.Writable {\n  /**\r\n   * Creates an instance of SlpFile.\r\n   * @param {string} filePath The file location to write to.\r\n   * @param {WritableOptions} [opts] Options for writing.\r\n   * @memberof SlpFile\r\n   */\n  constructor(filePath, slpStream, opts) {\n    super(opts);\n    this.filePath = void 0;\n    this.metadata = void 0;\n    this.fileStream = null;\n    this.rawDataLength = 0;\n    this.slpStream = void 0;\n    this.usesExternalStream = false;\n    this.filePath = filePath;\n    this.metadata = {\n      consoleNickname: DEFAULT_NICKNAME,\n      startTime: new Date(),\n      lastFrame: -124,\n      players: {}\n    };\n    this.usesExternalStream = Boolean(slpStream); // Create a new SlpStream if one wasn't already provided\n    // This SLP stream represents a single game not multiple, so use manual mode\n\n    this.slpStream = slpStream ? slpStream : new SlpStream({\n      mode: exports.SlpStreamMode.MANUAL\n    });\n\n    this._setupListeners();\n\n    this._initializeNewGame(this.filePath);\n  }\n  /**\r\n   * Get the current file path being written to.\r\n   *\r\n   * @returns {string} The location of the current file path\r\n   * @memberof SlpFile\r\n   */\n\n\n  path() {\n    return this.filePath;\n  }\n  /**\r\n   * Sets the metadata of the Slippi file, such as consoleNickname, lastFrame, and players.\r\n   * @param metadata The metadata to be written\r\n   */\n\n\n  setMetadata(metadata) {\n    this.metadata = Object.assign({}, this.metadata, metadata);\n  }\n\n  _write(chunk, encoding, callback) {\n    if (encoding !== \"buffer\") {\n      throw new Error(`Unsupported stream encoding. Expected 'buffer' got '${encoding}'.`);\n    } // Write it to the file\n\n\n    if (this.fileStream) {\n      this.fileStream.write(chunk);\n    } // Parse the data manually if it's an internal stream\n\n\n    if (!this.usesExternalStream) {\n      this.slpStream.write(chunk);\n    } // Keep track of the bytes we've written\n\n\n    this.rawDataLength += chunk.length;\n    callback();\n  }\n  /**\r\n   * Here we define what to do on each command. We need to populate the metadata field\r\n   * so we keep track of the latest frame, as well as the number of frames each character has\r\n   * been used.\r\n   *\r\n   * @param data The parsed data from a SlpStream\r\n   */\n\n\n  _onCommand(data) {\n    const {\n      command,\n      payload\n    } = data;\n\n    switch (command) {\n      case exports.Command.GAME_START:\n        const {\n          players\n        } = payload;\n        lodash.forEach(players, player => {\n          if (player.type === 3) {\n            return;\n          }\n\n          this.metadata.players[player.playerIndex] = {\n            characterUsage: {},\n            names: {\n              netplay: player.displayName,\n              code: player.connectCode\n            }\n          };\n        });\n        break;\n\n      case exports.Command.POST_FRAME_UPDATE:\n        // Here we need to update some metadata fields\n        const {\n          frame,\n          playerIndex,\n          isFollower,\n          internalCharacterId\n        } = payload;\n\n        if (isFollower) {\n          // No need to do this for follower\n          break;\n        } // Update frame index\n\n\n        this.metadata.lastFrame = frame; // Update character usage\n\n        const prevPlayer = this.metadata.players[playerIndex];\n        const characterUsage = prevPlayer.characterUsage;\n        const curCharFrames = characterUsage[internalCharacterId] || 0;\n        const player = { ...prevPlayer,\n          characterUsage: { ...characterUsage,\n            [internalCharacterId]: curCharFrames + 1\n          }\n        };\n        this.metadata.players[playerIndex] = player;\n        break;\n    }\n  }\n\n  _setupListeners() {\n    const streamListener = data => {\n      this._onCommand(data);\n    };\n\n    this.slpStream.on(exports.SlpStreamEvent.COMMAND, streamListener);\n    this.on(\"finish\", () => {\n      // Update file with bytes written\n      const fd = fs__default[\"default\"].openSync(this.filePath, \"r+\");\n      fs__default[\"default\"].writeSync(fd, createUInt32Buffer(this.rawDataLength), 0, 4, 11);\n      fs__default[\"default\"].closeSync(fd); // Unsubscribe from the stream\n\n      this.slpStream.removeListener(exports.SlpStreamEvent.COMMAND, streamListener); // Terminate the internal stream\n\n      if (!this.usesExternalStream) {\n        this.slpStream.end();\n      }\n    });\n  }\n\n  _initializeNewGame(filePath) {\n    this.fileStream = fs__default[\"default\"].createWriteStream(filePath, {\n      encoding: \"binary\"\n    });\n    const header = Buffer.concat([Buffer.from(\"{U\"), Buffer.from([3]), Buffer.from(\"raw[$U#l\"), Buffer.from([0, 0, 0, 0])]);\n    this.fileStream.write(header);\n  }\n\n  _final(callback) {\n    let footer = Buffer.concat([Buffer.from(\"U\"), Buffer.from([8]), Buffer.from(\"metadata{\")]); // Write game start time\n\n    const startTimeStr = this.metadata.startTime.toISOString();\n    footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([7]), Buffer.from(\"startAtSU\"), Buffer.from([startTimeStr.length]), Buffer.from(startTimeStr)]); // Write last frame index\n    // TODO: Get last frame\n\n    const lastFrame = this.metadata.lastFrame;\n    footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([9]), Buffer.from(\"lastFramel\"), createInt32Buffer(lastFrame)]); // write the Console Nickname\n\n    const consoleNick = this.metadata.consoleNickname || DEFAULT_NICKNAME;\n    footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([11]), Buffer.from(\"consoleNickSU\"), Buffer.from([consoleNick.length]), Buffer.from(consoleNick)]); // Start writting player specific data\n\n    footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([7]), Buffer.from(\"players{\")]);\n    const players = this.metadata.players;\n    lodash.forEach(players, (player, index) => {\n      // Start player obj with index being the player index\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([index.length]), Buffer.from(`${index}{`)]); // Start characters key for this player\n\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([10]), Buffer.from(\"characters{\")]); // Write character usage\n\n      lodash.forEach(player.characterUsage, (usage, internalId) => {\n        // Write this character\n        footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([internalId.length]), Buffer.from(`${internalId}l`), createUInt32Buffer(usage)]);\n      }); // Close characters\n\n      footer = Buffer.concat([footer, Buffer.from(\"}\")]); // Start names key for this player\n\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([5]), Buffer.from(\"names{\")]); // Write display name\n\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([7]), Buffer.from(\"netplaySU\"), Buffer.from([player.names.netplay.length]), Buffer.from(`${player.names.netplay}`)]); // Write connect code\n\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([4]), Buffer.from(\"codeSU\"), Buffer.from([player.names.code.length]), Buffer.from(`${player.names.code}`)]); // Close names and player\n\n      footer = Buffer.concat([footer, Buffer.from(\"}}\")]);\n    }); // Close players\n\n    footer = Buffer.concat([footer, Buffer.from(\"}\")]); // Write played on\n\n    footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([8]), Buffer.from(\"playedOnSU\"), Buffer.from([7]), Buffer.from(\"network\")]); // Close metadata and file\n\n    footer = Buffer.concat([footer, Buffer.from(\"}}\")]); // End the stream\n\n    if (this.fileStream) {\n      this.fileStream.write(footer, callback);\n    }\n  }\n\n}\n\nconst createInt32Buffer = number => {\n  const buf = Buffer.alloc(4);\n  buf.writeInt32BE(number, 0);\n  return buf;\n};\n\nconst createUInt32Buffer = number => {\n  const buf = Buffer.alloc(4);\n  buf.writeUInt32BE(number, 0);\n  return buf;\n};\n\n/**\r\n * The default function to use for generating new SLP files.\r\n */\n\nfunction getNewFilePath(folder, date) {\n  return path__default[\"default\"].join(folder, `Game_${dateFns.format(date, \"yyyyMMdd\")}T${dateFns.format(date, \"HHmmss\")}.slp`);\n}\n\nconst defaultSettings = {\n  outputFiles: true,\n  folderPath: \".\",\n  consoleNickname: \"unknown\",\n  newFilename: getNewFilePath\n};\nexports.SlpFileWriterEvent = void 0;\n\n(function (SlpFileWriterEvent) {\n  SlpFileWriterEvent[\"NEW_FILE\"] = \"new-file\";\n  SlpFileWriterEvent[\"FILE_COMPLETE\"] = \"file-complete\";\n})(exports.SlpFileWriterEvent || (exports.SlpFileWriterEvent = {}));\n/**\r\n * SlpFileWriter lets us not only emit events as an SlpStream but also\r\n * writes the data that is being passed in to an SLP file. Use this if\r\n * you want to process Slippi data in real time but also want to be able\r\n * to write out the data to an SLP file.\r\n *\r\n * @export\r\n * @class SlpFileWriter\r\n * @extends {SlpStream}\r\n */\n\n\nclass SlpFileWriter extends SlpStream {\n  /**\r\n   * Creates an instance of SlpFileWriter.\r\n   */\n  constructor(options, opts) {\n    super(options, opts);\n    this.currentFile = null;\n    this.options = void 0;\n    this.options = Object.assign({}, defaultSettings, options);\n\n    this._setupListeners();\n  }\n\n  _writePayload(payload) {\n    // Write data to the current file\n    if (this.currentFile) {\n      this.currentFile.write(payload);\n    }\n  }\n\n  _setupListeners() {\n    this.on(exports.SlpStreamEvent.RAW, data => {\n      const {\n        command,\n        payload\n      } = data;\n\n      switch (command) {\n        case exports.Command.MESSAGE_SIZES:\n          // Create the new game first before writing the payload\n          this._handleNewGame();\n\n          this._writePayload(payload);\n\n          break;\n\n        case exports.Command.GAME_END:\n          // Write payload first before ending the game\n          this._writePayload(payload);\n\n          this._handleEndGame();\n\n          break;\n\n        default:\n          this._writePayload(payload);\n\n          break;\n      }\n    });\n  }\n  /**\r\n   * Return the name of the SLP file currently being written or null if\r\n   * no file is being written to currently.\r\n   *\r\n   * @returns {(string | null)}\r\n   * @memberof SlpFileWriter\r\n   */\n\n\n  getCurrentFilename() {\n    if (this.currentFile !== null) {\n      return path__default[\"default\"].resolve(this.currentFile.path());\n    }\n\n    return null;\n  }\n  /**\r\n   * Ends the current file being written to.\r\n   *\r\n   * @returns {(string | null)}\r\n   * @memberof SlpFileWriter\r\n   */\n\n\n  endCurrentFile() {\n    this._handleEndGame();\n  }\n  /**\r\n   * Updates the settings to be the desired ones passed in.\r\n   *\r\n   * @param {Partial<SlpFileWriterOptions>} settings\r\n   * @memberof SlpFileWriter\r\n   */\n\n\n  updateSettings(settings) {\n    this.options = Object.assign({}, this.options, settings);\n  }\n\n  _handleNewGame() {\n    // Only create a new file if we're outputting files\n    if (this.options.outputFiles) {\n      const filePath = this.options.newFilename(this.options.folderPath, new Date());\n      this.currentFile = new SlpFile(filePath, this); // console.log(`Creating new file at: ${filePath}`);\n\n      this.emit(exports.SlpFileWriterEvent.NEW_FILE, filePath);\n    }\n  }\n\n  _handleEndGame() {\n    // End the stream\n    if (this.currentFile) {\n      // Set the console nickname\n      this.currentFile.setMetadata({\n        consoleNickname: this.options.consoleNickname\n      });\n      this.currentFile.end(); // console.log(`Finished writing file: ${this.currentFile.path()}`);\n\n      this.emit(exports.SlpFileWriterEvent.FILE_COMPLETE, this.currentFile.path()); // Clear current file\n\n      this.currentFile = null;\n    }\n  }\n\n}\n\nclass RollbackCounter {\n  constructor() {\n    this.rollbackFrames = {};\n    this.rollbackFrameCount = 0;\n    this.rollbackPlayerIdx = null;\n    this.lastFrameWasRollback = false;\n    this.currentRollbackLength = 0;\n    this.rollbackLengths = [];\n  }\n\n  checkIfRollbackFrame(currentFrame, playerIdx) {\n    if (this.rollbackPlayerIdx === null) {\n      // we only want to follow a single player to avoid double counting. So we use whoever is on first.\n      this.rollbackPlayerIdx = playerIdx;\n    } else if (this.rollbackPlayerIdx !== playerIdx) {\n      return;\n    }\n\n    if (currentFrame && currentFrame.players) {\n      // frame already exists for currentFrameNumber so we must be rolling back\n      // Note: We detect during PreFrameUpdate, but new versions have a\n      // FrameStart command that has already initialized the frame, so we must\n      // check for player data too.\n      if (this.rollbackFrames[currentFrame.frame]) {\n        this.rollbackFrames[currentFrame.frame].push(currentFrame);\n      } else {\n        this.rollbackFrames[currentFrame.frame] = [currentFrame];\n      }\n\n      this.rollbackFrameCount++;\n      this.currentRollbackLength++;\n      this.lastFrameWasRollback = true;\n    } else if (this.lastFrameWasRollback) {\n      this.rollbackLengths.push(this.currentRollbackLength);\n      this.currentRollbackLength = 0;\n      this.lastFrameWasRollback = false;\n    }\n\n    return this.lastFrameWasRollback;\n  }\n\n  getFrames() {\n    return this.rollbackFrames;\n  }\n\n  getCount() {\n    return this.rollbackFrameCount;\n  }\n\n  getLengths() {\n    return this.rollbackLengths;\n  }\n\n}\n\nconst ITEM_SETTINGS_BIT_COUNT = 40;\nconst MAX_ROLLBACK_FRAMES = 7;\nexports.SlpParserEvent = void 0;\n\n(function (SlpParserEvent) {\n  SlpParserEvent[\"SETTINGS\"] = \"settings\";\n  SlpParserEvent[\"END\"] = \"end\";\n  SlpParserEvent[\"FRAME\"] = \"frame\";\n  SlpParserEvent[\"FINALIZED_FRAME\"] = \"finalized-frame\";\n  SlpParserEvent[\"ROLLBACK_FRAME\"] = \"rollback-frame\";\n})(exports.SlpParserEvent || (exports.SlpParserEvent = {})); // If strict mode is on, we will do strict validation checking\n// which could throw errors on invalid data.\n// Default to false though since probably only real time applications\n// would care about valid data.\n\n\nconst defaultSlpParserOptions = {\n  strict: false\n};\nclass SlpParser extends events.EventEmitter {\n  constructor(options) {\n    super();\n    this.frames = {};\n    this.rollbackCounter = new RollbackCounter();\n    this.settings = null;\n    this.gameEnd = null;\n    this.latestFrameIndex = null;\n    this.settingsComplete = false;\n    this.lastFinalizedFrame = exports.Frames.FIRST - 1;\n    this.options = void 0;\n    this.geckoList = null;\n    this.options = Object.assign({}, defaultSlpParserOptions, options);\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  handleCommand(command, payload) {\n    switch (command) {\n      case exports.Command.GAME_START:\n        this._handleGameStart(payload);\n\n        break;\n\n      case exports.Command.FRAME_START:\n        this._handleFrameStart(payload);\n\n        break;\n\n      case exports.Command.POST_FRAME_UPDATE:\n        // We need to handle the post frame update first since that\n        // will finalize the settings object, before we fire the frame update\n        this._handlePostFrameUpdate(payload);\n\n        this._handleFrameUpdate(command, payload);\n\n        break;\n\n      case exports.Command.PRE_FRAME_UPDATE:\n        this._handleFrameUpdate(command, payload);\n\n        break;\n\n      case exports.Command.ITEM_UPDATE:\n        this._handleItemUpdate(payload);\n\n        break;\n\n      case exports.Command.FRAME_BOOKEND:\n        this._handleFrameBookend(payload);\n\n        break;\n\n      case exports.Command.GAME_END:\n        this._handleGameEnd(payload);\n\n        break;\n\n      case exports.Command.GECKO_LIST:\n        this._handleGeckoList(payload);\n\n        break;\n    }\n  }\n  /**\r\n   * Resets the parser state to their default values.\r\n   */\n\n\n  reset() {\n    this.frames = {};\n    this.settings = null;\n    this.gameEnd = null;\n    this.latestFrameIndex = null;\n    this.settingsComplete = false;\n    this.lastFinalizedFrame = exports.Frames.FIRST - 1;\n  }\n\n  getLatestFrameNumber() {\n    var _this$latestFrameInde;\n\n    return (_this$latestFrameInde = this.latestFrameIndex) != null ? _this$latestFrameInde : exports.Frames.FIRST - 1;\n  }\n\n  getPlayableFrameCount() {\n    if (this.latestFrameIndex === null) {\n      return 0;\n    }\n\n    return this.latestFrameIndex < exports.Frames.FIRST_PLAYABLE ? 0 : this.latestFrameIndex - exports.Frames.FIRST_PLAYABLE;\n  }\n\n  getLatestFrame() {\n    // return this.playerFrames[this.latestFrameIndex];\n    // TODO: Modify this to check if we actually have all the latest frame data and return that\n    // TODO: If we do. For now I'm just going to take a shortcut\n    const allFrames = this.getFrames();\n    const frameIndex = this.latestFrameIndex !== null ? this.latestFrameIndex : exports.Frames.FIRST;\n    const indexToUse = this.gameEnd ? frameIndex : frameIndex - 1;\n    return lodash.get(allFrames, indexToUse) || null;\n  }\n\n  getSettings() {\n    return this.settingsComplete ? this.settings : null;\n  }\n\n  getItems() {\n    var _this$settings, _this$settings2;\n\n    if (((_this$settings = this.settings) == null ? void 0 : _this$settings.itemSpawnBehavior) === exports.ItemSpawnType.OFF) {\n      return null;\n    }\n\n    const itemBitfield = (_this$settings2 = this.settings) == null ? void 0 : _this$settings2.enabledItems;\n\n    if (!exists(itemBitfield)) {\n      return null;\n    }\n\n    const enabledItems = []; // Ideally we would be able to do this with bitshifting instead, but javascript\n    // truncates numbers after 32 bits when doing bitwise operations\n\n    for (let i = 0; i < ITEM_SETTINGS_BIT_COUNT; i++) {\n      if (Math.floor(itemBitfield / 2 ** i) & 1) {\n        enabledItems.push(2 ** i);\n      }\n    }\n\n    return enabledItems;\n  }\n\n  getGameEnd() {\n    return this.gameEnd;\n  }\n\n  getFrames() {\n    return this.frames;\n  }\n\n  getRollbackFrames() {\n    return {\n      frames: this.rollbackCounter.getFrames(),\n      count: this.rollbackCounter.getCount(),\n      lengths: this.rollbackCounter.getLengths()\n    };\n  }\n\n  getFrame(num) {\n    return this.frames[num] || null;\n  }\n\n  getGeckoList() {\n    return this.geckoList;\n  }\n\n  _handleGeckoList(payload) {\n    this.geckoList = payload;\n  }\n\n  _handleGameEnd(payload) {\n    // Finalize remaining frames if necessary\n    if (this.latestFrameIndex !== null && this.latestFrameIndex !== this.lastFinalizedFrame) {\n      this._finalizeFrames(this.latestFrameIndex);\n    }\n\n    payload = payload;\n    this.gameEnd = payload;\n    this.emit(exports.SlpParserEvent.END, this.gameEnd);\n  }\n\n  _handleGameStart(payload) {\n    this.settings = payload;\n    const players = payload.players;\n    this.settings.players = players.filter(player => player.type !== 3); // Check to see if the file was created after the sheik fix so we know\n    // we don't have to process the first frame of the game for the full settings\n\n    if (payload.slpVersion && semver__default[\"default\"].gte(payload.slpVersion, \"1.6.0\")) {\n      this._completeSettings();\n    }\n  }\n\n  _handleFrameStart(payload) {\n    const currentFrameNumber = payload.frame;\n    lodash.set(this.frames, [currentFrameNumber, \"start\"], payload);\n  }\n\n  _handlePostFrameUpdate(payload) {\n    if (this.settingsComplete) {\n      return;\n    } // Finish calculating settings\n\n\n    if (payload.frame <= exports.Frames.FIRST) {\n      const playerIndex = payload.playerIndex;\n      const playersByIndex = lodash.keyBy(this.settings.players, \"playerIndex\");\n\n      switch (payload.internalCharacterId) {\n        case 0x7:\n          playersByIndex[playerIndex].characterId = 0x13; // Sheik\n\n          break;\n\n        case 0x13:\n          playersByIndex[playerIndex].characterId = 0x12; // Zelda\n\n          break;\n      }\n    }\n\n    if (payload.frame > exports.Frames.FIRST) {\n      this._completeSettings();\n    }\n  }\n\n  _handleFrameUpdate(command, payload) {\n    payload = payload;\n    const location = command === exports.Command.PRE_FRAME_UPDATE ? \"pre\" : \"post\";\n    const field = payload.isFollower ? \"followers\" : \"players\";\n    const currentFrameNumber = payload.frame;\n    this.latestFrameIndex = currentFrameNumber;\n\n    if (location === \"pre\" && !payload.isFollower) {\n      const currentFrame = this.frames[currentFrameNumber];\n      const wasRolledback = this.rollbackCounter.checkIfRollbackFrame(currentFrame, payload.playerIndex);\n\n      if (wasRolledback) {\n        // frame is about to be overwritten\n        this.emit(exports.SlpParserEvent.ROLLBACK_FRAME, currentFrame);\n      }\n    }\n\n    lodash.set(this.frames, [currentFrameNumber, field, payload.playerIndex, location], payload);\n    lodash.set(this.frames, [currentFrameNumber, \"frame\"], currentFrameNumber); // If file is from before frame bookending, add frame to stats computer here. Does a little\n    // more processing than necessary, but it works\n\n    const settings = this.getSettings();\n\n    if (settings && (!settings.slpVersion || semver__default[\"default\"].lte(settings.slpVersion, \"2.2.0\"))) {\n      this.emit(exports.SlpParserEvent.FRAME, this.frames[currentFrameNumber]); // Finalize the previous frame since no bookending exists\n\n      this._finalizeFrames(currentFrameNumber - 1);\n    } else {\n      lodash.set(this.frames, [currentFrameNumber, \"isTransferComplete\"], false);\n    }\n  }\n\n  _handleItemUpdate(payload) {\n    var _this$frames$currentF, _this$frames$currentF2;\n\n    const currentFrameNumber = payload.frame;\n    const items = (_this$frames$currentF = (_this$frames$currentF2 = this.frames[currentFrameNumber]) == null ? void 0 : _this$frames$currentF2.items) != null ? _this$frames$currentF : [];\n    items.push(payload); // Set items with newest\n\n    lodash.set(this.frames, [currentFrameNumber, \"items\"], items);\n  }\n\n  _handleFrameBookend(payload) {\n    const latestFinalizedFrame = payload.latestFinalizedFrame;\n    const currentFrameNumber = payload.frame;\n    lodash.set(this.frames, [currentFrameNumber, \"isTransferComplete\"], true); // Fire off a normal frame event\n\n    this.emit(exports.SlpParserEvent.FRAME, this.frames[currentFrameNumber]); // Finalize frames if necessary\n\n    const validLatestFrame = this.settings.gameMode === exports.GameMode.ONLINE;\n\n    if (validLatestFrame && latestFinalizedFrame >= exports.Frames.FIRST) {\n      // Ensure valid latestFinalizedFrame\n      if (this.options.strict && latestFinalizedFrame < currentFrameNumber - MAX_ROLLBACK_FRAMES) {\n        throw new Error(`latestFinalizedFrame should be within ${MAX_ROLLBACK_FRAMES} frames of ${currentFrameNumber}`);\n      }\n\n      this._finalizeFrames(latestFinalizedFrame);\n    } else {\n      // Since we don't have a valid finalized frame, just finalize the frame based on MAX_ROLLBACK_FRAMES\n      this._finalizeFrames(currentFrameNumber - MAX_ROLLBACK_FRAMES);\n    }\n  }\n  /**\r\n   * Fires off the FINALIZED_FRAME event for frames up until a certain number\r\n   * @param num The frame to finalize until\r\n   */\n\n\n  _finalizeFrames(num) {\n    while (this.lastFinalizedFrame < num) {\n      const frameToFinalize = this.lastFinalizedFrame + 1;\n      const frame = this.getFrame(frameToFinalize); // Check that we have all the pre and post frame data for all players if we're in strict mode\n\n      if (this.options.strict) {\n        for (const player of this.settings.players) {\n          const playerFrameInfo = frame.players[player.playerIndex]; // Allow player frame info to be empty in non 1v1 games since\n          // players which have been defeated will have no frame info.\n\n          if (this.settings.players.length > 2 && !playerFrameInfo) {\n            continue;\n          }\n\n          const {\n            pre,\n            post\n          } = playerFrameInfo;\n\n          if (!pre || !post) {\n            const preOrPost = pre ? \"pre\" : \"post\";\n            throw new Error(`Could not finalize frame ${frameToFinalize} of ${num}: missing ${preOrPost}-frame update for player ${player.playerIndex}`);\n          }\n        }\n      } // Our frame is complete so finalize the frame\n\n\n      this.emit(exports.SlpParserEvent.FINALIZED_FRAME, frame);\n      this.lastFinalizedFrame = frameToFinalize;\n    }\n  }\n\n  _completeSettings() {\n    if (!this.settingsComplete) {\n      this.settingsComplete = true;\n      this.emit(exports.SlpParserEvent.SETTINGS, this.settings);\n    }\n  }\n\n}\n\nfunction getWinners(gameEnd, settings, finalPostFrameUpdates) {\n  var _players$find$teamId, _players$find2;\n\n  const {\n    placements,\n    gameEndMethod,\n    lrasInitiatorIndex\n  } = gameEnd;\n  const {\n    players,\n    isTeams\n  } = settings;\n\n  if (gameEndMethod === exports.GameEndMethod.NO_CONTEST || gameEndMethod === exports.GameEndMethod.UNRESOLVED) {\n    // The winner is the person who didn't LRAS\n    if (exists(lrasInitiatorIndex) && players.length === 2) {\n      var _players$find;\n\n      const winnerIndex = (_players$find = players.find(({\n        playerIndex\n      }) => playerIndex !== lrasInitiatorIndex)) == null ? void 0 : _players$find.playerIndex;\n\n      if (exists(winnerIndex)) {\n        return [{\n          playerIndex: winnerIndex,\n          position: 0\n        }];\n      }\n    }\n\n    return [];\n  }\n\n  if (gameEndMethod === exports.GameEndMethod.TIME && players.length === 2) {\n    const nonFollowerUpdates = finalPostFrameUpdates.filter(pfu => !pfu.isFollower);\n\n    if (nonFollowerUpdates.length !== players.length) {\n      return [];\n    }\n\n    const p1 = nonFollowerUpdates[0];\n    const p2 = nonFollowerUpdates[1];\n\n    if (p1.stocksRemaining > p2.stocksRemaining) {\n      return [{\n        playerIndex: p1.playerIndex,\n        position: 0\n      }];\n    } else if (p2.stocksRemaining > p1.stocksRemaining) {\n      return [{\n        playerIndex: p2.playerIndex,\n        position: 0\n      }];\n    }\n\n    const p1Health = Math.trunc(p1.percent);\n    const p2Health = Math.trunc(p2.percent);\n\n    if (p1Health < p2Health) {\n      return [{\n        playerIndex: p1.playerIndex,\n        position: 0\n      }];\n    } else if (p2Health < p1Health) {\n      return [{\n        playerIndex: p2.playerIndex,\n        position: 0\n      }];\n    } // If stocks and percents were tied, no winner\n\n\n    return [];\n  }\n\n  const firstPosition = placements.find(placement => placement.position === 0);\n\n  if (!firstPosition) {\n    return [];\n  }\n\n  const winningTeam = (_players$find$teamId = (_players$find2 = players.find(({\n    playerIndex\n  }) => playerIndex === firstPosition.playerIndex)) == null ? void 0 : _players$find2.teamId) != null ? _players$find$teamId : null;\n\n  if (isTeams && exists(winningTeam)) {\n    return placements.filter(placement => {\n      var _players$find$teamId2, _players$find3;\n\n      const teamId = (_players$find$teamId2 = (_players$find3 = players.find(({\n        playerIndex\n      }) => playerIndex === placement.playerIndex)) == null ? void 0 : _players$find3.teamId) != null ? _players$find$teamId2 : null;\n      return teamId === winningTeam;\n    });\n  }\n\n  return [firstPosition];\n}\n\nconst SANDBAG_INTERNAL_ID = 32;\nconst FEET_CONVERSION_FACTOR = 0.952462;\nconst METERS_CONVERSION_FACTOR = 1.04167;\nfunction positionToHomeRunDistance(distance, units = \"feet\") {\n  let score = 0;\n\n  switch (units) {\n    case \"feet\":\n      score = 10 * Math.floor(distance - 70 * FEET_CONVERSION_FACTOR); // convert to float32\n\n      score = Math.fround(score);\n      score = Math.floor(score / 30.4788 * 10) / 10;\n      break;\n\n    case \"meters\":\n      score = 10 * Math.floor(distance - 70 * METERS_CONVERSION_FACTOR); // convert to float32\n\n      score = Math.fround(score);\n      score = Math.floor(score / 100 * 10) / 10;\n      break;\n\n    default:\n      throw new Error(`Unsupported units: ${units}`);\n  } // round to 1 decimal\n\n\n  score = Math.round(score * 10) / 10;\n  return Math.max(0, score);\n}\nfunction extractDistanceInfoFromFrame(settings, lastFrame) {\n  var _sandbagLastFrame$pos;\n\n  const sandbagLastFrame = Object.values(lastFrame.players).filter(exists).find(playerFrame => playerFrame.post.internalCharacterId === SANDBAG_INTERNAL_ID);\n\n  if (!sandbagLastFrame) {\n    return null;\n  } // Only return the distance in meters if it's a Japanese replay.\n  // Technically we should check if the replay is PAL but we don't yet support\n  // stadium replays in PAL.\n\n\n  const units = settings.language === exports.Language.JAPANESE ? \"meters\" : \"feet\";\n  const distance = positionToHomeRunDistance((_sandbagLastFrame$pos = sandbagLastFrame.post.positionX) != null ? _sandbagLastFrame$pos : 0, units);\n  return {\n    distance,\n    units\n  };\n}\n\n/**\r\n * Slippi Game class that wraps a file\r\n */\n\nclass SlippiGame {\n  constructor(input, opts) {\n    this.input = void 0;\n    this.metadata = null;\n    this.finalStats = null;\n    this.parser = void 0;\n    this.readPosition = null;\n    this.actionsComputer = new ActionsComputer();\n    this.conversionComputer = new ConversionComputer();\n    this.comboComputer = new ComboComputer();\n    this.stockComputer = new StockComputer();\n    this.inputComputer = new InputComputer();\n    this.targetBreakComputer = new TargetBreakComputer();\n    this.statsComputer = void 0;\n\n    if (typeof input === \"string\") {\n      this.input = {\n        source: exports.SlpInputSource.FILE,\n        filePath: input\n      };\n    } else if (input instanceof Buffer) {\n      this.input = {\n        source: exports.SlpInputSource.BUFFER,\n        buffer: input\n      };\n    } else if (input instanceof ArrayBuffer) {\n      this.input = {\n        source: exports.SlpInputSource.BUFFER,\n        buffer: Buffer.from(input)\n      };\n    } else {\n      throw new Error(\"Cannot create SlippiGame with input of that type\");\n    } // Set up stats calculation\n\n\n    this.statsComputer = new Stats(opts);\n    this.statsComputer.register(this.actionsComputer, this.comboComputer, this.conversionComputer, this.inputComputer, this.stockComputer, this.targetBreakComputer);\n    this.parser = new SlpParser();\n    this.parser.on(exports.SlpParserEvent.SETTINGS, settings => {\n      this.statsComputer.setup(settings);\n    }); // Use finalized frames for stats computation\n\n    this.parser.on(exports.SlpParserEvent.FINALIZED_FRAME, frame => {\n      this.statsComputer.addFrame(frame);\n    });\n  }\n\n  _process(shouldStop = () => false, file) {\n    if (this.parser.getGameEnd() !== null) {\n      return;\n    }\n\n    const slpfile = file != null ? file : openSlpFile(this.input); // Generate settings from iterating through file\n\n    this.readPosition = iterateEvents(slpfile, (command, payload) => {\n      if (!payload) {\n        // If payload is falsy, keep iterating. The parser probably just doesn't know\n        // about this command yet\n        return false;\n      }\n\n      this.parser.handleCommand(command, payload);\n      return shouldStop(command, payload);\n    }, this.readPosition);\n\n    if (!file) {\n      closeSlpFile(slpfile);\n    }\n  }\n  /**\r\n   * Gets the game settings, these are the settings that describe the starting state of\r\n   * the game such as characters, stage, etc.\r\n   */\n\n\n  getSettings() {\n    // Settings is only complete after post-frame update\n    this._process(() => this.parser.getSettings() !== null);\n\n    return this.parser.getSettings();\n  }\n\n  getItems() {\n    this._process();\n\n    return this.parser.getItems();\n  }\n\n  getLatestFrame() {\n    this._process();\n\n    return this.parser.getLatestFrame();\n  }\n\n  getGameEnd(options = {}) {\n    if (options != null && options.skipProcessing) {\n      // Read game end block directly\n      const slpfile = openSlpFile(this.input);\n      const gameEnd = getGameEnd(slpfile);\n      closeSlpFile(slpfile);\n      return gameEnd;\n    }\n\n    this._process();\n\n    return this.parser.getGameEnd();\n  }\n\n  getFrames() {\n    this._process();\n\n    return this.parser.getFrames();\n  }\n\n  getRollbackFrames() {\n    this._process();\n\n    return this.parser.getRollbackFrames();\n  }\n\n  getGeckoList() {\n    this._process(() => this.parser.getGeckoList() !== null);\n\n    return this.parser.getGeckoList();\n  }\n\n  getStats() {\n    if (this.finalStats) {\n      return this.finalStats;\n    }\n\n    this._process();\n\n    const settings = this.parser.getSettings();\n\n    if (!settings) {\n      return null;\n    } // Finish processing if we're not up to date\n\n\n    this.statsComputer.process();\n    const inputs = this.inputComputer.fetch();\n    const stocks = this.stockComputer.fetch();\n    const conversions = this.conversionComputer.fetch();\n    const playableFrameCount = this.parser.getPlayableFrameCount();\n    const overall = generateOverallStats({\n      settings,\n      inputs,\n      conversions,\n      playableFrameCount\n    });\n    const gameEnd = this.parser.getGameEnd();\n    const gameComplete = gameEnd !== null;\n    const stats = {\n      lastFrame: this.parser.getLatestFrameNumber(),\n      playableFrameCount,\n      stocks: stocks,\n      conversions: conversions,\n      combos: this.comboComputer.fetch(),\n      actionCounts: this.actionsComputer.fetch(),\n      overall: overall,\n      gameComplete\n    };\n\n    if (gameComplete) {\n      // If the game is complete, store a cached version of stats because it should not\n      // change anymore. Ideally the statsCompuer.process and fetch functions would simply do no\n      // work in this case instead but currently the conversions fetch function,\n      // generateOverallStats, and maybe more are doing work on every call.\n      this.finalStats = stats;\n    }\n\n    return stats;\n  }\n\n  getStadiumStats() {\n    this._process();\n\n    const settings = this.parser.getSettings();\n\n    if (!settings) {\n      return null;\n    }\n\n    const latestFrame = this.parser.getLatestFrame();\n    const players = latestFrame == null ? void 0 : latestFrame.players;\n\n    if (!players) {\n      return null;\n    }\n\n    this.statsComputer.process();\n\n    switch (settings.gameMode) {\n      case exports.GameMode.TARGET_TEST:\n        return {\n          type: \"target-test\",\n          targetBreaks: this.targetBreakComputer.fetch()\n        };\n\n      case exports.GameMode.HOME_RUN_CONTEST:\n        const distanceInfo = extractDistanceInfoFromFrame(settings, latestFrame);\n\n        if (!distanceInfo) {\n          return null;\n        }\n\n        return {\n          type: \"home-run-contest\",\n          distance: distanceInfo.distance,\n          units: distanceInfo.units\n        };\n\n      default:\n        return null;\n    }\n  }\n\n  getMetadata() {\n    if (this.metadata) {\n      return this.metadata;\n    }\n\n    const slpfile = openSlpFile(this.input);\n    this.metadata = getMetadata(slpfile);\n    closeSlpFile(slpfile);\n    return this.metadata;\n  }\n\n  getFilePath() {\n    var _this$input$filePath;\n\n    if (this.input.source !== exports.SlpInputSource.FILE) {\n      return null;\n    }\n\n    return (_this$input$filePath = this.input.filePath) != null ? _this$input$filePath : null;\n  }\n\n  getWinners() {\n    // Read game end block directly\n    const slpfile = openSlpFile(this.input);\n    const gameEnd = getGameEnd(slpfile);\n\n    this._process(() => this.parser.getSettings() !== null, slpfile);\n\n    const settings = this.parser.getSettings();\n\n    if (!gameEnd || !settings) {\n      // Technically using the final post frame updates, it should be possible to compute winners for\n      // replays without a gameEnd message. But I'll leave this here anyway\n      closeSlpFile(slpfile);\n      return [];\n    } // If we went to time, let's fetch the post frame updates to compute the winner\n\n\n    let finalPostFrameUpdates = [];\n\n    if (gameEnd.gameEndMethod === exports.GameEndMethod.TIME) {\n      finalPostFrameUpdates = extractFinalPostFrameUpdates(slpfile);\n    }\n\n    closeSlpFile(slpfile);\n    return getWinners(gameEnd, settings, finalPostFrameUpdates);\n  }\n\n}\n\nexports.ActionsComputer = ActionsComputer;\nexports.ComboComputer = ComboComputer;\nexports.ConsoleCommunication = ConsoleCommunication;\nexports.ConsoleConnection = ConsoleConnection;\nexports.ConversionComputer = ConversionComputer;\nexports.DolphinConnection = DolphinConnection;\nexports.InputComputer = InputComputer;\nexports.MAX_ROLLBACK_FRAMES = MAX_ROLLBACK_FRAMES;\nexports.NETWORK_MESSAGE = NETWORK_MESSAGE;\nexports.SlippiGame = SlippiGame;\nexports.SlpFile = SlpFile;\nexports.SlpFileWriter = SlpFileWriter;\nexports.SlpParser = SlpParser;\nexports.SlpStream = SlpStream;\nexports.Stats = Stats;\nexports.StockComputer = StockComputer;\nexports.TargetBreakComputer = TargetBreakComputer;\nexports.Timers = Timers;\nexports.animations = animationUtils;\nexports.calcDamageTaken = calcDamageTaken;\nexports.characters = characterUtils;\nexports.closeSlpFile = closeSlpFile;\nexports.didLoseStock = didLoseStock;\nexports.extractFinalPostFrameUpdates = extractFinalPostFrameUpdates;\nexports.frameToGameTimer = frameToGameTimer;\nexports.generateOverallStats = generateOverallStats;\nexports.getGameEnd = getGameEnd;\nexports.getMetadata = getMetadata;\nexports.getSinglesPlayerPermutationsFromSettings = getSinglesPlayerPermutationsFromSettings;\nexports.isCommandGrabbed = isCommandGrabbed;\nexports.isDamaged = isDamaged;\nexports.isDead = isDead;\nexports.isDown = isDown;\nexports.isGrabbed = isGrabbed;\nexports.isInControl = isInControl;\nexports.isTeching = isTeching;\nexports.iterateEvents = iterateEvents;\nexports.moves = moveUtils;\nexports.openSlpFile = openSlpFile;\nexports.parseMessage = parseMessage;\nexports.stages = stageUtils;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}